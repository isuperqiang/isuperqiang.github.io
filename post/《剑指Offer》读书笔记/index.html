<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>《剑指Offer》读书笔记 | 落英坠露</title>
<meta name="description" content="技术让生活更美好">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://isuperqiang.github.io/favicon.ico?v=1557649212127">
<link rel="stylesheet" href="https://isuperqiang.github.io/styles/main.css">


  
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css" />
  

  


<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>

<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />



  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://isuperqiang.github.io">
        <img src="https://isuperqiang.github.io/images/avatar.png?v=1557649212127" class="site-logo">
        <h1 class="site-title">落英坠露</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="https://isuperqiang.github.io" class="site-nav">
            首页
          </a>
        
      
        
          <a href="https://isuperqiang.github.io/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="https://isuperqiang.github.io/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="https://isuperqiang.github.io/post/about/" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      技术让生活更美好
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">《剑指Offer》读书笔记</h2>
            <div class="post-date">2017-06-23</div>
            
            <div class="post-content">
              <h2 id="第一章-面试的流程">第一章 面试的流程</h2>
<h3 id="11-面试官谈面试">1.1 面试官谈面试</h3>
<ol>
<li>对于初级程序员，一般偏向考察算法和数据结构，看应聘者的基本功；对于高级程序员，多关注专业技能和项目经验。</li>
<li>应聘者要事先做好准备，对公司近况、项目情况有所了解，对应聘的工作怀有热情，还要准备好合适的问题问面试官。</li>
<li>应聘者在面试的过程中首先需要放松，不要过于紧张，这有助于后面解决问题时开拓思路。其次不要急于编写代码，应该先了解清楚所要解决的问题。</li>
<li>应聘技术岗位就是要踏实写程序。</li>
</ol>
<h3 id="12-面试的三种形式">1.2 面试的三种形式</h3>
<h4 id="121-电话面试">1.2.1 电话面试</h4>
<p>应聘者在电话面试的时候，应该尽可能用形象的语言把细节说出来。</p>
<h4 id="122-共享桌面远程面试">1.2.2 共享桌面远程面试</h4>
<p>考察的是应聘者的编程习惯和调试能力。</p>
<p>面试官认可的几种编程习惯：</p>
<ul>
<li>思考清楚再开始编码</li>
<li>良好的代码命名和缩进对齐习惯</li>
<li>能够单元测试，测试在前、开发在后</li>
</ul>
<h4 id="123-现场面试">1.2.3 现场面试</h4>
<ul>
<li>规划好路线并估算出行时间，不要迟到</li>
<li>准备好得体的衣服，干净舒服即可</li>
<li>注意面试邀请函里的面试流程</li>
<li>提前准备几个问题</li>
</ul>
<h3 id="13-面试的三个环节">1.3 面试的三个环节</h3>
<h4 id="131-行为面试">1.3.1 行为面试</h4>
<p>面试开始的 5--10 分钟是行为面试时间，简短的自我介绍（30秒 -- 1分钟）。</p>
<h5 id="1-应聘者的项目经验">1. 应聘者的项目经验</h5>
<p>STAR 模型： Situation → Task → Action → Result</p>
<ul>
<li>Situation：简短的项目背景，功能、目标用户等。</li>
<li>Task：自己完成的任务，注意区分「参与」和「负责」。</li>
<li>Action：为了完成任务做了哪些工作，是怎么做的，这里可以详细介绍。</li>
<li>Result：自己的贡献，最好能用数字说明。</li>
</ul>
<blockquote>
<p>Winforms 是微软 .NET 中的一个成熟的 UI 平台（Situation）。本人的工作是在添加少量新功能之外主要负责维护已有的功能（Task）。新功能主要是让 Winforms 的控件的风格和 Visa、Win 7 的风格保持一致。在维护方面，对于较难的问题，我用 WinDbg 等工具进行调试（Action）。在过去的两年中，我总共修改了超过 200 个 Bug（Result）。</p>
</blockquote>
<p>面试官可能的追问：</p>
<ul>
<li>你在该项目中遇到的最大问题是什么？怎么解决的？</li>
<li>从这个项目中学到了什么？</li>
<li>什么时候会和其他团队成员产生冲突？怎么解决的？</li>
</ul>
<p>在介绍项目经验时，应聘者不必详述项目的背景，而要突出介绍自己完成的工作以及取得的成就。</p>
<h5 id="2-应聘者掌握的技能">2. 应聘者掌握的技能</h5>
<p>描述技能时，注意「了解」、「熟悉」和「精通」区别。</p>
<ul>
<li>「了解」指对某个技术只是上过课或者看过书，没有做过实际的项目。通常不建议在简历中列出只是肤浅地了解一点的技能，除非是应聘的职位的确需要。</li>
<li>简历中描述技能掌握的程度大部分应该是「熟悉」，使用某一技术较长时间，可以独立解决大部分问题，我们就熟悉它了。</li>
<li>对某一技术得心应手，别人请教的问题都有信心、有能力解决，这个时候可以说精通。应聘者不要试图把自己修饰成「高人」而轻易使用「精通」，除非自己能够很轻松地回答该领域里绝大多数的问题。</li>
</ul>
<h5 id="3-回答为什么跳槽">3. 回答「为什么跳槽」</h5>
<p>在回答这个问题时不要抱怨，也不要流露出负面的情绪。</p>
<p>应聘者应该避免以下四个原因：</p>
<ul>
<li>老板太苛刻</li>
<li>同事相处太难</li>
<li>加班太频繁</li>
<li>工资太低</li>
</ul>
<p>通常给出的答案是：现在的工作做了一段时间，已经没有太多的激情了，因此希望寻找一份更有挑战的工作。然后具体论述为什么有些厌倦现在的职位，以及面试的职位我为什么会有兴趣。</p>
<h4 id="132-技术面试">1.3.2 技术面试</h4>
<p><strong>应聘者需要具备的素质：</strong></p>
<ol>
<li>
<h5 id="扎实的基础知识">扎实的基础知识</h5>
</li>
</ol>
<p>扎实的基本功表现在三个方面：</p>
<ul>
<li>编程语言：要掌握一两门编程语言。</li>
<li>数据结构：要熟练掌握链表、树、栈、队列和哈希表等数据结构以及它们的操作。</li>
<li>算法：要了解各种查找和排序算法，重点掌握二分查找、归并排序和快速排序。</li>
</ul>
<ol start="2">
<li>
<h5 id="高质量的代码">高质量的代码</h5>
</li>
</ol>
<p>在面试过程中，面试官总会格外关注边界条件、特殊输入（空指针、空字符串等）等看似细枝末节但实质至关重要的地方，以考察应聘者是否注重代码质量。</p>
<p>最好的办法是在动手写代码之后想好测试用例。写完代码后，现在心里默默运行，再把代码交给面试官。</p>
<ol start="3">
<li>
<h5 id="清晰的思路">清晰的思路</h5>
</li>
</ol>
<p>在面试中遇到难题，一般有三种办法分析、解决：</p>
<ul>
<li>画图使抽象问题形象化</li>
<li>举例使抽象问题具体化</li>
<li>分解使复杂问题简单化</li>
</ul>
<h5 id="4-优化效率的能力">4. 优化效率的能力</h5>
<p>优秀的程序员对时间和内存的消耗锱铢必较，他们很有激情不断优化自己的代码。当面试官的题目有多种解法时，他们通常期待得到最优解。</p>
<ul>
<li>首先要知道如何分析效率。即使同一种算法，用不同的方法实现的效率可能大不相同。</li>
<li>还要熟悉各种数据结构的优缺点，并能选择合适的数据结构解决问题。</li>
<li>也要熟练掌握常用的算法，最常用的算法是查找和排序。</li>
</ul>
<ol start="5">
<li>
<h5 id="优秀的综合能力">优秀的综合能力</h5>
</li>
</ol>
<p>展示自己的软技能（Soft Skills），比如沟通能力、学习能力。</p>
<p>面试官通常有两种办法考察应聘者的学习能力和愿望：</p>
<ul>
<li>询问应聘者最近在看什么书，从中学到了哪些新技术</li>
<li>抛出一个新概念，观察面试者能不能在较短的时间内理解并解决相关问题。</li>
</ul>
<p>知识迁移能力是一种特殊的学习能力。面试官经常会先问一个简单的问题，再问一个复杂但是和前面的问题相关的问题。期待应聘者能够从简单的问题中得到启示，从而找到解决复杂问题的窍门。</p>
<p>还有一些面试官喜欢考察应聘者的抽象建模能力和发散思维能力。</p>
<h4 id="133-应聘者提问环节">1.3.3 应聘者提问环节</h4>
<p>在面试之前多做些功课，为每轮面试准备 2—3 个问题。</p>
<p>注意几点：</p>
<ul>
<li>有些问题不适合在技术面试环节提问，比如公司未来的发展战略。</li>
<li>其次不要问薪水，技术面试不是谈薪水的时候，要谈工资等通过后和 HR 谈。</li>
<li>不要立即打听面试结果，因为面试有好几轮，最终结果是综合评估的。</li>
</ul>
<p>推荐的问题是与应聘的职位或者项目相关的，首先要对职位或者项目背景有一定的了解。面试之前做足功课，到网上收集公司的相关信息（成立时间、主要业务、职位要求等）；二是面试过程中留心面试官说过的话，比如项目进展情况，可以从中找出一两个点向面试官提问。</p>
<h2 id="第二章-面试需要的基础知识">第二章 面试需要的基础知识</h2>
<h3 id="21-面试官谈基础">2.1 面试官谈基础</h3>
<p>面向对象的特性，设计模式，数据结构和算法，编程能力，问题分析和推理能力，并发控制，算法复杂度，计算机系统知识……</p>
<h3 id="22-编程语言">2.2 编程语言</h3>
<h4 id="221-c">2.2.1 C++</h4>
<p><strong>面试题 1：赋值运算符函数</strong></p>
<h4 id="222-c">2.2.2 C####</h4>
<p><strong>面试题 2：单例模式</strong></p>
<h3 id="23-数据结构">2.3 数据结构</h3>
<h4 id="231-数组">2.3.1 数组</h4>
<p>内存连续，按照顺序存储。</p>
<p><strong>面试题 3：二维数组中的查找</strong></p>
<blockquote>
<p>在一个二维数组中，每行都按照从左到右递增的顺序排列，每列都按照从上到下递增的顺序排列。请书写一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
</blockquote>
<p>选取比较点，逐步缩小范围。</p>
<h4 id="232-字符串">2.3.2 字符串</h4>
<p>字符串常量池、字符串不可变。</p>
<p><strong>面试题 4：替换空格</strong></p>
<blockquote>
<p>请实现一个函数，把字符串中的每个空格替换成「%20」。例如输入「We are happy.」，则输出「We%20are%20happy.」。</p>
</blockquote>
<p>首先得到空格的个数，从后向前遍历字符串，遇到空格替换成 %20，所有的字符只需要复制一次，算法的时间复杂度是 O(n)。</p>
<p>合并两个数组（包括字符串）时，如果从前往后复制每个数字（或字符）需要重复移动数字（或字符），那么我们可以考虑从后往前复制，这样就能减少移动的次数，从而提升效率。</p>
<h4 id="233-链表">2.3.3 链表</h4>
<p>链表是一种动态的数据结构，在创建链表时，无须知道链表的长度。内存分配不是在创建链表时一次性完成，而是每添加一个结点分配一次内存，链表的空间利用率比数组高。内存地址不一定连续，查找时的时间复杂度是 O(n)。</p>
<p><strong>面试题 5：从尾到头打印链表</strong></p>
<blockquote>
<p>输入一个链表的头结点，从尾到头打印每个结点的值。</p>
</blockquote>
<ul>
<li>第一个遍历的结点最后一个输出，典型的后进先出，可以使用栈实现这种顺序。</li>
<li>递归在本质上就是一个栈结构，自然可以用递归来实现。（隐藏栈溢出的问题）</li>
</ul>
<h4 id="234-树">2.3.4 树</h4>
<p>二叉树的遍历：</p>
<ul>
<li>前序遍历：根节点 → 左子树 → 右子树</li>
<li>中序遍历：左子树 → 根节点 → 右子树</li>
<li>后序遍历：左子树 → 右子树 → 根节点</li>
</ul>
<p>递归实现比循环实现简单地多。</p>
<p>二叉搜索树（二叉排序树），平均时间复杂度：O(logN)。</p>
<p>红黑树和堆（最大堆和最小堆）</p>
<p><strong>面试题 6：重建二叉树</strong></p>
<blockquote>
<p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，那么重建二叉树并输出它的头结点。</p>
</blockquote>
<p>前序遍历序列中，第一个数字总是树的根节点的值，在根节点左边的值属于左子树，右边的值属于右子树。在前序遍历序列和中序遍历序列找到划分左、右子树的值，递归地构建左右子树。</p>
<h4 id="235-栈和队列">2.3.5 栈和队列</h4>
<p>栈的特点：后进先出；队列的特点：先进先出。</p>
<p><strong>面试题 7：用两个栈实现一个队列</strong></p>
<blockquote>
<p>用两个栈实现一个队列，请实现它的两个函数 appendTail 和 deleteHead，分别完成在队列尾部插入节点和在队列头部删除结点的功能。</p>
</blockquote>
<p>通过具体的例子分析问题，画图的手段把抽象的问题形象化，从而解决相对复杂的问题。</p>
<p>相关题目：用两个队列实现一个栈。</p>
<h3 id="24-算法和数据操作">2.4 算法和数据操作</h3>
<p>排序和查找是面试官考查算法的重点，重点掌握二分查找、归并排序和快速排序，做到随时准确、完整地写出它们的代码。</p>
<p>通常基于递归的实现方法，代码会比较简洁，但是性能不如基于循环的实现方法。</p>
<h4 id="241-查找和排序">2.4.1 查找和排序</h4>
<p>查找相对而言较为简单，不外乎顺序查找、二分查找、哈希表查找和二叉排序树查找。</p>
<p><strong>Tips：</strong></p>
<blockquote>
<p>如果面试题要求在排序的数组（或者部分排序的数组）中查找一个数字或者统计某个数字出现的次数，我们可以尝试使用二分查找算法。</p>
</blockquote>
<p>哈希表最主要的优点就是我们利用它能够在 O(1) 时间内查找某一元素，是效率最高的查找方式，缺点是需要额外的空间来实现哈希表。</p>
<p>与二叉排序树对应的数据结构是二叉搜索树。</p>
<p>排序比查找复杂一些，熟悉插入排序、冒泡排序、归并排序、快速排序等不同算法及其特点。</p>
<p>不同的排序算法适用的场合也不尽相同。在面试的时候，如果面试官要求实现一个排序算法，那么应聘者一定要问清楚这个排序应用的环境是什么、有哪些约束条件，在得到足够多的信息后，再选择最合适的排序算法。</p>
<p><strong>问题 8：旋转数组的最小数字</strong></p>
<blockquote>
<p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如：{3,4,5,1,2} 为 {1,2,3,4,5} 的一个旋转，该数组的最小值为 1。</p>
</blockquote>
<p>思路：旋转后的数组可以划分为两个排序的子数组，而且前面的子数组的元素都大于或者等于后面子数组的元素，最小元素正好是这两个子数组的分界线。在排序数组中，我们可以使用二分查找法实现 O(logN) 的查找。</p>
<p>考查对二分查找的理解，变换了二分查找的条件。</p>
<p>考虑排序数组本身是一个旋转数组的情况，以及数组中有相同数字的特例。</p>
<h4 id="242-递归和循环">2.4.2 递归和循环</h4>
<p>如果我们需要重复地多次计算相同的问题，通常可以选择用递归或者循环两种方式。</p>
<p><strong>Tips：</strong></p>
<blockquote>
<p>通常基于递归实现的代码比基于循环实现的代码要简洁，更加容易实现。如果面试官没有特殊要求，应聘者可以优先采用递归的方法编程。</p>
</blockquote>
<p>递归存在严重的效率（函数调用）、性能（重复计算）和调用栈溢出（层级太多）的问题。</p>
<p><strong>面试题 9：斐波那契数列</strong></p>
<blockquote>
<p>题目一：写一个函数，输入 n，求斐波那契数列的第 n 项。</p>
</blockquote>
<p>低效率的递归方法存在重复计算的问题，面试官不会喜欢。</p>
<p>推荐的做法是用循环实现，从下往上计算，f(0) + f(1) = f(2), f(1) + f(2) = f(3)……这样时间复杂度是 O(n)。</p>
<blockquote>
<p>题目二：一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级。求该青蛙跳上一个 n 级台阶总共有多少种跳法？</p>
</blockquote>
<p>这其实是斐波那契数列的应用。当 n &gt; 2 时。f(n) = f(n-1) + f(n-2)，其中 f(1) = 1， f(2) = 2。</p>
<blockquote>
<p>扩展：一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级台阶……可以跳上 n 级阶梯，此时青蛙跳上 n 级阶梯一共有多少种跳法？</p>
</blockquote>
<p>用数学归纳法可以证明：f(n) = 2的(n-1)次幂。</p>
<blockquote>
<p>相关题目：用 2x1 的小矩形横着或者竖着覆盖更大的矩形，比如用 8个 2x1 的小矩形无重叠地覆盖一个 2x8 的大矩形，总共有多少种方法？</p>
</blockquote>
<p>思路：这仍然是斐波那契数列，分析可得 f(8) = f(7) + f(6)。</p>
<h4 id="243-位运算">2.4.3 位运算</h4>
<p>位运算是把数字用二进制表示后，对每位上的 0 或者 1 的运算，很多底层的技术都离不开位运算。</p>
<p>关于进制的题目：</p>
<blockquote>
<p>在 Excel 中，用 A 表示第一列，B 表示第二列……Z表示第26列，AA 表示第27列，AB 表示第28列……以此类推。请写出一个函数，输入用字母表示的列号编码，输出它是第几列？</p>
</blockquote>
<p>问题的本质是把十进制数字用 A-Z表示成二十六进制。</p>
<p>位运算的几种类型：与、或、异或、取反、左移、右移、无符号右移。</p>
<p><strong>面试题 10：二进制中 1 的个数</strong></p>
<blockquote>
<p>请实现一个函数，输入一个整数，输出该数二进制中 1 的个数。例如把 9 表示成二进制的是 1001，有 2 位是 1。因此如果输入 9，该函数输出 2。</p>
</blockquote>
<ul>
<li>可能引起死循环的解法：先判断整数的二进制最低位是不是 1 ，再把输入的整数右移一位，再判断是不是 1 …… 反复右移，直到整数变成 0 为止。如果输入负数，右移时高位补 1，最终数字变成 111111……，陷入死循环。</li>
<li>常规解法：先把 i 和 1 做与运算，判断 i 的最低位是不是 1。接着把 1 左移一位得到 2，再和 i 做与运算，判断 i 的低次位是不是 1 …… 这样反复左移，每次都能判断 i 的其中一位是不是 1。</li>
<li>能给面试官带来惊喜的解法：把一个整数减去 1，再和原来的整数做与运算，会把该整数最右边的一个 1 变成 0。那么一个整数的二进制表示中有多少个 1，就可以进行多少次这样的操作。</li>
</ul>
<blockquote>
<p>相关题目：</p>
</blockquote>
<ul>
<li>用一条语句判断一个数是不是 2 的整数次方。如果一个数是 2 的整数次方，那么它的二进制表示中有且只有一位是 1，而其他所有位都是 0。根据前面的分析，把这个整数减去 1, 再和它自己做与运算，这个整数中唯一的 1 就会变成 0。</li>
<li>输入两个整数 m 和 n，计算需要改变 m 的二进制表示中的多少位才能得到 n。比如 10 的二进制表示为 1010，13 的二进制表示为 1101，需要改变 1010 中的 3 位才得到 1101。我们可以分两步解决这个问题：第一步求这个两个数的异或，第二部统计异或结果中 1 的个数。</li>
</ul>
<p><strong>Tips:</strong></p>
<blockquote>
<p>把一个整数减去 1 之后再和原来的整数做位与运算，得到的结果相当于是把这个整数的二进制表示中的最右边一个 1 变成 0。很多二进制的问题都可以用这个思路解决。</p>
</blockquote>
<h2 id="第三章-高质量的代码">第三章 高质量的代码</h2>
<h3 id="31-面试官谈代码质量">3.1 面试官谈代码质量</h3>
<ul>
<li>一般会考查代码的容错处理能力，对一些特殊的输入是否考虑、如何处理。不能容忍只是针对假想的「正常值」进行处理，不考虑异常状况和资源回收等问题。</li>
<li>不能容忍的是，该掌握的知识没有掌握，而且提醒了还不知道。比如：double a, b; if(a==b)…</li>
<li>最不能容忍的是忽略边界情况。</li>
<li>如果连变量、函数命名都毫无规章，解决问题找不到最合适的数据结构，说明程序写得太少，不够熟悉。</li>
<li>从程序的正确性和健壮性两方面检验代码的质量。关注对输入参数的检查、处理错误和异常的方式、命名方式等。</li>
</ul>
<h3 id="32-代码的规范性">3.2 代码的规范性</h3>
<ul>
<li>书写清晰。在面试过程中减慢写字的速度，尽量把每个字母写清楚，不用担心没有时间去写代码。</li>
<li>布局清晰。注意调整代码的布局，加入合理的缩进并让括号对齐成对出现，确保布局和逻辑清晰。</li>
<li>命名合理。建议用完整的英文单词组合命名变量和函数，最好让面试官一眼就能看出代码的意图。</li>
</ul>
<h3 id="33-代码的完整性">3.3 代码的完整性</h3>
<ol>
<li>从三个方面确保代码的完整性</li>
</ol>
<p>从功能测试、边界测试和负面测试三个方面设计测试用例，以保证代码的完整性。</p>
<ul>
<li>功能测试：保证代码能够完成面试官要求的基本功能，突破常规思维的限制。如字符串转换成整数，要把零、整数合负数都考虑进去。</li>
<li>边界测试：考虑循环结束的边界条件，递归终止的边界值等，如字符串转换成整数，确保正确转换最大的正整数和最小的负整数。</li>
<li>负面测试：考虑各种可能的错误输入，如字符串转换成整数，输入的字符串不是数字。</li>
</ul>
<ol>
<li>三种错误处理的方法</li>
</ol>
<ul>
<li>函数用返回值告知调用者是否出错</li>
<li>当发生错误时设置一个全局变量</li>
<li>当函数运行出错时，抛出一个异常</li>
</ul>
<p><strong>面试题 11. 数值的整数次方</strong></p>
<blockquote>
<p>实现函数 double Power(double base, int exponent)，求 base 的 exponent 次方。不得使用库函数，无需考虑大数问题。</p>
</blockquote>
<p><strong>Tips：</strong></p>
<blockquote>
<p>由于计算机表示小数（包括float 和 double）都有误差，所以我们不能使用等号（==）判断两个小数是否相等。如果两个小数的差的绝对值很小，比如小于 0.00000001，就可以认为它们相等。</p>
</blockquote>
<p>全面的解法：考虑指数是零或者负数的情况</p>
<p>高效的解法：递归实现乘法，把次方分解成两个 1/2 次方</p>
<p>注意优化的细节：使用右移运算符代替除以 2，位与运算代替求余运算符（%）判断奇偶性。</p>
<p><strong>面试题 12. 打印 1 到最大的 n 位数</strong></p>
<blockquote>
<p>输入数字 n，按顺序打印从 1 到最大的 n 位十进制数，比如输入 3，则打印 1、2、3 一直带最大的三位数 999。</p>
</blockquote>
<h3 id="34-代码的健壮性">3.4 代码的健壮性</h3>
<p>健壮性是指程序能够判断输入是否合乎规范要求，并对不合要求的输入予以合理的处理。</p>
<p>提高代码健壮性的有效途径是进行防御性编程。防御性编程是指预见在什么地方可能会出现问题，并对可能出现的问题制定处理方式。</p>
<p>在面试时，最简单也最实用的防御性编程就是在函数入口添加代码以验证用户输入是否符合要求。</p>
<p><strong>面试题 15. 链表中倒数第 k 个结点</strong></p>
<blockquote>
<p>输入一个链表，输出该链表中倒数第 k 个结点。为了符合大多数人的习惯，本题从 1 开始计数，即链表的尾节点是倒数第 1 个结点。例如一个链表有 6 个结点，从头结点开始它们的值依次是 1、2、3、4、5、6，这个链表的倒数第 3 个节点是值为 4 的结点。</p>
</blockquote>
<p>思路：两个指针遍链表历，只要遍历一次就能找到结点。第一个指针先遍历 k-1 个结点，从第 k 个结点开始，第二个指针开始遍历，两个指针保持 k-1 的距离。当第一个指针遍历结束时，第二个指针的位置就是第 k 个结点。</p>
<p><strong>Tips：</strong></p>
<blockquote>
<p>面试过程中写代码要特别注意健壮性。如果写出的代码存在多处崩溃的风险，那么我们很可能和 offer 失之交臂。</p>
</blockquote>
<p>失分的三个问题：链表头结点指针为 null；输入的 k 是 0；链表的结点少于 k。</p>
<p><strong>相关题目：</strong></p>
<ul>
<li>求链表的中间结点。如果链表中的结点总数为奇数，就返回中间结点；否则返回中间两个结点中的任意一个。为了解决这个问题，我们也可以定义两个指针，同时同链表的头结点出发，一个指针一次走一步，另一个指针一次走两步。当走得快的指针到达链表的末尾时，走得慢的指针正好在链表的中间。</li>
<li>判断一个单向链表是否形成了环形结构。和前面的问题一样，定义两个指针，同时从链表的头结点出发，一个指针一次走一步，另一个指针一次走两步。如果走得快的指针追上了走得慢的指针，那么链表就是环形链表；如果走得快的指针走到了链表的末尾都没有追上走得慢的指针，那么链表就不是环形链表。</li>
</ul>
<p><strong>举一反三：</strong></p>
<p>当我们用一个指针遍历链表不能解决问题的时候，可以尝试用两个指针遍历链表，让其中一个指针遍历的速度快一些，或者让它在链表上走若干步。</p>
<p><strong>面试题 16. 反转链表</strong></p>
<blockquote>
<p>定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点。</p>
</blockquote>
<p>为了正确地反转一个链表，需要调整链表中指针的方向。</p>
<p>测试用例：</p>
<ul>
<li>输入的链表头指针是 null</li>
<li>输入的链表只有一个结点</li>
<li>输入的链表有多个结点</li>
</ul>
<p>避免出错的好办法就是提前想好测试用例。</p>
<p>本题扩展：使用递归实现同样的反转链表的功能。</p>
<p><strong>面试题 17. 合并两个排序的链表</strong></p>
<blockquote>
<p>输入两个递增排序的链表，合并这两个链表并使新的链表中的结点仍然按照递增排序。</p>
</blockquote>
<p>思路：比较大小，找到头结点，继续合并剩余的结点，递归调用即可。</p>
<p>注意测试用例，两个链表的一个或者两个头结点为空指针、两个链表中只有一个结点。</p>
<p><strong>面试题 18. 树的子结构</strong></p>
<blockquote>
<p>输入两棵二叉树 A 和 B，判断 B 是不是 A 的子结构。</p>
</blockquote>
<p>第一步在树 A 中查找与根结点的值一样的结点 R，这实际上就是树的遍历。第二步判断树 A 中以 R 为根结点的子树是不是和树 B 具有相同的结构。可以采用递归的方式遍历，同时注意可能的空指针。</p>
<h3 id="35-本章小结">3.5 本章小结</h3>
<p>从规范性、完整性和健壮性三个方面介绍了如何在面试时写出高质量的代码。</p>
<ul>
<li>规范性：书写清晰、布局清晰、命名合理</li>
<li>完整新：完整基本功能、考虑边界条件、做好错误处理</li>
<li>健壮性：采取防御式编程、处理无效的输入</li>
</ul>
<h2 id="第四章-解决面试题的思路">第四章 解决面试题的思路</h2>
<h3 id="41-面试官谈面试思路">4.1 面试官谈面试思路</h3>
<ul>
<li>编码前讲自己的思路是个考查指标，一个合格的应聘者应该在他做事之前明白自己要做的事情究竟是什么，以及该怎么做。</li>
<li>让应聘者给我讲具体的问题分析过程，经常会要求他证明。</li>
<li>个人比较倾向于让应聘者在写代码之前解释他的思路。可以采用举例子、画图等多种方式，解释清楚问题本身和问题解决方案是关键</li>
<li>对于比较复杂的算法和设计，一般来讲最好是在开始写代码前讲清楚思路和设计。</li>
<li>喜欢应聘者先讲清思路，希望他能在分析的过程中发现这些错误和漏洞，并加以改正。</li>
<li>喜欢应聘者在写代码之前先讲思路，举例子和画图都是很好的办法。</li>
</ul>
<h3 id="42-画图让抽象问题形象化">4.2 画图让抽象问题形象化</h3>
<p>画图是在面试过程中应聘者用来帮助自己分析、推理的常用手段。图形能使抽象的问题具体化、形象化，应聘者说不定通过几个图形就能找到规律，从而找到问题的解决方案。</p>
<p>在面试的时候，应聘者需要向面试官解释自己的思路。对于复杂的问题，可以画出几个图形，一边看着图形一边讲解，面试官就能更加轻松地理解应聘者的思路。</p>
<p><strong>面试题 19. 二叉树的镜像</strong></p>
<blockquote>
<p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p>
</blockquote>
<p>为了能够形成直观的印象，我们可以自己画一棵二叉树，然后根据照镜子的经验画出它的镜像。</p>
<p>先前序遍历二叉树的每个结点，如果遍历的结点有子结点，就交换它的两个子结点。当交换完所有非叶子结点的左右子结点后，就得到了树的镜像。</p>
<p><strong>扩展：</strong> 用循环实现该题目</p>
<p><strong>面试题 20. 顺时针打印矩阵</strong></p>
<blockquote>
<p>输入一个矩阵，按照从外向里顺时针的顺序依次打印每个数字。</p>
</blockquote>
<p>由于以从外向内的顺序依次打印，我们可以把矩阵想象成若干个圈，用一个循环来打印矩阵，每次打印矩阵中的一个圈。</p>
<p>打印一圈分为四步：从左到右打印一行、从上到下打印一列、从右到左打印一行、从下到上打印一列。最后一圈可能退化成只有一行、只有一列甚至只有一个数字。</p>
<h3 id="43-举例让抽象问题具体化">4.3 举例让抽象问题具体化</h3>
<ul>
<li>具体的例子可以帮助我们找到抽象的隐藏的规律</li>
<li>具体的例子也可以帮助我们向面试官解释算法思路</li>
<li>具体的例子还能帮助我们确保代码的质量</li>
</ul>
<p><strong>面试题 21. 包含 min 函数的栈</strong></p>
<blockquote>
<p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数。在该栈中，调用 min、push 以及 pop 的时间复杂度都是 O(1)。</p>
</blockquote>
<p>举个栗子多做几次入栈出栈的操作，把最小元素用另外的辅助栈保存。</p>
<p><strong>面试题 22. 栈的压入、弹出序列</strong></p>
<blockquote>
<p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序，假设压入栈的所有数字都不相等。例如序列 1、2、3、4、5 是某栈的压栈序列，序列 4、5、3、2、1 是该压栈序列对应的一个弹出序列，但是 4、3、5、1、2 就不可能是该压序列的弹出序列。</p>
</blockquote>
<p>举一两个例子，一步步分析压栈、弹出的过程，从中找出规律。</p>
<p>如果下一个弹出的数字刚好是栈顶数字，那么直接弹出。如果下一个弹出的数字不在栈顶，我们把压栈序列中还没有入栈的数字压入辅助栈，直到把下一个需要弹出的数字压入栈顶为止。如果所有的数字都已经压入栈还没有找到下一个弹出的数字，那么该序列不可能是个弹出序列。</p>
<p><strong>面试题 23. 从上往下打印二叉树</strong></p>
<blockquote>
<p>从上往下打印出二叉树的每个结点，同一层的结点按照从左到右的顺序打印。</p>
</blockquote>
<p>是指考查树的遍历算法，首先分析按层遍历的过程。找到规律：每次打印一个结点的时候，如果该结点有子结点，则把该结点的子结点放到一个队列的末尾。然后到队列的头部取出最早入队的结点，重复前面的打印操作，直到队列中所有的结点都被打印出来为止。</p>
<p><strong>扩展：</strong> 如何广度优先遍历一个有向图？这同样也基于队列实现。树是图的一种特殊退化形式，从上到下按层遍历二叉树，从本质上说就是广度优先遍历二叉树。</p>
<p><strong>面试题 24. 二叉搜索树的后序遍历序列</strong></p>
<blockquote>
<p>输入一个整数数组，判断该数组是不是某二叉搜素树的后序遍历结果。假设输入的数组任意两个数字互不相同。</p>
</blockquote>
<p>在后序遍历得到的序列中，最后一个数字是树的根结点的值。数组中前面的数字可以分为两部分：第一部分是左子树结点的值，它们都比根结点的值小，第二部分是右子树结点的值，它们都比根结点的值大。</p>
<p><strong>相关题目：</strong> 输入一个整数数组，判断该数组是不是某二叉搜索树的前序遍历的结果。这和前面的问题类似，只是在前序遍历得到的序列中，第一个数字是根结点的值。</p>
<p>如果面试题要求处理一棵二叉树的遍历序列，我们可以先找到二叉树的根结点，再基于根结点把整棵树的遍历序列拆分成左子树和右子树对应的子序列，接下来递归地处理这两个序列。</p>
<p><strong>面试题 25. 二叉树中和为某一值的路径</strong></p>
<blockquote>
<p>输入一棵二叉树和一个整数，打印二叉树中结点值的和为输入整数的所有路径。从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</p>
</blockquote>
<p>当用前序遍历的方式访问到某一结点时，我们把该结点添加到路径上，并累加该结点的值。如果该结点为叶结点并且路径中结点值的和刚好等于输入的整数，则打印当前的路径。如果当前结点不是叶结点，则继续访问它的子结点。当前结点访问结束后，在路径上删除当前结点并减去结点的值，以确保返回父结点时路径刚好是从根结点到父结点的路径。保存路径的数据结构实际上是个栈。</p>
<h3 id="44-分解让复杂问题简单化">4.4 分解让复杂问题简单化</h3>
<p>按照解决问题的步骤来分解复杂问题，每步解决一个小问题。</p>
<p>分治法：分而治之，各个击破</p>
<p><strong>面试题 26. 复杂链表的复制</strong></p>
<p><strong>面试题 27. 二叉搜索树与双向链表</strong></p>
<p><strong>面试题 28. 字符串的排列</strong></p>
<h2 id="第五章-优化时间和空间效率">第五章 优化时间和空间效率</h2>
<h3 id="51-面试官谈效率">5.1 面试官谈效率</h3>
<ul>
<li>面试时一般会直接要求时间复杂度和空间复杂度，这两者都很重要。</li>
<li>空间换时间还是时间换空间，这要看具体的题目了。一般的应用是空间换时间，因为用户更关心速度。</li>
<li>只要不是特别大的内存开销，时间复杂度比较重要。因为改进时间复杂度对算法的要求更高。</li>
</ul>
<h3 id="52-时间效率">5.2 时间效率</h3>
<ul>
<li>我们的编程习惯对代码的时间效率有很大影响。</li>
<li>同一个算法使用循环和递归两种方式实现的时间效率可能会大不一样。</li>
<li>代码的时间效率还体现在应聘者对数据结构和算法功底的掌握程度。</li>
<li>应聘者在面试的时候要展示敏捷的思维能力和追求完美的激情。</li>
</ul>
<h2 id="第六章-面试中的各项能力">第六章 面试中的各项能力</h2>
<h3 id="61-面试官谈能力">6.1 面试官谈能力</h3>
<ul>
<li>能够礼貌平和、不卑不亢地和面试官交流，逻辑清晰、详略得当地介绍项目经历，发现问题的细节并向面试官提问。深入了解自己做的的项目，对面试题能够快速寻找解决办法。</li>
<li>问一些面试者不熟悉的领域，在解答过程中观察沟通能力和求知欲。</li>
<li>沟通能力和学习能力都很重要。询问过往的经历，考查算法和询问项目经历，尤其是没有接触过的问题。</li>
<li>通过介绍过往项目考查表达能力，问其看书和关注什么来考查学习能力。</li>
<li>问及一些需求不是很明确的问题，解决这些问题需要和面试官进行沟通，讲解思路和代码的过程中也需要交流互动。</li>
<li>清晰有条理地表达自己，在得到信息不够的情况下主动发问澄清，在得到一些暗示之后迅速做出反应纠正错误。</li>
</ul>
<h3 id="62-沟通能力和学习能力">6.2 沟通能力和学习能力</h3>
<h5 id="1-沟通能力">1. 沟通能力</h5>
<p>知之为知之，不知为不知。对于不清楚的知识点，要勇敢承认，千万别不懂装懂。</p>
<h5 id="2-学习能力">2. 学习能力</h5>
<p>询问应聘者最近在看什么书或者做什么项目，从中学到了哪些新技术。抛出一个新概念，观察应聘者能不能在较短的时间内理解这个新概念并解决相关问题。</p>
<h5 id="3-善于学习-沟通的人也善于提问">3. 善于学习、沟通的人也善于提问</h5>
<p>建议应聘者在面试的过程中遇到不明白的地方多提问，这样面试官就会觉得你态度积极、求知欲望强烈，会给面试的结果加分。</p>
<p><strong>Tips：</strong></p>
<blockquote>
<p>面试是一个双向交流的过程，面试官可以问应聘者问题，同样应聘者也可以向面试官提问。如果应聘者能够针对面试题主动地提出几个高质量的问题，面试官就会觉得他由很强的沟通能力和学习能力。</p>
</blockquote>
<h3 id="63-知识迁移能力">6.3 知识迁移能力</h3>
<p>通俗说就是「举一反三」。每做一道面试题的时候，都要总结这道题的解法有什么特点，有哪些思路可以应用到同类型的题目中去。</p>
<p><strong>面试题 38. 数字在排序数组中出现的次数</strong></p>
<p><strong>面试题 39. 二叉树的深度</strong></p>
<p><strong>面试题 40. 数组中只出现一次的数字</strong></p>
<p><strong>面试题 41. 和为 s 的两个数字 VS 和为 s 的连续正数序列</strong></p>
<p><strong>面试题 42. 翻转单词顺序 VS 左旋转字符串</strong></p>
<h3 id="64-抽象建模能力">6.4 抽象建模能力</h3>
<p>程序员的工作就是把各种现实问题抽象成数学模型，并用计算机编程语言表达出来。要解决建模问题，除了需要具备扎实的数学基础和编程能力之外，还需要具有敏锐的洞察力和丰富的想象力。</p>
<p>建模的第一步是选择合理的数据结构来表述问题。第二步是分析模型中的内在规律，并用编程语言表述这种规律。</p>
<p><strong>面试题 43. n 个骰子的点数</strong></p>
<p><strong>面试题 44. 扑克牌的顺子</strong></p>
<p><strong>面试题 45. 圆圈中最后剩下的数字</strong></p>
<h3 id="65-发散思维能力">6.5 发散思维能力</h3>
<p>发散思维的特点是思维活动的多向性和变通性，也就是我们在思考问题时注重运用多思路、多方案、多途径地解决问题。</p>
<p>通过考查发散思维能力，面试官能够了解应聘者探索新思路的激情、灵活性和变通性、知识的广度和深度。</p>
<p><strong>面试题 46. 求 1+2+...+n</strong></p>
<p><strong>面试题 47. 不用加减乘除法做加发</strong></p>
<p><strong>面试题 48. 不能被继承的类</strong></p>
<h2 id="第七章-两个面试案例">第七章 两个面试案例</h2>
<p>通常一轮面试是从面试官对照着简历，了解应聘者的项目经历及掌握的技能开始的。在介绍自己的项目经历时，应聘者可以参照 STAR 模型，着重介绍自己完成的工作（包括基于什么平台、用了哪些技术、实现了哪些算法等），以及最终对项目组的贡献。</p>
<p>接着进入重头戏技术面试环节。在这一环节中面试官会从编程语言、数据结构和算法等方面，考查应聘者的基础知识是否扎实全面，并且很有可能会要求应聘者编程实现一两个函数。如果碰到的面试题很简单，应聘者也不能掉以轻心，一定要从基本功能、边界条件和错误处理等方面确保代码的完整性和鲁棒性。</p>
<p>如果碰到的题目很难，应聘者可以尝试画图让抽象的问题变得形象化，也可以尝试举几个具体的例子去分析隐含的规律，还可以尝试把大的问题分解成两个或者多个小问题，再递归地解决小问题。这 3 种方法能够帮助应聘者形成清晰的思路，从而解决复杂的难题。很多面试题都不止一种解决方案，应聘者可以从时间复杂度和空间复杂度两个方面选择最优的解法。</p>
<p>在面试过程中，面试官除了关注应聘者的编程能力外，他还会关注应聘者的沟通能力和学习能力，并有可能考查应聘者的知识迁移能力、抽象建模能力和发散思维能力）。</p>
<p>在面试结束前的几分钟，面试官会给应聘者机会问几个最感兴趣的问题。应聘者可以从当前招聘的项目及其团队等方面提出几个问题。不建议应聘者在技术面试的时候向面试官询问薪资情况，或者立即打听面试结果。</p>
<h3 id="71-案例一面试题-49把字符串转换成正数">7.1 案例一：（面试题 49）把字符串转换成正数</h3>
<h3 id="72-案例二面试题-50树中两个节点的最低公共祖先">7.2 案例二：（面试题 50）树中两个节点的最低公共祖先</h3>

            </div>
            
              <div class="tag-container">
                
                  <a href="https://isuperqiang.github.io/tag/mian-shi" class="tag">
                    面试
                  </a>
                
                  <a href="https://isuperqiang.github.io/tag/du-shu" class="tag">
                    读书
                  </a>
                
              </div>
            
            

            
              
                <div id="gitalk-container" data-aos="fade-in"></div>
              

              
            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>

<script type="application/javascript">

AOS.init();

hljs.initHighlightingOnLoad()

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>


  
  
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>

      var gitalk = new Gitalk({
        clientID: '2d592b1f64cd4e3a8e73',
        clientSecret: '0f2a4bb1031c2cc9a8d60153522506ce6771dfa6',
        repo: 'isuperqiang.github.io',
        owner: 'isuperqiang',
        admin: ['isuperqiang'],
        id: location.pathname,      // Ensure uniqueness and length less than 50
        distractionFreeMode: false  // Facebook-like distraction free mode
      })

      gitalk.render('gitalk-container')

    </script>
  

  




  </body>
</html>
