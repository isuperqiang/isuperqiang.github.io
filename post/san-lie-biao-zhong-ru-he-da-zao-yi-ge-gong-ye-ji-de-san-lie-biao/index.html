<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>散列表（中）：如何打造一个工业级的散列表 | 落英坠露</title>
<meta name="description" content="生活不止眼前的苟且，还有诗和远方的田野。" />
<link rel="shortcut icon" href="https://isuperqiang.github.io/favicon.ico?v=1610382508094">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://isuperqiang.github.io/styles/main.css">

<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://isuperqiang.github.io">
  <img class="avatar" src="https://isuperqiang.github.io/images/avatar.png?v=1610382508094" alt="">
  </a>
  <h1 class="site-title">
    落英坠露
  </h1>
  <p class="site-description">
    生活不止眼前的苟且，还有诗和远方的田野。
  </p>
  <div class="menu-container">
    
      
        <a href="https://isuperqiang.cn" class="menu">
          首页
        </a>
      
    
      
        <a href="https://isuperqiang.cn/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="https://isuperqiang.cn/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="https://isuperqiang.cn/post/about/" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
        <a href="https://github.com/isuperqiang" target="_blank">
          <i class="fab fa-github"></i>
        </a>
      
    
      
    
      
    
      
        <a href="https://www.zhihu.com/people/isuperqiang/" target="_blank">
          <i class="fab fa-zhihu"></i>
        </a>
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              散列表（中）：如何打造一个工业级的散列表
            </h2>
            <div class="post-info">
              <span>
                2019-05-12
              </span>
              <span>
                4 min read
              </span>
              
                <a href="https://isuperqiang.github.io/tag/datastruct-algorithm/" class="post-tag">
                  # 数据结构算法
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <p>工业级的散列表应该具有哪些特性？</p>
<ul>
<li>支持快速的查询、插入、删除操作；</li>
<li>内存占用合理，不能浪费过多的内存空间；</li>
<li>性能稳定，极端情况下，散列表的性能也不会退化到无法接受的情况。</li>
</ul>
<p>如何实现这样一个散列表呢？我会从这三个方面来考虑设计思路：</p>
<ul>
<li>设计一个合适的散列函数；</li>
<li>定义装载因子阈值，并且设计动态扩容策略；</li>
<li>选择合适的散列冲突解决方法。</li>
</ul>
<h3 id="1-如何设计散列函数">1. 如何设计散列函数</h3>
<p>首先，散列函数的设计不能太复杂。否则会消耗很多计算时间，影响散列表的性能。其次，散列函数生成的值要尽可能随机并且均匀分布，这样才能避免或者最小化散列冲突。</p>
<p>常见的散列函数设计方法：直接寻址法、平方取中法、折叠法、随机数法等。</p>
<h3 id="2-如何根据装载因子动态扩容">2. 如何根据装载因子动态扩容</h3>
<h4 id="1-设置装载因子阈值">1. 设置装载因子阈值</h4>
<p>针对散列表，当装载因子过大时，我们可以进行动态扩容，重新申请一个更大的散列表，将数据搬移到这个新散列表中，还需要通过散列函数重新计算每个数据的存储位置。对于支持动态扩容的散列表，插入数据的时间复杂度使用摊还分析法是 O(1)。</p>
<p>装载因子阈值的设置要权衡时间、空间复杂度。如果内存空间不紧张，对执行效率要求很高，可以降低负载因子的阈值；相反，如果内存空间紧张，对执行效率要求又不高，可以增加负载因子的值，甚至可以大于 1。</p>
<h4 id="2-避免低效扩容">2. 避免低效扩容</h4>
<p><strong>分批扩容</strong></p>
<p>为了解决一次性扩容耗时过多的情况，可以将扩容操作穿插在插入操作的过程中，分批完成。</p>
<p>分批扩容的插入操作：当有新数据要插入时，将数据插入新散列表，并且从老散列表中取出一个数据放入新散列表。每次插入都重复上面的过程。</p>
<p>分批扩容的查询操作：先查找新散列表，如果没有找到，再查找老散列表。</p>
<p>通过均摊的方式，任何情况下，插入一个数据的时间复杂度都是O(1)。</p>
<h3 id="3-如何选择冲突解决方法">3. 如何选择冲突解决方法</h3>
<p>开放寻址法和链表法在实际的软件开发中都非常常用。比如，Java 中 <code>LinkedHashMap</code> 就采用了链表法解决冲突，<code>ThreadLocalMap</code> 是通过线性探测的开放寻址法来解决冲突。</p>
<h4 id="开放寻址法">开放寻址法</h4>
<p><strong>优点：</strong></p>
<ul>
<li>散列表中的数据都存储在数组中，可以有效地利用 CPU 缓存加快查询速度。</li>
<li>没有指针，序列化起来比较简单。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>删除数据的时候比较麻烦，需要特殊标记已经删除的数据。</li>
<li>数据存储在一个数组中，比起链表法，冲突的代价更高。</li>
<li>装载因子的上限不能太大，比链表法更浪费内存空间。</li>
</ul>
<p><strong>结论：</strong><br>
当数据量比较小、装载因子小的时候，适合采用开放寻址法。这也是 Java 中的 <code>ThreadLocalMap</code> 使用开放寻址法解决散列冲突的原因。</p>
<h4 id="链表法">链表法</h4>
<p><strong>优点：</strong></p>
<ul>
<li>链表法对内存的利用率比开放寻址法要高。</li>
<li>链表法比起开放寻址法，对大装载因子的容忍度更高。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>对于比较小的对象的存储，是比较消耗内存的。</li>
<li>对 CPU 缓存是不友好的，对执行效率有一定的影响。</li>
</ul>
<p><strong>结论：</strong><br>
基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列表，而且，比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表。</p>
<h3 id="4-工业级散列表举例分析">4. 工业级散列表举例分析</h3>
<p>Java 中的 <code>HashMap</code>。</p>
<ul>
<li>默认初始大小 16</li>
<li>默认最大装载因子 0.75，扩容到原来的两倍</li>
<li>链表法解决冲突，JDK1.8 后引入红黑树</li>
<li>散列函数 <code>(h ^ (h &gt;&gt;&gt; 16)) &amp; (capitity -1);</code></li>
</ul>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li>
<ul>
<li><a href="#1-%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0">1. 如何设计散列函数</a></li>
<li><a href="#2-%E5%A6%82%E4%BD%95%E6%A0%B9%E6%8D%AE%E8%A3%85%E8%BD%BD%E5%9B%A0%E5%AD%90%E5%8A%A8%E6%80%81%E6%89%A9%E5%AE%B9">2. 如何根据装载因子动态扩容</a>
<ul>
<li><a href="#1-%E8%AE%BE%E7%BD%AE%E8%A3%85%E8%BD%BD%E5%9B%A0%E5%AD%90%E9%98%88%E5%80%BC">1. 设置装载因子阈值</a></li>
<li><a href="#2-%E9%81%BF%E5%85%8D%E4%BD%8E%E6%95%88%E6%89%A9%E5%AE%B9">2. 避免低效扩容</a></li>
</ul>
</li>
<li><a href="#3-%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95">3. 如何选择冲突解决方法</a>
<ul>
<li><a href="#%E5%BC%80%E6%94%BE%E5%AF%BB%E5%9D%80%E6%B3%95">开放寻址法</a></li>
<li><a href="#%E9%93%BE%E8%A1%A8%E6%B3%95">链表法</a></li>
</ul>
</li>
<li><a href="#4-%E5%B7%A5%E4%B8%9A%E7%BA%A7%E6%95%A3%E5%88%97%E8%A1%A8%E4%B8%BE%E4%BE%8B%E5%88%86%E6%9E%90">4. 工业级散列表举例分析</a></li>
</ul>
</li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://isuperqiang.github.io/post/san-lie-biao-shang-dan-ci-pin-xie-jian-cha-gong-neng-ru-he-shi-xian/">
              <h3 class="post-title">
                散列表（上）：单词拼写检查功能如何实现
              </h3>
            </a>
          </div>
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: 'd18dcb9f11230a396f48',
    clientSecret: 'b798878d844257cde96f390c0313cf0ab6433fcf',
    repo: 'isuperqiang.github.io',
    owner: 'isuperqiang',
    admin: ['isuperqiang'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | 
  <a class="rss" href="https://isuperqiang.github.io/atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()

  let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

  // This should probably be throttled.
  // Especially because it triggers during smooth scrolling.
  // https://lodash.com/docs/4.17.10#throttle
  // You could do like...
  // window.addEventListener("scroll", () => {
  //    _.throttle(doThatStuff, 100);
  // });
  // Only not doing it here to keep this Pen dependency-free.

  window.addEventListener("scroll", event => {
    let fromTop = window.scrollY;

    mainNavLinks.forEach((link, index) => {
      let section = document.getElementById(decodeURI(link.hash).substring(1));
      let nextSection = null
      if (mainNavLinks[index + 1]) {
        nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
      }
      console.log('section.offsetHeight', section.offsetHeight);
      if (section.offsetTop <= fromTop) {
        if (nextSection) {
          if (nextSection.offsetTop > fromTop) {
            link.classList.add("current");
          } else {
            link.classList.remove("current");    
          }
        } else {
          link.classList.add("current");
        }
      } else {
        link.classList.remove("current");
      }
    });
  });

</script>

      </div>
    </div>
  </body>
</html>
