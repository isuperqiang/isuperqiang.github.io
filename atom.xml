<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://isuperqiang.cn</id>
    <title>落英坠露</title>
    <updated>2019-06-23T05:03:03.052Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://isuperqiang.cn"/>
    <link rel="self" href="https://isuperqiang.cn/atom.xml"/>
    <subtitle>技术让生活更美好</subtitle>
    <logo>https://isuperqiang.cn/images/avatar.png</logo>
    <icon>https://isuperqiang.cn/favicon.ico</icon>
    <rights>All rights reserved 2019, 落英坠露</rights>
    <entry>
        <title type="html"><![CDATA[Java 比较浮点数的正确方式]]></title>
        <id>https://isuperqiang.cn/post/java-bi-jiao-fu-dian-shu-de-zheng-que-fang-shi</id>
        <link href="https://isuperqiang.cn/post/java-bi-jiao-fu-dian-shu-de-zheng-que-fang-shi">
        </link>
        <updated>2019-06-23T04:02:17.000Z</updated>
        <summary type="html"><![CDATA[<p>今天在读《Java开发手册》时，看到浮点数的等值判断问题「浮点数的基本数据类型不能用 <code>==</code> 比较，包装数据类型不能用 <code>equals</code> 比较」。以前开发时也遇到过浮点数的坑，所以就想一探究竟。</p>
]]></summary>
        <content type="html"><![CDATA[<p>今天在读《Java开发手册》时，看到浮点数的等值判断问题「浮点数的基本数据类型不能用 <code>==</code> 比较，包装数据类型不能用 <code>equals</code> 比较」。以前开发时也遇到过浮点数的坑，所以就想一探究竟。</p>
<!-- more -->
<h3 id="1-浮点数表示">1. 浮点数表示</h3>
<p>在计算机系统理论中，浮点数采用 IEEE 754 标准表示，编码方式是符号+阶码+尾数，如图：</p>
<p><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/1820210-61af804d90504fc0.webp" alt="浮点数表示"></p>
<p>比如 float 类型占用 32 位，单精度浮点表示法：</p>
<ul>
<li>符号位（sign）占用 1 位，用来表示正负数，0 表示正数，1 表示负数</li>
<li>指数位（exponent）占用 8 位，用来表示指数，实际要加上偏移量</li>
<li>小数位（fraction）占用 23 位，用来表示小数，不足位数补 0</li>
</ul>
<p>从这里可以看出，指数位决定了大小范围，小数位决定了计算精度。当十进制数值转换为二进制科学表达式后，得到的尾数位数是有可能很长甚至是无限长。所以当使用浮点格式来存储数字的时候，实际存储的尾数是被截取或执行舍入后的近似值。这就解释了浮点数计算不准确的问题，因为近似值和原值是有差异的。</p>
<p>更详细的介绍可以查阅 <a href="https://www.zhihu.com/question/46432979/answer/221485161">java浮点类型float和double的主要区别，它们的小数精度范围大小是多少？ - Boss呱呱的回答 - 知乎</a>。</p>
<h3 id="2-比较浮点数的方式">2. 比较浮点数的方式</h3>
<p>让我们来验证一下比较浮点数的几种方式。</p>
<h4 id="1-操作符">1. <code>==</code> 操作符</h4>
<p>比较两个浮点数，一个从零开始加 11 次 0.1，另一个用 0.1 乘以 11 计算。然后用 <code>==</code> 比较大小。</p>
<pre><code class="language-java">    private void compareByOperator() {
        float f1 = 0.0f;
        for (int i = 0; i &lt; 11; i++) {
            f1 += 0.1f;
        }

        float f2 = 0.1f * 11;

        System.out.println(&quot;f1 = &quot; + f1);
        System.out.println(&quot;f2 = &quot; + f2);

        if (f1 == f2) {
            System.out.println(&quot;f1 and f2 are equal using operator ==&quot;);
        } else {
            System.out.println(&quot;f1 and f2 are not equal using operator ==&quot;);
        }
    }
</code></pre>
<p>运行输出：</p>
<pre><code>f1 = 1.1000001
f2 = 1.1
f1 and f2 are not equal
</code></pre>
<p>可以看到，两个浮点数不相等，所以通过 <code>==</code> 来比较浮点数是不可靠的。</p>
<h4 id="2-误差范围">2. 误差范围</h4>
<p>指定一个误差范围，两个浮点数的差值在范围之内，则认为是相等的。使用 <code>Math.abs()</code> 计算差值，然后和阈值比较。</p>
<pre><code class="language-java">    private void compareByThreshold() {
        final float THRESHOLD = 0.000001;
        float f1 = 0.0f;
        for (int i = 0; i &lt; 11; i++) {
            f1 += 0.1f;
        }

        float f2 = 0.1f * 11;

        System.out.println(&quot;f1 = &quot; + f1);
        System.out.println(&quot;f2 = &quot; + f2);

        if (Math.abs(f1 - f2) &lt; THRESHOLD) {
            System.out.println(&quot;f1 and f2 are equal using threshold&quot;);
        } else {
            System.out.println(&quot;f1 and f2 are not equal using threshold&quot;);
        }
    }
</code></pre>
<p>运行输出：</p>
<pre><code>f1 = 1.1000001
f2 = 1.1
f1 and f2 are equal using threshold
</code></pre>
<h4 id="3-使用-bigdecimal">3. 使用 <code>BigDecimal</code></h4>
<p><code>BigDecimal</code> 是不可变的，能够精确地表示十进制数字。需要注意的是，创建 <code>BigDecimal</code> 对象时，要使用参数为 <code>String</code> 的构造方法，不要使用构造参数为 <code>double</code> 的，如果非要使用 <code>double</code> 创建，一定要用 <code>valueOf</code> 静态方法，防止丢失精度。然后调用 <code>compareTo</code> 方法比较即可。</p>
<pre><code class="language-java">    private void compareByBigDecimal() {
        BigDecimal f1 = new BigDecimal(&quot;0.0&quot;);
        BigDecimal pointOne = new BigDecimal(&quot;0.1&quot;);
        for (int i = 0; i &lt; 11; i++) {
            f1 = f1.add(pointOne);
        }

        BigDecimal f2 = new BigDecimal(&quot;0.1&quot;);
        BigDecimal eleven = new BigDecimal(&quot;11&quot;);
        f2 = f2.multiply(eleven);

        System.out.println(&quot;f1 = &quot; + f1);
        System.out.println(&quot;f2 = &quot; + f2);

        if (f1.compareTo(f2) == 0) {
            System.out.println(&quot;f1 and f2 are equal using BigDecimal&quot;);
        } else {
            System.out.println(&quot;f1 and f2 are not equal using BigDecimal&quot;);
        }
    }
</code></pre>
<p>运行输出：</p>
<pre><code>f1 = 1.1
f2 = 1.1
f1 and f2 are equal using BigDecimal
</code></pre>
<h3 id="3-结论">3. 结论</h3>
<p>使用 <code>==</code> 比较浮点数不准确，可以采用误差范围近似相等，或者 <code>BigDecimal</code> 计算比较。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每周 ARTS 第 11 期]]></title>
        <id>https://isuperqiang.cn/post/mei-zhou-arts-di-11-qi</id>
        <link href="https://isuperqiang.cn/post/mei-zhou-arts-di-11-qi">
        </link>
        <updated>2019-06-16T03:38:22.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-algorithm">1. Algorithm</h2>
<h3 id="263-丑数简单">263. 丑数（简单）</h3>
<h5 id="描述">描述：</h5>
<blockquote>
<p>编写一个程序判断给定的数是否为丑数。丑数就是只包含质因数 2, 3, 5 的正整数。</p>
</blockquote>
<h5 id="示例">示例：</h5>
<pre><code>示例：
输入: 6
输出: true
解释: 6 = 2 × 3
</code></pre>
<h5 id="思路">思路：</h5>
<ul>
<li>循环实现：循环去除 2、3、5，直到不能整除，如果余数是 1，那么就是丑数。</li>
<li>递归实现：和循环一样，也是不停地除2、3、5。</li>
</ul>
<pre><code class="language-java">class Solution {
    public boolean isUgly(int num) {
        if (num &lt;= 0) {
            return false;
        } else if (num == 1) {
            return true;
        }
        while (num % 2 == 0) {
            num /= 2;
        }
        while (num % 3 == 0) {
            num /= 3;
        }
        while (num % 5 == 0) {
            num /= 5;
        }
        return num == 1;
    }
  
   private static boolean isUgly2(int num) {
        if (num &lt;= 0) {
            return false;
        } else if (num == 1) {
            return true;
        }
        if (num % 2 == 0) {
            return isUgly2(num / 2);
        }
        if (num % 3 == 0) {
            return isUgly2(num / 3);
        }
        if (num % 5 == 0) {
            return isUgly2(num / 5);
        }
        return false;
    }
}
</code></pre>
<h5 id="分析">分析：</h5>
<p>循环和递归实现一样：</p>
<ul>
<li>时间复杂度：O(logn)</li>
<li>空间复杂度：O(1)</li>
</ul>
<hr>
<h3 id="349-两个数组的交集简单">349.  两个数组的交集（简单）</h3>
<h5 id="描述-2">描述：</h5>
<blockquote>
<p>给定两个数组，编写一个函数来计算它们的交集。</p>
</blockquote>
<h5 id="示例-2">示例：</h5>
<pre><code>输入: nums1 = [1,2,2,1], nums2 = [2,2]
输出: [2]
</code></pre>
<h5 id="说明">说明：</h5>
<ul>
<li>输出结果中的每个元素一定是唯一的。</li>
<li>我们可以不考虑输出结果的顺序。</li>
</ul>
<h5 id="思路-2">思路：</h5>
<p>使用一个 Set 去除数组一重复元素，另一个 Set 保存两个数组的交集</p>
<h5 id="解法">解法：</h5>
<pre><code class="language-java">class Solution {
    public int[] intersection(int[] nums1, int[] nums2) {
        if (nums1 == null || nums2 == null) {
            return new int[]{};
        }

        Set&lt;Integer&gt; set1 = new HashSet&lt;&gt;(nums1.length);
        for (int i : nums1) {
            set1.add(i);
        }
        Set&lt;Integer&gt; set2 = new HashSet&lt;&gt;(nums1.length);
        for (int i : nums2) {
            if (set1.contains(i)) {
                set2.add(i);
            }
        }
        int size = set2.size();
        int[] ret = new int[size];
        Iterator&lt;Integer&gt; iterator = set2.iterator();
        for (int i = 0; i &lt; size; i++) {
            ret[i] = iterator.next();
        }
        return ret;
    }
}
</code></pre>
<h5 id="分析-2">分析：</h5>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(n)</li>
</ul>
<h2 id="2-review">2. Review</h2>
<p><a href="https://medium.com/free-code-camp/what-is-an-api-in-english-please-b880a3214a82">What is an API? In English, please.</a> 什么是 API？</p>
<p>开发者都知道 API 是应用程序接口，作者对它有更广泛的认识。API 是服务方的一部分，它接收请求并发出响应。API 是向客户提供服务的一种方式，客户端访问 API 获取消息，比如 GitHub 的 API。在面向对象编程中，对象的 public 方法也可以看作是一种 API，用来与其他对象进行交互。</p>
<h2 id="3-tip">3. Tip</h2>
<p><a href="https://www.jianshu.com/p/43af9c156674">Android I/O 那些事儿</a> 总结了 Android 系统的 I/O 知识，对它有了更深层次的了解。</p>
<h2 id="4-share">4. Share</h2>
<p>经典是经过时间筛选的，在这个浮躁的社会，多读经典是最省时间的选择。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每周 ARTS 第 10 期]]></title>
        <id>https://isuperqiang.cn/post/mei-zhou-arts-di-10-qi</id>
        <link href="https://isuperqiang.cn/post/mei-zhou-arts-di-10-qi">
        </link>
        <updated>2019-06-09T03:37:47.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-algorithm">1. Algorithm</h2>
<h3 id="226-翻转二叉树简单">226. 翻转二叉树（简单）</h3>
<h5 id="描述">描述：</h5>
<blockquote>
<p>翻转一棵二叉树</p>
</blockquote>
<h5 id="示例">示例：</h5>
<pre><code>示例：
输入:
    4
  2    7
1  3  6  9
输出:
    4
  7    2
9  6  3  1
</code></pre>
<h5 id="思路">思路：</h5>
<ul>
<li>递归法：翻转一个二叉树，就是把根节点的左子树翻转一下，同样的把右子树翻转一下，再交换左右子树就可以了。</li>
<li>迭代法：类似广度优先遍历的方式，使用队列存储尚未交换的节点，每次从队列取出一个结点，交互其左右子结点，直到队列为空。</li>
</ul>
<pre><code class="language-java">class Solution {
    public TreeNode invertTreeRecursively(TreeNode root) {
        if (root == null) {
            return null;
        }

        TreeNode temp = root.left;
        root.left = root.right;
        root.right = temp;
        invertTreeRecursively(root.left);
        invertTreeRecursively(root.right);
        return root;
    }

    public TreeNode invertTreeIteratively(TreeNode root) {
        if (root == null) {
            return null;
        }

        LinkedList&lt;TreeNode&gt; list = new LinkedList&lt;&gt;();
        list.add(root);
        while (list.isEmpty()) {
            TreeNode current = list.poll();
            TreeNode temp = current.left;
            current.left = current.right;
            current.right = temp;

            if (current.left != null) {
                list.add(current.left);
            }
            if (current.right != null) {
                list.add(current.right);
            }
        }
        return root;
    }
}
</code></pre>
<h5 id="分析">分析：</h5>
<p>递归和迭代法一样：</p>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(n)</li>
</ul>
<hr>
<h3 id="326-3-的幂简单">326. 3 的幂（简单）</h3>
<h5 id="描述-2">描述：</h5>
<blockquote>
<p>给定一个整数，写一个函数来判断它是否是 3 的幂次方。</p>
</blockquote>
<h5 id="示例-2">示例：</h5>
<pre><code>输入: 27
输出: true
</code></pre>
<h5 id="思路-2">思路：</h5>
<ul>
<li>解法一：累乘法</li>
<li>解法二：3的幂次质因子只有3，而整数范围内的3的幂次最大是1162261467</li>
</ul>
<h5 id="解法">解法：</h5>
<pre><code class="language-java">class Solution {
    public boolean isPowerOfThree(int n) {
        if (n &lt;= 0) {
            return false;
        }
        if (n == 1) {
            return true;
        }
        long m = 1;
        while (m &lt; n) {
            m *= 3;
            if (m == n) {
                return true;
            }
        }
        return false;
    }

    public boolean isPowerOfThree2(int n) {
        return n &gt; 0 &amp;&amp; 1162261467 % n == 0;
    }
}
</code></pre>
<h5 id="分析-2">分析：</h5>
<p>解法一：</p>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<p>解法二：</p>
<ul>
<li>时间复杂度：O(1)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h2 id="2-review">2. Review</h2>
<p><a href="https://medium.com/@cscalfani/goodbye-object-oriented-programming-a59cda4c0e53">Goodbye, Object Oriented Programming</a> 再见，面向对象编程</p>
<p>作者是个有着多年经验的老程序员，他毫不留情地指出了面向对象编程的问题，分别从封装、继承和多态这三大支柱来阐述。</p>
<ul>
<li>继承最大的好处就是复用。但是出现了「猴子香蕉丛林」问题，我只想要一根香蕉，得到的却是香蕉丛林。钻石问题，继承关系的结构图就像钻石一样，这样容易造成调用混乱。还有基类问题，子类不知道基类的实现，从而引发操作错误。解决办法就是用组合替代继承，原意是包含和委托。</li>
<li>封装使得对象保证内部的变量受保护，然而它却带来了一下问题。引用问题，给构造方法传参时，对象存在多个应用，这样对象就不安全了。解决办法是对象深拷贝，但不是所有对象都支持克隆。</li>
<li>面向对象编程不需要多态，它完全可以基于接口来实现。</li>
</ul>
<p>最后作者告别了面向对象编程，转向函数式编程。</p>
<p>虽然作者举出这么多 OOP 的问题，但是面向对象的思想依然非常流行。软件开发没有银弹，能够实现功能、解决问题的思想都是值得采用的。</p>
<h2 id="3-tip">3. Tip</h2>
<p>日常的琐事都用软件记录，比如有道云笔记、滴答清单、LastPass。大脑是用来思考的，不是用来记东西的，它充当的更多是 CPU 的角色，而不是硬盘。所以，让大脑轻松一下，用工具记录吧。</p>
<h2 id="4-share">4. Share</h2>
<p><a href="https://mp.weixin.qq.com/s/qodCngOPXGSaaBy2ULAgqg">关于线程和I/O模型的极简知识</a> 主要讲述了线程和 I/O 模型的演化历史，问题驱动模型的演化，每种模型都有各自的使用场景。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android I/O 那些事儿]]></title>
        <id>https://isuperqiang.cn/post/android-io-na-xie-shi-er</id>
        <link href="https://isuperqiang.cn/post/android-io-na-xie-shi-er">
        </link>
        <updated>2019-06-04T04:47:01.000Z</updated>
        <summary type="html"><![CDATA[<p>I/O 操作是编程离不开的话题，它不仅是读写那么简单，还涉及底层的文件系统和存储设备。I/O 的快慢影响程序的执行效率，这篇文章主要介绍 Android 平台 I/O 的方式和使用场景。</p>
]]></summary>
        <content type="html"><![CDATA[<p>I/O 操作是编程离不开的话题，它不仅是读写那么简单，还涉及底层的文件系统和存储设备。I/O 的快慢影响程序的执行效率，这篇文章主要介绍 Android 平台 I/O 的方式和使用场景。</p>
<!-- more -->
<h3 id="1-linux-io-的基本组成">1. Linux I/O 的基本组成</h3>
<p>众所周知，Android 基于 Linux 系统，先介绍一些 Linux 上 I/O 的知识。</p>
<p>I/O 操作由应用程序、文件系统和磁盘共同完成，应用程序将 I/O 命令发送给文件系统，文件系统在合适的时间把 I/O 指令发送给磁盘。I/O 的流程如下图：</p>
<p><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20190603080604.png" alt="I/O操作"></p>
<p>CPU 和内存的速度比磁盘快得多，I/O 操作的瓶颈在于磁盘的性能。为了降低磁盘对应用程序的影响，文件系统要进行各种各样的优化。</p>
<h4 id="文件系统">文件系统</h4>
<p>简单来说，文件系统就是存储和组织数据的方式。应用程序调用 read() 方法，系统会通过中断从用户空间进入内核空间，然后经过虚拟文件系统、具体文件系统、页缓存。</p>
<p><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20190603081904.png" alt="Linux-I/O架构"></p>
<ul>
<li>虚拟文件系统（VFS）。主要用于屏蔽具体的文件系统，为应用程序的操作提供一个统一的接口。</li>
<li>文件系统（File System）。ext4、F2FS 都是具体文件系统实现。每个文件系统都有适合自己的场景。</li>
<li>页缓存（Page Cache）。文件系统对数据的缓存，读文件时先检查页缓存，如果命中就不去读磁盘。</li>
</ul>
<h4 id="磁盘">磁盘</h4>
<p>磁盘指的是系统的存储设备，常见的有机械硬盘、固态硬盘等。如果发现应用程序要读的数据没有在页缓存中，这时候就需要真正向磁盘发起 I/O 请求。磁盘 I/O 的过程要先经过内核的通用块层、I/O 调度层、设备驱动层，最后才会交给具体的硬件设备处理。</p>
<p><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20190603082924.png" alt="磁盘架构"></p>
<ul>
<li>通用块层。接收上层发出的磁盘请求，并最终发出 I/O 请求。它与 VPS 的作用类似。</li>
<li>I/O 调度层。根据设置的调度算法对请求合并和排序。不能接收到磁盘请求就立刻交给驱动层处理。</li>
<li>块设备驱动层。根据具体的物理设备，选择对应的驱动程序，通过操控硬件设备完成最终的 I/O 请求。</li>
</ul>
<h3 id="2-android-上的-io">2. Android 上的 I/O</h3>
<p>Android 现在普遍使用的是 Linux 常用的 ext4 文件系统。F2FS（Flash-Friendly File System）是三星为闪存研发的文件系统，它针对闪存进行了大量优化，F2FS 文件系统在小文件的随机读写方面比 ext4 更快。随着 Google、华为的投入和使用，F2FS 应该会成为 Android 主流的文件系统。</p>
<p>Android 手机使用闪存作为存储设备，也就是我们常说的 ROM。前几年闪存通常使用 eMMC 标准，近年来采用性能更好的 UFS 2.0/2.1 标准。手机存储也朝着体积更小、功耗更低、速度更快、容量更大的方向发展，闪存的随机读写速度甚至比 SSD 还快。</p>
<h4 id="手机变卡">手机变卡</h4>
<p>Android 手机用久了会变卡，除了系统升级、设备折旧等因素，还和 I/O 有密切关系。I/O 操作变慢的原因有下面几条：</p>
<ul>
<li>内存不足。系统回收 Page Cache 和 Buffer Cache 的内存，大部分的写操作会直接落盘，导致性能低下。</li>
<li>写入放大。闪存重复写入需要先进行擦除，一次写入会引起整个块数据的迁移，导致写入时间非常久。</li>
<li>设备性能差。在高负载的情况下容易出现瓶颈。</li>
</ul>
<h4 id="文件损坏">文件损坏</h4>
<p>文件损坏是令人头疼的问题，大多是由不正确的操作导致的。文件损坏的原因可以从应用程序、文件系统和磁盘三个角度来分析：</p>
<ul>
<li>应用程序。大部分的 I/O 方法都不是原子操作，文件的跨进程或者多线程写入、使用一个已经关闭的文件描述符 fd 来操作文件，都有可能导致数据被覆盖或者删除。</li>
<li>文件系统。虽说内核崩溃或者系统突然断电都有可能导致文件系统损坏，不过文件系统也做了很多的保护措施。例如 system 分区保证只读不可写，增加异常检查和恢复机制。</li>
<li>磁盘。手机上使用的闪存是电子式的存储设备，所以在资料传输过程可能会发生电子遗失等现象导致数据错误。</li>
</ul>
<h3 id="3-io-的三种方式">3. I/O 的三种方式</h3>
<p>I/O 有三种方式：标准 I/O、mmap 和 Direct I/O。</p>
<p><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20190604090403.png" alt="I/O的方式"></p>
<h4 id="标准-io">标准 I/O</h4>
<p>应用程序平时用到 read/write 操作都属于标准 I/O，也就是缓存 I/O（Buffered I/O）。它的关键特性有：</p>
<ul>
<li>对于读操作，当应用程序读取某块数据时，如果这块数据已经在页缓存中，那么就不需要经过物理读盘操作。</li>
<li>对于写操作，应用程序会先将数据写到页缓存中去，不需要等全部数据被写回磁盘，系统会定期将页缓存中的数据刷到磁盘上。</li>
</ul>
<p>缓存 I/O 可以很大程度减少真正读写磁盘的次数，从而提升性能。但是延迟写机制可能会导致数据丢失。在实际应用中，如果某些数据非常重要，我们应该采用同步写机制。</p>
<p>读操作时，数据会先从磁盘拷贝到 Page Cache 中，然后再从 Page Cache 拷贝到应用程序的用户空间，这样就会多一次内存拷贝。内存相对磁盘是高速设备，即使多拷贝一次，也比真正读一次硬盘要快。</p>
<h4 id="mmap">mmap</h4>
<p>mmap 把文件映射到进程的地址空间，提高了 I/O 的性能。</p>
<p>mmap 的优点有：</p>
<ul>
<li>减少系统调用。只需要一次 mmap() 系统调用，后续所有的调用像操作内存一样。</li>
<li>减少数据拷贝。mmap 只需要从磁盘拷贝一次，由于做过内存映射，不需要再拷贝回用户空间。</li>
<li>可靠性高。mmap 把数据写入页缓存后，跟缓存 I/O 的延迟写机制一样。</li>
</ul>
<p>存在的缺点：</p>
<ul>
<li>虚拟内存增大。Apk、Dex、so 都是通过 mmap 读取。mmap 会导致虚拟内存增大，mmap 大文件容易出现 OOM。</li>
<li>磁盘延迟。mmap 通过缺页中断向磁盘发起真正的磁盘 I/O，不能通过 mmap 消除磁盘 I/O 的延迟。</li>
</ul>
<p>在 Android 中可以将文件通过 <a href="https://developer.android.com/reference/android/os/MemoryFile">MemoryFile</a> 或者 <a href="https://developer.android.com/reference/java/nio/MappedByteBuffer">MappedByteBuffer</a> 映射到内存，然后进行读写，使用这种方式对于小文件和频繁读写操作的文件还是有一定优势的。</p>
<p>mmap 比较适合对同一块区域频繁读写的情况，推荐使用 I/O 线程来操作。用户日志、数据上报都满足这种场景，另外需要跨进程同步的时候，mmap 也是一个不错的选择。Android 跨进程通信有自己独有的 Binder 机制，它内部也是使用 mmap 实现。</p>
<h4 id="direct-io">Direct I/O</h4>
<p>一些数据库自己实现了数据和索引的缓存管理，对页缓存的依赖没那么强烈。它们想绕开页缓存机制，减少一次数据拷贝，它的数据也不会污染页缓存。</p>
<p>直接 I/O 访问文件方式减少了一次数据拷贝和一些系统调用的耗时，很大程度降低了 CPU 的使用率以及内存的占用。负面影响就是读写操作都是同步执行，导致应用程序等待。</p>
<h3 id="4-同步与异步-io">4. 同步与异步 I/O</h3>
<p>多线程阻塞式在 I/O 操作上的并没有优势，I/O 操作的主要瓶颈在于磁盘带宽。所以 I/O 操作不能开大量的线程。</p>
<p>NIO 是非阻塞 I/O，将 I/O 以事件的方式通知，可以减少线程切换的开销。NIO 的最大作用不是减少读取文件的耗时，而是最大化提升应用整体的 CPU 利用率。</p>
<p>另外，非常推荐 Square 的 <a href="https://github.com/square/okio">Okio</a>，它支持同步和异步 I/O，也做了比较多的优化。</p>
<p>I/O 优化对提升应用的体验非常有用，希望上面所讲的内容对你有帮助。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每周 ARTS 第 9 期]]></title>
        <id>https://isuperqiang.cn/post/mei-zhou-arts-di-9-qi</id>
        <link href="https://isuperqiang.cn/post/mei-zhou-arts-di-9-qi">
        </link>
        <updated>2019-06-02T03:37:13.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-algorithm">1. Algorithm</h2>
<h3 id="268-缺失数字简单">268. 缺失数字（简单）</h3>
<h5 id="描述">描述：</h5>
<blockquote>
<p>给定一个包含 0, 1, 2, ..., n 中 n 个数的序列，找出 0 .. n 中没有出现在序列中的那个数。</p>
</blockquote>
<h5 id="示例">示例：</h5>
<pre><code>输入: [3,0,1]
输出: 2
</code></pre>
<h5 id="思路">思路：</h5>
<blockquote>
<ul>
<li>解法一：用完整数组的元素之和减去当前数组的元素之和就可以了。</li>
<li>解法二：异或操作，eg: b^a^b=a; 相同的数字互相抵消，剩下的数值就是结果</li>
</ul>
</blockquote>
<h5 id="解法">解法：</h5>
<pre><code class="language-java">class Solution {
    public int missingNumber1(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }
        int numSum = 0;
        int allSum = nums.length;
        for (int i = 0; i &lt; nums.length; i++) {
            numSum += nums[i];
            allSum += i;
        }
        return allSum - numSum;
    }

    public int missingNumber2(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }
        int result = nums.length;
        for (int i = 0; i &lt; nums.length; i++) {
            result ^= nums[i];
            result ^= i;
        }
        return result;
    }
}
</code></pre>
<h5 id="分析">分析：</h5>
<ul>
<li>解法一和解法二一样：时间复杂度：O(n)，空间复杂度：O(1)</li>
</ul>
<hr>
<h3 id="203-移除链表元素简单">203. 移除链表元素（简单）</h3>
<h5 id="描述-2">描述：</h5>
<blockquote>
<p>删除链表中等于给定值 val 的所有节点。</p>
</blockquote>
<h5 id="示例-2">示例：</h5>
<pre><code>输入: 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val = 6
输出: 1-&gt;2-&gt;3-&gt;4-&gt;5
</code></pre>
<h5 id="思路-2">思路：</h5>
<blockquote>
<ul>
<li>解法一：首先检查头结点，如果结点值与val相等，那么把头指针后移；然后遍历链表，如果当前结点值与val相等，那么将前一个结点的指针指向后一个结点。</li>
<li>解法二：递归。</li>
</ul>
</blockquote>
<h5 id="解法-2">解法：</h5>
<pre><code class="language-java">class Solution {
    public ListNode removeElements(ListNode head, int val) {
        if (head == null) {
            return null;
        }
        while (head != null &amp;&amp; head.val == val) {
            head = head.next;
        }
        ListNode curr = head;
        ListNode prev = curr;
        while (curr != null) {
            if (curr.val == val) {
                prev.next = curr.next;
            } else {
                prev = curr;
            }
            curr = curr.next;
        }
        return head;
    }

    public ListNode removeElementsRecursive(ListNode head, int val) {
        if (head == null) {
            return null;
        }
        head.next = removeElementsRecursive(head.next, val);
        return head.val == val ? head.next : head;
    }
}
</code></pre>
<h5 id="分析-2">分析：</h5>
<ul>
<li>时间复杂度：O(n)，空间复杂度：O(1)</li>
</ul>
<h2 id="2-review">2. Review</h2>
<p><a href="https://hackernoon.com/50-data-structure-and-algorithms-interview-questions-for-programmers-b4b1ac61f5b0">50+ Data Structure and Algorithms Interview Questions for Programmers</a> 50个数据结构和算法面试题</p>
<p>作者主要介绍了面试中常见的算法题，大多关于数组、链表、字符串、二叉树，还有其他等。</p>
<ul>
<li>数组是最基本的线性数据结构，使用连续的存储空间。随机访问元素的时间复杂度 O(1)，添加和移除元素的时间复杂度是 O(n)。常见的题目有：数组反转、数据排序等。</li>
<li>链表也是一种线性数据结构，通过结点的指针连接，存储空间不连续。添加和移除元素的时间复杂度是 O(1)，查找元素的时间复杂度是 O(n)。解决链表问题不要忘记递归的思想。</li>
<li>字符串的问题也很常见，String 本质上就是字符数组，可以采用基于数组的解法。</li>
<li>树是一种有层次的数据结构，解决二叉树问题的关键是树的理论知识。比如：树的深度、大小、叶子结点，还有前序遍历、中序遍历、后序遍历。</li>
<li>其他的问题，比如算法、设计、位运算、逻辑题等，</li>
</ul>
<h2 id="3-tip">3. Tip</h2>
<p>重新复习了 Gradle 构建的知识。Gradle 构建就是围绕 Project 和 Task 展开的，Project 可以理解要构建的模块，Task 则是要执行的任务。Gradle 构建要经历初始化、配置和执行的过程，Task 之间存在依赖关系，开发者可以自由配置 Task，灵活性非常好。另外，Groovy 是基于 JVM 的语言，可以和 Java 兼容，语法和 Python 类似，封装了很多常用的 API，特别适合写脚本。</p>
<h2 id="4-share">4. Share</h2>
<p><a href="https://www.zhihu.com/question/312019918">作为 IT 行业的过来人，你有什么话想对后辈说的？</a></p>
<p>从老一代 IT 人的经历中，得到一些发展和行为的启示。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每周 ARTS 第 8 期]]></title>
        <id>https://isuperqiang.cn/post/mei-zhou-arts-di-8-qi</id>
        <link href="https://isuperqiang.cn/post/mei-zhou-arts-di-8-qi">
        </link>
        <updated>2019-05-26T03:36:25.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-algorithm">1. Algorithm</h2>
<h3 id="101-对称二叉树简单">101. 对称二叉树（简单）</h3>
<h5 id="描述">描述：</h5>
<blockquote>
<p>给定一个二叉树，检查它是否是镜像对称的。</p>
</blockquote>
<h5 id="示例">示例：</h5>
<pre><code>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。
         1
       /   \
      2     2
     / \   /  \
    3   4 4    3
</code></pre>
<h5 id="思路">思路：</h5>
<blockquote>
<ul>
<li>递归法：如果同时满足下面的条件，两个树互为镜像：它们的两个根结点具有相同的值；每个树的右子树都与另一个树的左子树镜像对称。</li>
<li>迭代法：类似广度优先遍历，但要把队列存的值 Double 一下。每次提取两个结点并比较它们的值。然后将两个结点的左右子结点按相反的顺序插入队列中。当队列为空时，或者我们检测到树不对称（即从队列中取出两个不相等的连续结点）时，算法结束。</li>
</ul>
</blockquote>
<h5 id="解法">解法：</h5>
<pre><code class="language-java">class Solution {
      // 迭代法
    public boolean isSymmetric2(TreeNode root) {
        if (root == null) {
            return true;
        }

        Queue&lt;TreeNode&gt; q = new LinkedList&lt;&gt;();
        q.add(root);
        q.add(root);
        while (q.size() &gt; 0) {
            TreeNode left = q.poll();
            TreeNode right = q.poll();
            if (left == null &amp;&amp; right == null) {
                continue;
            }
            if (left == null || right == null) {
                return false;
            }
            if (left.val != right.val) {
                return false;
            }
            q.add(left.left);
            q.add(right.right);
            q.add(left.right);
            q.add(right.left);
        }
        return true;
    }

    // 递归法
    public boolean isSymmetric(TreeNode root) {
        if (root == null) {
            return true;
        }
        return isMirror(root.left, root.right);
    }

    private boolean isMirror(TreeNode left, TreeNode right) {
        if (left == null &amp;&amp; right == null) {
            return true;
        }

        if (left == null || right == null) {
            return false;
        }

        if (left.val == right.val) {
            return isMirror(left.left, right.right) &amp;&amp; isMirror(left.right, right.left);
        }
        return false;
    }
}
</code></pre>
<h5 id="分析">分析：</h5>
<ul>
<li>递归法：时间复杂度：O(n)，空间复杂度：O(n)</li>
<li>迭代法：时间复杂度：O(n)，空间复杂度：O(n)</li>
</ul>
<hr>
<h3 id="107-二叉树的层次遍历-ii简单">107. 二叉树的层次遍历 II（简单）</h3>
<h5 id="描述-2">描述：</h5>
<blockquote>
<p>给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p>
</blockquote>
<h5 id="示例-2">示例：</h5>
<pre><code>例如，给定二叉树 [3,9,20,null,null,15,7],
     3
   /   \
  9    20
 / \
15  7
返回其自底向上的层次遍历为：
[
  [15,7],
  [9,20],
  [3]
]
</code></pre>
<h5 id="思路-2">思路：</h5>
<blockquote>
<p>广度优先，逐层遍历。首先构建数据列表和下层结点列表，遍历当前层的结点列表，把数据添加到数据列表，并把每个结点的子结点添加到下层结点列表。遍历完成后，把数据列表放到结果列表的首部，然后把下层结点列表变成当前结点列表，继续遍历。</p>
</blockquote>
<h5 id="解法-2">解法：</h5>
<pre><code class="language-java">class Solution {
    public List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) {
        if (root == null) {
            return Collections.emptyList();
        }

        List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;&gt;();
        List&lt;TreeNode&gt; currRowList = new LinkedList&lt;&gt;();
        currRowList.add(root);
        List&lt;TreeNode&gt; nextRowList;
        List&lt;Integer&gt; valueList;
        while (currRowList.size() &gt; 0) {
            valueList = new LinkedList&lt;&gt;();
            nextRowList = new LinkedList&lt;&gt;();
            for (TreeNode treeNode : currRowList) {
                valueList.add(treeNode.val);
                if (treeNode.left != null) {
                    nextRowList.add(treeNode.left);
                }
                if (treeNode.right != null) {
                    nextRowList.add(treeNode.right);
                }
            }
            result.add(0, valueList);
            currRowList = nextRowList;
        }
        return result;
    }
}
</code></pre>
<h5 id="分析-2">分析：</h5>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(n)</li>
</ul>
<h2 id="2-review">2. Review</h2>
<p><a href="https://medium.freecodecamp.org/writing-a-killer-software-engineering-resume-b11c91ef699d">How to write a killer Software Engineering résumé</a> 软件工程师如何写出杀手级的简历</p>
<p>作者是位面霸，他凭简历获得了 Google、Facebook、Amazon 等公司的面试机会。文章讲述了杀手级简历的特征，以及如何写出更好更高效的简历。</p>
<p>如何写出杀手级的简历？这里有几点建议：</p>
<ul>
<li>一眼就要看到的信息：你是谁，联系方式，教育经历，工作经历，项目经历，专业技能。</li>
<li>内容一两页就够了，排版格式简单明了。</li>
<li>让 HR 省事、舒心，自然就给你机会。</li>
<li>个人经历要和职位相关，按照最近时间排列。</li>
<li>简历不是通用的，每个职位都要有不同的版本。</li>
<li>描述工作成果：Accomplished [X] as measured by [Y] by doing [Z]。</li>
<li>个人项目很重要，体现了对编程的热爱和追求。</li>
<li>专业技能，精通、熟悉、了解 XXX。</li>
</ul>
<h2 id="3-tip">3. Tip</h2>
<p>每个开发者都该有一套自己的代码工具箱，用来收集日常开发用到的工具类，为的是能够在项目中快速集成和使用， 从而缩短开发周期，提高编码效率，节约时间成本。我自己就整理了一套 Android 开发的常用代码库，有需要时直接拿来使用，简单省事。</p>
<h2 id="4-share">4. Share</h2>
<p><a href="https://mp.weixin.qq.com/s/9ZU8aovjazSPdrQoNhIkqg">努力成为一名‘‘值得跟’’的Leader</a></p>
<p>什么样的人才是一个好的 Leader？“<strong>值得跟</strong>”绝对是对一个 Leader 最高的赞扬。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每周 ARTS 第 7 期]]></title>
        <id>https://isuperqiang.cn/post/mei-zhou-arts-di-7-qi</id>
        <link href="https://isuperqiang.cn/post/mei-zhou-arts-di-7-qi">
        </link>
        <updated>2019-05-19T03:35:42.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-algorithm">1. Algorithm</h2>
<h3 id="141-环形链表简单">141. 环形链表（简单）</h3>
<h5 id="描述">描述：</h5>
<blockquote>
<p>给定一个链表，判断链表中是否有环。</p>
</blockquote>
<h5 id="示例">示例：</h5>
<pre><code class="language-properties">输入: [3,2,0,4,2]
输出: true
</code></pre>
<h5 id="思路">思路：</h5>
<blockquote>
<p>使用快慢指针，慢指针每次移动一步，而快指针每次移动两步。如果存在环，那么两指针必定相遇。</p>
</blockquote>
<h5 id="解法">解法：</h5>
<pre><code class="language-java">class Solution {
    public boolean hasCycle(ListNode head) {
        if (head == null) {
            return false;
        }

        ListNode slow = head;
        ListNode fast = head;
        while (fast != null &amp;&amp; fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
            if (slow == fast) {
                return true;
            }
        }
        return false;
    }
}
</code></pre>
<h5 id="分析">分析：</h5>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<hr>
<h3 id="172-阶乘后的零简单">172. 阶乘后的零（简单）</h3>
<h5 id="描述-2">描述：</h5>
<blockquote>
<p>给定一个整数 <em>n</em>，返回 <em>n</em>! 结果尾数中零的数量。</p>
</blockquote>
<h5 id="示例-2">示例：</h5>
<pre><code class="language-properties">输入: 5
输出: 1
解释: 5! = 120, 尾数中有 1 个
</code></pre>
<h5 id="思路-2">思路：</h5>
<blockquote>
<p>只有 2 * 5 末尾才有零，乘数中 2 的个数肯定比 5 多。n! 为递减阶乘，只要统计乘数里因子 5 的个数就行了。</p>
</blockquote>
<h5 id="解法-2">解法：</h5>
<pre><code class="language-java">class Solution {
    // 递归法
    public int trailingZeroes1(int n) {
        if (n &lt; 5) {
            return 0;
        } else {
            return n / 5 + trailingZeroes1(n / 5);
        }
    }

    // 迭代法
    public int trailingZeroes2(int n) {
        int count = 0;
        while (n &gt;= 5) {
            count += n / 5;
            n /= 5;
        }
        return count;
    }
}
</code></pre>
<h5 id="分析-2">分析：</h5>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h2 id="2-review">2. Review</h2>
<p><a href="https://medium.freecodecamp.org/ace-your-first-year-as-a-junior-developer-with-this-advice-bbc68b6fe2d9">Ace your first year as a junior developer with this advice</a> 初级开发者赢得首年的建议</p>
<p>文章主要从以下几个方面展开论述：</p>
<ul>
<li>知识有缺口不可怕，软件开发者就要不断学习。</li>
<li>有问题是好事，要积极寻求帮助。</li>
<li>代码审查是你的朋友，从中可以学到很多。</li>
<li>把大任务拆解成小任务，写下步骤会更加清晰。</li>
<li>保持简洁。三个步骤：走通、重构、优化。测试驱动开发（TDD）</li>
<li>学习如何写整洁代码。平庸的程序员写出机器理解的代码，优秀的程序员写出人类可读的代码。</li>
<li>你遇到的问题大部分都有答案，所以先去寻找答案吧。比如到 GitHub、StackOverflow 上。</li>
<li>学会如何读代码。关注设计模式、方法类变量的命名、注释的使用、测试的使用。</li>
</ul>
<h2 id="3-tip">3. Tip</h2>
<p>这周末学习了 Dagger2 依赖注入框架，在 Android 开发中经常被使用。原理是这样的，它在编译阶段通过注解处理器扫描代码中的注解，然后自动生成辅助代码，简化了依赖注入的步骤，而且不会对性能产生任何影响。</p>
<h2 id="4-share">4. Share</h2>
<p><a href="https://mp.weixin.qq.com/s/M1E_UrkCQ3PNnGsyqpKc1A">从程序员到架构师 - 技能篇</a></p>
<p>架构师只是功底深厚的程序员。程序员从初级、中级、高级再到架构师，是一个不断经验积累的过程。在程序员生涯中，除了技术实力以外，其它软实力也不容忽视。如：主动学习、积累经验、控制注意力、超越自我。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每周 ARTS 第 6 期]]></title>
        <id>https://isuperqiang.cn/post/mei-zhou-arts-di-6-qi</id>
        <link href="https://isuperqiang.cn/post/mei-zhou-arts-di-6-qi">
        </link>
        <updated>2019-05-12T03:34:58.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-algorithm">1. Algorithm</h2>
<h3 id="160-相交链表简单">160. 相交链表（简单）</h3>
<h5 id="描述">描述：</h5>
<blockquote>
<p>编写一个程序，找到两个单链表相交的起始节点。</p>
</blockquote>
<h5 id="示例">示例：</h5>
<pre><code class="language-properties">输入: 9-&gt;1-&gt;2-&gt;4, 3-&gt;2-&gt;4
输出: 2
</code></pre>
<h5 id="思路">思路：</h5>
<blockquote>
<p>定义两个指针, 第一轮让到达末尾的节点指向另一个链表的头部, 最后如果两个指针相遇则为交点。两个指针移动了相同的距离, 有交点就结束, 无交点就各走了两条指针的长度。</p>
</blockquote>
<h5 id="解法">解法：</h5>
<pre><code class="language-java">class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        if (headA == null || headB == null) {
            return null;
        }

        ListNode pointA = headA;
        ListNode pointB = headB;
        while (pointA != pointB) {
            pointA = pointA == null ? headB : pointA.next;
            pointB = pointB == null ? headA : pointB.next;
            if (pointA != null &amp;&amp; pointB != null &amp;&amp; pointA.val == pointB.val) {
                break;
            }
        }
        return pointA;
    }
}
</code></pre>
<h5 id="分析">分析：</h5>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<hr>
<h3 id="169-求众数简单">169. 求众数（简单）</h3>
<h5 id="描述-2">描述：</h5>
<blockquote>
<p>给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 n/2 的元素。你可以假设数组是非空的，并且给定的数组总是存在众数。</p>
</blockquote>
<h5 id="示例-2">示例：</h5>
<pre><code class="language-properties">输入: [2,2,1,1,1,2,2]
输出: 2
</code></pre>
<h5 id="思路-2">思路：</h5>
<blockquote>
<p>从第一个数开始 count=1，遇到相同的就加 1，遇到不同的就减 1。如果减到 0，就换个数开始计数，总能找到最多的那个。</p>
</blockquote>
<h5 id="解法-2">解法：</h5>
<pre><code class="language-java">class Solution {
    public int majorityElement(int[] nums) {
        if (nums == null) {
            return 0;
        }

        int count = 1;
        int major = nums[0];
        for (int i = 1; i &lt; nums.length; i++) {
            if (major == nums[i]) {
                count++;
            } else {
                if (--count == 0) {
                    major = nums[i + 1];
                }
            }
        }
        return major;
    }
}
</code></pre>
<h5 id="分析-2">分析：</h5>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h2 id="2-review">2. Review</h2>
<p><a href="https://medium.freecodecamp.org/a-software-engineering-survival-guide-fe3eafb47166">A Software Engineering survival guide</a> 软件工程师生存指南</p>
<p>作者总结了软件工程师职业生涯前几年的经验：</p>
<ul>
<li>怎样充分准备面试</li>
<li>工作中如何成长</li>
<li>持续进步需要什么资源</li>
</ul>
<p>准备面试的几条意见：</p>
<ul>
<li>简历上列举的编程语言，至少能够完成 <code>FizzBuzz</code> 测试。</li>
<li>基本的数据结构和算法，像链表、数组、树和排序。</li>
<li>你选择的语言的特点，比如字符串为什么不可变，内存是如何管理的。</li>
<li>面向对象编程的概念，比如类、对象和继承。</li>
<li>学会总结你的经验，在简历上记叙下来。</li>
<li>在 GitHub 上展示代码，或者参与开源项目。</li>
<li>面试是双向的过程，也要面试你的面试官，比如提问几个问题：
<ul>
<li>你们是如何进行软件测试的</li>
<li>你们用什么版本控制系统</li>
<li>你们是如何处理技术债的</li>
<li>...</li>
</ul>
</li>
</ul>
<p>工作中的几条建议：</p>
<ul>
<li>优秀的工业级代码是可读的、具有防御性的、经过优化的。</li>
<li>大多数时间不是用来写新代码，而是 debug、读代码。</li>
<li>debug 和读代码，熟悉基础代码和产品。</li>
<li>组织你的想法，比如使用 TODO 列表、笔记、图表。</li>
<li>好的库具备的特征：开源、宽松的许可（MIT、BSD等）、成熟、一直维护、其他公司或项目在用。</li>
</ul>
<p>持续提升的几条建议：在线课程、在线硕士学位、博客、大会。</p>
<h2 id="3-tip">3. Tip</h2>
<p>最近在读《软技能：代码之外的生存指南》，看到营销的章节。对于有才华的人来说，营销就是一个「乘数效应」。你的营销越好，你的才华才能表现得淋漓尽致。自我营销的正确的方式是为别人提供价值，塑造好自己的形象，打造引人注目的品牌。对于软件开发人员，推荐的是博客。</p>
<h2 id="4-share">4. Share</h2>
<p><a href="https://open.leancloud.cn/git-commit-message/">Git Commit 日志风格指南</a></p>
<p>这是 LeanCloud 技术团队的文章，主要讲了几点 Git 提交日志的规范。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android 开发者指南之性能提示]]></title>
        <id>https://isuperqiang.cn/post/android-kai-fa-zhe-zhi-nan-zhi-xing-neng-ti-shi</id>
        <link href="https://isuperqiang.cn/post/android-kai-fa-zhe-zhi-nan-zhi-xing-neng-ti-shi">
        </link>
        <updated>2019-05-10T04:42:56.000Z</updated>
        <summary type="html"><![CDATA[<p>翻译自 Android 开发者训练课程，原文链接：<a href="https://developer.android.com/training/articles/perf-tips">Performance tips</a></p>
]]></summary>
        <content type="html"><![CDATA[<p>翻译自 Android 开发者训练课程，原文链接：<a href="https://developer.android.com/training/articles/perf-tips">Performance tips</a></p>
<!-- more -->
<hr>
<p>这篇文档主要涵盖了一些微小的优化，组合它们能够提升应用的整体性能，但是这些变化不会带来戏剧性的效果。你应该优选选择正确的算法和数据结构，但是它超出了本文档要说明的范围。在一般的开发练习中，你应该使用本文档中的提示，这样才能把提高代码效率当成一种习惯。</p>
<p>编写高效代码的两个基本原则：</p>
<ul>
<li>不要做不该做的事</li>
<li>尽量避免分配内存</li>
</ul>
<p>当你微优化安卓应用时，面对最棘手的问题之一就是，你的应用会运行在各种不同类型的硬件上。不同版本的虚拟机跑在不同处理器上，运行速度也不同。通常你不能简单地说，设备 X 是比设备 Y 运行快/慢的因素，将结果从一个设备扩展到其他设备。特别是，关于在其他设备上的性能，模拟器上的测量结果不全面。有没有 JIT 的设备也有非常大的差异：具有 JIT 的设备的最佳代码并不总是没有设备的最佳代码。</p>
<p>为确保你的应用在各种设备上都能正常运行，确保你的代码在各个级别都高效，并积极优化你的性能。</p>
<h4 id="避免创建不必要的对象">避免创建不必要的对象</h4>
<p>创建对象并不是没有开销的。分代垃圾收集器具有用于临时对象的每个线程分配池，这可以使分配更便宜，但是分配内存总是比不分配代价要大。</p>
<p>当你在应用中创建更多的对象时，你将被迫进行垃圾收集，对于用户体验来说，它就像「打嗝」一样的。在安卓 2.3 之后引入了并发垃圾收集器，但是也应该避免不必要的工作。</p>
<p>因此，你要避免创建不必要的对象。下面是一些例子：</p>
<ul>
<li>如果你的方法返回一个字符串，你知道它的结果总会拼接到 <code>StringBuffer</code>，这时你就该更改签名和实现，这样函数会直接追加，而不是创建存活期短的临时对象。</li>
<li>当从输入数据提取字符串时，尝试返回原始数据到子字符串，而不是创建一个拷贝。你会创建一个新的 <code>String</code> 对象，但是它会和原始数据共享 <code>char[]</code>。（需要考虑的是，如果你只使用原始输入的一小部分，那么无论如何，如果你用这个方法，你都会在内存中保留它。））</li>
</ul>
<p>一个激进的想法是，把多维数组切片变成并行的一维数组。</p>
<ul>
<li><code>int</code> 数组比 <code>Integer</code> 对象数组好多了。但是概括来说，两个并行的 <code>int</code> 数组同样比二维数组 <code>(int,int)</code>高效。对于其他的基本数据类型的组合也是如此。</li>
<li>如果你需要实现一个容器，用来存储二元组 <code>(Foo,Bar)</code> 对象，记住两个并行的 <code>Foo[]</code> 和 <code>Bar[]</code> 数组通常比一个常规的 <code>(Foo,Bar)</code> 对象数组要好得多。（当然例外情况是，你为其他代码设计 API 以进行访问。在这些情况下，为了实现良好的 API 设计，通常最好对速度进行小的折衷。但是在你自己的内部代码中，你应该尝试尽可能高效。）</li>
</ul>
<p>一般来说，尽量避免创建短期的临时对象。更少地创建对象意味着更低频率的垃圾回收，这对用户体验有直接影响。</p>
<h4 id="首选静态虚拟">首选静态虚拟</h4>
<p>如果你不需要访问对象的字段，请将方法设为静态，调用速度就会提高 15%-20%。这也是很好的做法，因为你可以从方法签名中看出，调用方法不能改变对象的状态。</p>
<p>考虑下面的在类首部的声明。</p>
<pre><code>static int intVal = 42;
static String strVal = &quot;Hello, world!&quot;;
</code></pre>
<p>编译器生成一个类的初始化方法，叫做 <code>&lt;clint&gt;</code>，当第一次使用类的时候，该方法会被执行。这个方法把值 42 存在 <code>intVal</code> 变量中，从类文件字符串常量表中提取一个引用指向 <code>strVal</code>。当稍后引用这些值时，通过字段可以访问它们。</p>
<p>我们可以使用 <code>final</code> 关键字改善这一步：</p>
<pre><code>static final int intVal = 42;
static final String strVal = &quot;Hello, world!&quot;;
</code></pre>
<p>这样，类就不需要 <code>&lt;clinit&gt;</code> 方法了，因为常量进入 dex 文件中的静态字段初始值设定项。引用 <code>intVal</code> 的代码会直接使用整数值 42，访问 <code>strVal</code> 会使用相对划算的「字符串常量」指令，而不是字段查找。</p>
<p>注意：此优化仅适用于基本类型和字符串常量，而不适用于任意引用类型。尽管如此，最好尽可能地声明常量 <code>static final</code> 值。</p>
<h4 id="使用增强型-for-循环">使用增强型 for 循环</h4>
<p>增强型 <code>for</code> 循环（也就是 for-each 循环）可以遍历实现了 <code>Iterable</code> 接口的集合和数组。对于集合，迭代器被分配用于创建叫做 <code>hasNext()</code> 和 <code>next()</code> 的接口。对于 <code>ArrayList</code>，一个手写的计数循环比 for-each 快约 3 倍，但是对于其他集合，增强型 for 循环完全等同于显式迭代器用法。</p>
<p>这里有几个遍历数组的方案：</p>
<pre><code>static class Foo {
    int splat;
}

Foo[] array = ...

public void zero() {
    int sum = 0;
    for (int i = 0; i &lt; array.length; ++i) {
        sum += array[i].splat;
    }
}

public void one() {
    int sum = 0;
    Foo[] localArray = array;
    int len = localArray.length;

    for (int i = 0; i &lt; len; ++i) {
        sum += localArray[i].splat;
    }
}

public void two() {
    int sum = 0;
    for (Foo a : array) {
        sum += a.splat;
    }
}
</code></pre>
<p><code>zero()</code> 最慢，因为每次通过循环迭代获得数组长度是有成本的，JIT 还不会优化。</p>
<p><code>one()</code> 快一些，它将所有内容都拉到局部变量中，从而避免了查找。只有数组的长度才能提供性能优势。</p>
<p><code>two()</code> 在没有 JIT 的设备上是最快的，与具有 JIT 的设备的 one() 无法区分。它使用了 Java 语言 1.5 版本后引入的增强型 for 循环语法。</p>
<p>所以，你应该默认使用增强型 for 循环，但是考虑一个手写的计数循环，用于性能关键的 ArrayList 迭代。</p>
<h4 id="考虑包而不是私有内部类的私有访问">考虑包而不是私有内部类的私有访问</h4>
<p>来看下面的类的定义：</p>
<pre><code>public class Foo { 
    private class Inner { 
        void stuff() { 
            Foo.this.doStuff(Foo.this.mValue);
        } 
    } 
 
    private int mValue;
 
    public void run() { 
        Inner in = new Inner();
        mValue = 27;
        in.stuff();
    } 
 
    private void doStuff(int value) {
        System.out.println(&quot;Value is &quot; + value);
    } 
} 
</code></pre>
<p>重要的是，我们定义了一个私有的内部类 <code>Foo$Inner</code>，它可以直接访问外部类的私有方法和私有成员变量。这是合法的，代码会打印 「Value is27」。</p>
<p>问题是，虚拟机认为从 <code>Foo$Inner</code> 直接访问 <code>Foo</code> 的私有成员是非法的，因为 <code>Foo</code> 和 <code>Foo$Inner</code> 是不同的类，即使 Java 语言允许内部类访问外部类的私有成员。为了弥合差距，编译器会生成一对合成方法：</p>
<pre><code>/*package*/ static int Foo.access$100(Foo foo) {
    return foo.mValue;
}
/*package*/ static void Foo.access$200(Foo foo, int value) {
    foo.doStuff(value);
}
</code></pre>
<p>当内部类要访问外部类的 <code>mValue</code> 字段或者调用 <code>doStuff()</code> 方法时，它会调用这些静态方法。这意味着上面的代码实际上归结为，你通过访问器方法访问成员字段的情况。之前我们讨论到访问器如何比直接访问字段更慢。所以这是一个特定语言习语的例子，导致「看不见」的表演。</p>
<h4 id="避免使用浮点型">避免使用浮点型</h4>
<p>根据经验，浮点数 比Android 设备上的整数慢约 2 倍。</p>
<p>在速度方面，现代硬件上的 <code>float</code> 和 <code>double</code> 没有区别。在空间方面，<code>double</code> 大 2 倍。与桌面计算机一样，假设空间不是问题，您应该更喜欢 <code>double</code>。</p>
<p>此外，即使对于整数，一些处理器也有硬件乘法但缺乏硬件除法。在这种情况下，整数除法和模数运算在软件中执行 - 如果您正在设计哈希表或进行大量数学运算，则需要考虑。</p>
<h4 id="了解并使用库">了解并使用库</h4>
<p>除了喜欢库代码而不是自己编写代码，请记住系统可以自由地用手动编译汇编程序替换对库方法的调用，这可能比 JIT 可以生成的等效的 Java 最佳代码更好。这里典型的例子是 <code>String.indexOf()</code> 和相关的 API，Dalvik 用内联的内在代替。类似地，<code>System.arraycopy()</code> 方法比带有 JIT 的 Nexus One 上的手动编码循环快约 9 倍。</p>
<h4 id="小心使用原生方法">小心使用原生方法</h4>
<p>使用 Android NDK 的原生代码开发应用，不一定比用 Java 语言开发的更高效。一方面，Java 和 原生之间传递有损耗，JIT 不会跨越这些边界优化。如果你分配了原生资源（原生堆上的内存，文件描述符，或其他内容），安排及时收集这些资源可能要困难得多。你还需要为要运行的每个体系结构编译代码（而不是依赖于具有 JIT 的体系结构）。你可能甚至需要为相同的架构编译多个版本：为 G1 中的 ARM 处理器编译的原生代码无法充分利用 Nexus One 中的 ARM，以及为 Nexus One 中的 ARM 编译的代码不会在 G1 中的 ARM 上运行。</p>
<h4 id="性能神话">性能神话</h4>
<p>在没有 JIT 的设备上，通过具有精确类型而不是接口的变量调用方法确实更有效。（因此例如，调用 <code>HashMap</code> 映射上的方法比使用 <code>Map</code> 映射更便宜，即使在这两种情况下映射都是 <code>HashMap</code>。）情况并非如此慢 2 倍，实际差异更像是慢了 6％。此外，JIT 使两者有效地难以区分。</p>
<p>在没有 JIT 的设备上，缓存字段访问比重复访问字段快约 20％。使用 JIT，字段访问的成本与本地访问大致相同，因此除非您觉得它使代码更易于阅读，否则这不值得进行优化。（对于 final，static 和 static final 字段也是如此。）</p>
<h4 id="总是测量">总是测量</h4>
<p>在开始优化之前，请确保你遇到需要解决的问题。确保你可以准确衡量现有的绩效，否则你将无法衡量尝试的替代方案的好处。</p>
<p>你可能还会发现 Traceview 对于分析很有用，但重要的是要知道当前会禁用 JIT，这可能会导致它错误地将时间错误归结为 JIT 可能能够赢回的代码。在 Traceview 数据建议进行更改以确保在没有 Traceview 的情况下运行时生成的代码实际运行得更快时，这一点尤其重要。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每周 ARTS 第 5 期]]></title>
        <id>https://isuperqiang.cn/post/mei-zhou-arts-di-5-qi</id>
        <link href="https://isuperqiang.cn/post/mei-zhou-arts-di-5-qi">
        </link>
        <updated>2019-05-04T03:34:10.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-algorithm">1. Algorithm</h2>
<h3 id="83-删除排序链表中的重复元素简单">83. 删除排序链表中的重复元素（简单）</h3>
<h5 id="描述">描述：</h5>
<blockquote>
<p>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</p>
</blockquote>
<h5 id="示例">示例：</h5>
<pre><code class="language-properties">输入: 1-&gt;1-&gt;2-&gt;3-&gt;3
输出: 1-&gt;2-&gt;3
</code></pre>
<h5 id="思路">思路：</h5>
<blockquote>
<p>从头开始遍历链表，比较前后两个节点元素的值。如果相等就修改前置指针，不想等就继续往后移动。</p>
</blockquote>
<h5 id="解法">解法：</h5>
<pre><code class="language-java">class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        if (head == null) {
            return null;
        }
        ListNode lastNose = head;
        ListNode currentNode = head;
        while ((currentNode = currentNode.next) != null){
            if(lastNose.val == currentNode.val){
                lastNose.next = currentNode.next;
            } else {
                lastNose = currentNode;
            }
        }
        return head;
    }
}
</code></pre>
<h5 id="分析">分析：</h5>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<hr>
<h3 id="231-2-的幂简单">231. 2 的幂（简单）</h3>
<h5 id="描述-2">描述：</h5>
<blockquote>
<p>给定一个整数，编写一个函数来判断它是否是 2 的幂次方。</p>
</blockquote>
<h5 id="示例-2">示例：</h5>
<pre><code class="language-properties">输入: 16
输出: true
解释: 24 = 16
</code></pre>
<h5 id="思路-2">思路：</h5>
<blockquote>
<p>如果一个数是2的幂次，那么它的二进制表示一定只有一个1。比如8的二进制 00001000，现在把这个数减1，得到 00000111。发现低4位是按位取反，这时候（n&amp;n-1）的结果就一定是0。如果一个数不是2的幂次，那么它的二进制数里1的个数就大于1（0除外）。n 和 n-1 就不会出现左边都是0的现象了，n&amp;(n-1) 一定不是0。</p>
</blockquote>
<h5 id="解法-2">解法：</h5>
<pre><code class="language-java">class Solution {
    public boolean isPowerOfTwo(int n) {
        if (n &lt;= 0) {
            return false;
        }
        return (n &amp; (n - 1)) == 0;
    }
}
</code></pre>
<h5 id="分析-2">分析：</h5>
<ul>
<li>时间复杂度：O(1)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h2 id="2-review">2. Review</h2>
<p><a href="https://medium.freecodecamp.org/why-you-are-never-too-old-to-learn-java-or-any-programming-language-a62603e89448">Why you are never too old to learn Java (or any programming language)</a> 为什么任何时候学习 Java 都不算晚</p>
<p>作者是位 Java 课程的讲师，文章的主旨是任何时候学习一项新技能都不算晚，比如 30 多岁学习编程。职业不是终身不变的，只要你愿意，就可以不断学习。学到老，学到老。</p>
<p>作者阐述了学习 Java 的 5 个原因：</p>
<ul>
<li>学习新东西，可以活跃你的大脑，大脑总是越用越灵活。</li>
<li>现在有许多在线课程和资料，没有人在乎你的年龄。</li>
<li>年龄无关，想学新东西什么时候都不晚。</li>
<li>学习 Java 就像学习其他技能一样。</li>
<li>现在就是最好的时间，开始学习吧。</li>
</ul>
<p>这是作者针对国外的情况写的，从国内的环境来看，30多岁再学习编程，进入企业的优势非常小。明明是一门靠手艺吃饭的职业，非要变成靠体力消耗，程序员年轻化已经成为常态。</p>
<h2 id="3-tip">3. Tip</h2>
<p>最近在学习音视频编解码。简单来讲，编码就是压缩，解码就是解压。编码的目的是减小数据的体积，方便网络传输和本地存储。编码后的数据是不能直接使用的，必须先解码成原来的样子。就像 zip 压缩文件里面有张图片，我们用图片查看器是无法打开的，必须先解压文件，恢复图片原来的数据，这样才能查看。音视频编解码也是同样的道理。</p>
<h2 id="4-share">4. Share</h2>
<p><a href="https://mp.weixin.qq.com/s/qGC08VgXc66t0WT7mgZxhA">写代码这条路，能走多远？工程师能力模型告诉你</a></p>
<p>从能力习得速度和技能演进速度两个维度分析，程序员发生职业危机的可能性非常高。解决问题的三条出路：技术专家、管理岗、产品运营等。适合于走哪个路线，需要结合自己的性格来定。</p>
<p>技术专家的能力模型，处于中心的是行为处事的准则，也就是正确的思想观念。其中最核心的观念就是要把职业生涯当作自己的事业，为自己而工作，把提升自身能力作为事业的目标。围绕着这一核心的还包括以结果导向、主动承担责任的观念和既精又专的技术、团队协作能力等</p>
]]></content>
    </entry>
</feed>