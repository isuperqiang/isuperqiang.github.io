<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://isuperqiang.cn</id>
    <title>落英坠露</title>
    <updated>2019-10-27T13:18:07.331Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://isuperqiang.cn"/>
    <link rel="self" href="https://isuperqiang.cn/atom.xml"/>
    <subtitle>生活不止眼前的苟且，还有诗和远方的田野。</subtitle>
    <logo>https://isuperqiang.cn/images/avatar.png</logo>
    <icon>https://isuperqiang.cn/favicon.ico</icon>
    <rights>All rights reserved 2019, 落英坠露</rights>
    <entry>
        <title type="html"><![CDATA[深入理解计算机系统之异常控制流（一）]]></title>
        <id>https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-yi-chang-kong-zhi-liu-yi</id>
        <link href="https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-yi-chang-kong-zhi-liu-yi">
        </link>
        <updated>2019-10-27T13:14:43.000Z</updated>
        <content type="html"><![CDATA[<p>指令1，指令性2，指令3……，这样的控制转移序列就是处理器的控制流（control flow）。</p>
<p>现代系统通过使控制流发生突变，来应对系统状态的变化，称为异常控制流（ECF），它发生在计算机系统的各个层次。</p>
<p>ECF 的重要性：</p>
<ul>
<li>ECF 是操作系统实现 I/O、进程和虚拟内存的基本机制。</li>
<li>应用程序通过使用系统调用的 ECF 形式，来向操作系统请求服务。</li>
<li>操作系统为应用程序提供了强大的 ECF 机制，用来创建新进程、等待进程终止、通知其他进程中的异常事件。</li>
<li>ECF 是计算机系统中实现并发的基本机制，比如中断应用程序执行的异常处理程序。</li>
<li>非本地跳转是一种应用层 ECF，软件异常允许程序进行非本地跳转来响应错误情况。</li>
</ul>
<h3 id="1-异常">1. 异常</h3>
<p>异常就是控制流中的突变，用来响应处理器状态中的某些变化。它一部分由硬件实现，一部分由操作系统实现。</p>
<figure data-type="image" tabindex="1"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20191026212833.png" alt="异常的剖析"></figure>
<p>在任何情况下，当处理器检测到有事件发生时，就会通过一张叫做「异常表」的跳转表，进行一个间接过程调用，交给异常处理程序去处理。<br>
当处理完成后，根据引起异常事件的类型，发生以下 3 种情况中的一种：</p>
<ul>
<li>处理程序将控制返回给当前指令。</li>
<li>处理程序将控制返回给下一条指令。</li>
<li>处理程序终止被中断的程序。</li>
</ul>
<p>异常可以分为四类：</p>
<ul>
<li>中断：来自外部 I/O 设备信号的结果，不是由专门的指令造成的。</li>
<li>陷阱：最重要的用途是在用户程序和内核之间提供一个接口——系统调用。</li>
<li>故障：由错误情况引起，可能被故障处理程序修正，比如缺页异常。</li>
<li>终止：不可恢复的致命错误造成的结果，通常是一些硬件错误。</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20191026213802.png" alt="异常的类别"></figure>
<h3 id="2-进程">2. 进程</h3>
<p>进程就是一个正在执行的程序实例，系统中的每个程序都运行在某个进程的上下文（context）中。</p>
<p>进程提供给应用程序的关键抽象：</p>
<ul>
<li>一个独立的逻辑控制流，它提供一个假象，好像程序独占地使用处理器。</li>
<li>一个私有的地址空间，它提供一个假象，好像程序独占地使用内存系统。</li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20191027200254.png" alt="进程控制流"></figure>
<p>进程是轮流使用处理器的，每个进程执行它的流的一部分，然后被抢占（暂时挂起），然后轮到其他进程。</p>
<p>进程为每个程序提供它自己私有地址空间。一般而言，和某个地址关联的内存字节是不能被其他进程读或写的。每个私有地址空间都有相同的通用结构。</p>
<figure data-type="image" tabindex="4"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20191027201327.png" alt="x86-64 linux 进程地址空间"></figure>
<p>处理器通常是用某个控制寄存器中的一个模式位，来实现限制应用可以执行的指令以及可以访问的地址空间。</p>
<p>当设置了模式位时，进程就运行在内核模式中，它可以执行指令集中的任何指令，并且可以访问系统中的任何内存位置。没有设置模式位时，进行就运行在用户模式中，不允许执行特权指令，也不允许直接引用地址空间中内核区的代码和数据。</p>
<p>运行应用程序代码的进程起初是在用户模式中的，进程从用户模式变为内核模式的唯一方法就是通过中断、故障或者陷入系统调用这样的异常。</p>
<p>操作系统内核使用一种称为「上下文切换」的异常控制流来实现多任务。内核为每个进程维持一个上下文。上下文就是内核重新启动一个被抢占的进程所需的状态。这些状态包括：通用目的寄存器、程序计数器、用户栈、环境变量等。</p>
<p>上下文切换的过程：</p>
<ul>
<li>保存当前进程的上下文</li>
<li>恢复某个先前被抢占的进程保存的上下文</li>
<li>将控制传递给这个刚恢复的进程</li>
</ul>
<p>当执行系统调用或者中断时，都可能会发生上下文切换。</p>
<figure data-type="image" tabindex="5"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20191027202847.png" alt="进程上下文切换"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[深入理解计算机系统之存储器层次结构]]></title>
        <id>https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-cun-chu-qi-ceng-ci-jie-gou</id>
        <link href="https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-cun-chu-qi-ceng-ci-jie-gou">
        </link>
        <updated>2019-10-20T07:47:51.000Z</updated>
        <content type="html"><![CDATA[<h3 id="61-存储技术">6.1 存储技术</h3>
<p>这一节主要讲述存储技术的发展，从 SRAM、DRAM、ROM 再到硬盘。</p>
<p>随机访问存储器（RAM），分为静态 RAM 和动态 RAM，前者比后者更快，但也贵得多。SRAM 应用于高速缓存，DRAM 应用于主存和帧缓冲区。</p>
<p>高速缓存存储器作为 CPU 和主存之间的缓存区域，对应用程序性能的影响最大。现代计算机频繁使用基于 SRAM 的高速缓存，试图弥补处理器和内存之间的差距。</p>
<p>数据流通过总线（bus）在 CPU 和主存之间传递，总线携带地址、数据和控制信号。</p>
<figure data-type="image" tabindex="1"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20191020101259.png" alt="连接 CPU 和主存的总线"></figure>
<p>像显示器、鼠标、键盘这样的 I/O 设备，都是通过 I/O 总线连接到 CPU 和主存的。I/O 总线比系统和内存总线慢，但可以容纳多种第三方 I/O 设备。</p>
<figure data-type="image" tabindex="2"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20191020101728.png" alt="总线结构图"></figure>
<p>CPU 使用内存映射的技术向 I/O 设备发出命令，地址空间有一块是为 I/O 设备通信保留的 I/O 端口。</p>
<h3 id="62-局部性原理">6.2 局部性原理</h3>
<p>程序倾向于引用最近引用过的数据项，或者与最近引用过的数据项邻近的数据项。</p>
<p>局部性有两种表现形式：时间局部性和空间局部性。有着良好局部性的程序比局部性差的程序运行得更快。</p>
<p>对于一个循环求数组元素之和的函数，结果 sum 每次循环都被引用，具有良好的时间局部性。而数组按顺序迭代，具有良好的空间局部性。<br>
而对于多维数组，步长会影响程序的空间局部性。</p>
<p>评价程序中局部性的一些简单原则：</p>
<ul>
<li>重复引用相同变量的程序具有良好的时间局部性。</li>
<li>对于具有步长的引用模式的程序，步长越小，空间局部性越好。在内存中以大步长跳来跳去的程序，空间局部性会很差。</li>
<li>对于取指令来说，循环具有好的时间和空间局部性。循环体越小，迭次次数越多，局部性越好。</li>
</ul>
<h3 id="63-存储器的层次结构">6.3 存储器的层次结构</h3>
<figure data-type="image" tabindex="3"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20191020152557.png" alt="存储器层次结构"></figure>
<p>一般而言，从高层到底层，存储设备变得更慢、更便宜和更大容量。</p>
<p>存储器层次结构的本质是：每一层存储设备都是较低一层的缓存。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[深入理解计算机系统之程序的机器级表示（二）]]></title>
        <id>https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-cheng-xu-de-ji-qi-ji-biao-shi-er</id>
        <link href="https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-cheng-xu-de-ji-qi-ji-biao-shi-er">
        </link>
        <updated>2019-10-13T06:07:47.000Z</updated>
        <content type="html"><![CDATA[<h3 id="过程">过程</h3>
<p>过程提供了一种封装代码的方式，用一组指定的参数和一个可选的返回值实现某种功能。形式有函数、方法、子例程等。</p>
<p>C 语言使用栈提供的后进先出的内存管理原则。栈和程序寄存器存放着传递控制和数据、分配内存需要的信息。</p>
<p>当 Q 执行时，P 及 P 以上的函数调研暂时被挂起，需要为局部变量分配存储空间，或者设置另一个过程调用。当 Q 返回时，它分配的局部存储空间都会被释放。P 的返回地址也被压入栈中，表示在 Q 返回时，从 P 的返回地址继续执行。</p>
<p>大多数过程间数据传送通过寄存器实现，寄存器最多传递 6 个整型参数，超过 6 个的部分要通过栈来传递。</p>
<figure data-type="image" tabindex="1"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20191014070514.png" alt="栈帧结构"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每周 ARTS 第 25 期]]></title>
        <id>https://isuperqiang.cn/post/mei-zhou-arts-di-25-qi</id>
        <link href="https://isuperqiang.cn/post/mei-zhou-arts-di-25-qi">
        </link>
        <updated>2019-09-28T11:54:01.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-algorithm">1. Algorithm</h2>
<h3 id="22-递增的三元子序列中等">22. 递增的三元子序列（中等）</h3>
<h5 id="描述">描述：</h5>
<blockquote>
<p>给定一个未排序的数组，判断这个数组中是否存在长度为 3 的递增子序列。</p>
<p>数学表达式如下:</p>
<p>如果存在这样的 i, j, k,  且满足 0 ≤ i &lt; j &lt; k ≤ n-1，<br>
使得 arr[i] &lt; arr[j] &lt; arr[k] ，返回 true ; 否则返回 false 。</p>
</blockquote>
<h5 id="示例">示例：</h5>
<pre><code>输入: [1,2,3,4,5]
输出: true
输入: [5,4,3,2,1]
输出: false
</code></pre>
<h5 id="思路">思路：</h5>
<p><strong>双指针</strong></p>
<p>定义 min 为序列中的较小值，mid 为中间值，看是否能找到较大值。</p>
<pre><code class="language-java">class Sulution {
    public boolean increasingTriplet(int[] nums) {
        if (nums == null || nums.length &lt; 3) {
            return false;
        }

        int min = Integer.MAX_VALUE;
        int mid = Integer.MAX_VALUE;
        for (int num : nums) {
            if (num &lt;= min) {
                min = num;
            } else if (num &lt;= mid) {
                mid = num;
            } else {
                return true;
            }
        }
        return false;    
    }
}
</code></pre>
<h5 id="分析">分析：</h5>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h2 id="2-review">2. Review</h2>
<p><a href="https://skorks.com/2011/02/the-greatest-developer-fallacy-or-the-wisest-words-youll-ever-hear/">The Greatest Developer Fallacy Or The Wisest Words You’ll Ever Hear?</a> 你听过最伟大开发者的谬误还是最明智的话？</p>
<p>作者从 “I will learn it when I need it” 开始谈起，列举了一些自己的观点。</p>
<ul>
<li>投资你的未来，而不是需要的时候才学习，渴望比知识更重要。</li>
<li>你不知道你不知道的知识，你不去学习它，是因为你根本不知道它的存在。</li>
<li>广度是深度的副作用，在一个领域成为专家，其他领域也顺便了解。</li>
<li>和大牛交朋友，从他们那里学到东西。</li>
</ul>
<h2 id="3-tip">3. Tip</h2>
<p>分享一个搜索引擎 —— <a href="https://www.dogedoge.com/">多吉搜索</a>，它的宗旨是不追踪，不误导，称得上是国内的 duckduckgo。界面清爽，简单纯粹，搜索质量比百度高 100 倍。如果你不能愉快地访问谷歌，那么多吉搜索是不错的选择。😃</p>
<h2 id="4-share">4. Share</h2>
<p>最近由于国庆，SS 服务被阻隔了，无法访问谷歌，对开发很不方便。互联网本该自由，何必构筑高墙，遮蔽众人耳目，自欺欺人呢？</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[深入理解计算机系统之程序的机器级表示（一）]]></title>
        <id>https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-cheng-xu-de-ji-qi-ji-biao-shi-yi</id>
        <link href="https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-cheng-xu-de-ji-qi-ji-biao-shi-yi">
        </link>
        <updated>2019-09-23T12:45:49.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1-概述">1. 概述</h3>
<p>计算机执行机器代码，用字节序列编码低级的操作，包括处理数据、管理内存、读写存储设备上的数据，以及利用网络通信。编译器基于编程语言的规则、目标机器的指令集和操作系统遵循的惯例，经过一系列的阶段生成机器代码。GCC C 语言编译器以汇编代码的形式产生输出，汇编代码是机器代码的文本表示，给出程序中的每一条指令。然后 GCC 调用汇编器和链接器，根据汇编代码生成可执行的机器代码。</p>
<h3 id="2-程序编码">2. 程序编码</h3>
<p>计算机系统使用多种抽象模型来隐藏实现的细节。对于机器级编程来说，有两种抽象尤为重要。</p>
<ul>
<li>第一种是由指令集架构（Instruction Set Architecture, ISA）来定义机器级程序的格式和行为，它定义了处理器状态、指令的格式，以及每条指令对状态的影响。</li>
<li>第二种抽象是，机器级程序使用的内存地址是虚拟地址，提供的内存模型看上去是一个非常大的字节数组。存储器系统的实际实现是将多个硬件存储器和操作系统软件组合起来。</li>
</ul>
<p>在编译过程中，编译器把用 C 语言提供的相对比较抽象的执行模型表示的程序，转化为处理器执行的非常基本的指令。汇编代码表示非常接近于机器代码。与机器代码的二进制格式相比，汇编代码的主要特点是它用可读性更好的文本格式表示。</p>
<p>程序内存包含：程序的可执行机器代码、操作系统需要的一些信息、用来管理过程调用和返回的运行时栈，以及用户分配的内存块。程序内存用虚拟地址来寻址，在任意给定的时刻，只有一部分虚拟地址被认为是合法的。操作系统负责管理虚拟地址空间，将虚拟地址翻译为实际处理器内存中的物理地址。</p>
<p>一条机器指令只执行一个非常基本的操作。机器执行的程序只是一个字节序列，它是对一系列指令的编码。机器对产生这些指令对源代码几乎一无所知。</p>
<figure data-type="image" tabindex="1"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/Jietu20190222-072526@2x.jpg" alt="机器代码与汇编代码"></figure>
<p>生成实际可执行的代码需要对一组目标代码文件运行链接器，而这一组目标代码文件必须含有一个 main 函数。上图中，<code>callq</code> 指令调用函数 <code>muil2</code> 需要使用地址，链接器的任务之一就是为函数调用找到匹配的函数的可执行的代码的位置。最后的两行 <code>nop</code> 对程序没有影响，插入这些指令的目的是为了使代码变为 16 字节，使得存储器系统更好地放置下一个代码块。</p>
<h3 id="3-数据格式">3. 数据格式</h3>
<figure data-type="image" tabindex="2"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/Jietu20190222-073010@2x.jpg" alt="C语言数据类型"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每周 ARTS 第 24 期]]></title>
        <id>https://isuperqiang.cn/post/mei-zhou-arts-di-24-qi</id>
        <link href="https://isuperqiang.cn/post/mei-zhou-arts-di-24-qi">
        </link>
        <updated>2019-09-14T15:17:25.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-algorithm">1. Algorithm</h2>
<h3 id="22-生成括号中等">22. 生成括号（中等）</h3>
<h5 id="描述">描述：</h5>
<blockquote>
<p>给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。</p>
</blockquote>
<h5 id="示例">示例：</h5>
<pre><code>例如，给出 n = 3，生成结果为：
[
  &quot;((()))&quot;,
  &quot;(()())&quot;,
  &quot;(())()&quot;,
  &quot;()(())&quot;,
  &quot;()()()&quot;
]
</code></pre>
<h5 id="思路">思路：</h5>
<p><strong>动态规划</strong></p>
<p>生成 N 对括号，必然有 N 个左括号和 N 个右括号，左括号的数量大于等于右括号。要确定 N 对，首先确定 N-1 对，利用递归求解。</p>
<p>left 记录左括号的数量，right 记录右括号的数量，当左右括号的数量相等时，记录结果，结束递归。</p>
<pre><code class="language-java">class Sulution {
    public int uniquePaths(int m, int n) {
        int[][] dp = new int[m][n];
        for (int i = 0; i &lt; m; i++) {
            dp[i][0] = 1;
        }
        for (int i = 0; i &lt; n; i++) {
            dp[0][i] = 1;
        }
        for (int i = 1; i &lt; m; i++) {
            for (int j = 1; j &lt; n; j++) {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m - 1][n - 1];
    }
}
</code></pre>
<h5 id="分析">分析：</h5>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(n)</li>
</ul>
<h2 id="2-review">2. Review</h2>
<p><a href="https://blog.codinghorror.com/the-two-types-of-programmers/">The Two Types of Programmers</a> 两种程序员</p>
<p>在软件开发领域，有两种程序员：20% 的开拓者，他们对技术痴迷，紧跟最新趋势。还有 80% 的普通人，编程对于他们只是工作，工作之外不关心代码。这两类人群有着巨大的鸿沟，如果要改变软件开发的现状，就要在这两类人群之间建立连接。</p>
<h2 id="3-tip">3. Tip</h2>
<p>继续阅读 CSAPP，<a href="https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-cheng-xu-de-ji-qi-ji-biao-shi-yi/">深入理解计算机系统之程序的机器级表示（一）</a>。计算机只能执行机器指令，高级程序语言需要经过编译器编译成机器代码，才能被计算机执行。汇编代码是用人类可读的文本表示机器指令，它非常接近机器代码。</p>
<h2 id="4-share">4. Share</h2>
<p><a href="https://mp.weixin.qq.com/s/XXSkDygqm2RY8YqmJCyJWw">总结几点“上不得台面”的技术领导经验</a></p>
<p>在我看来，身为技术领导，对技术的敬畏、诚实谦和、尊重客观、力求平等，应当是始终不变的坚持。但是，在坚韧的骨骼之外，让身段变柔软一点，总不是坏事。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[深入理解计算机系统之信息的表示和处理（二）]]></title>
        <id>https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-xin-xi-de-biao-shi-he-chu-li-er</id>
        <link href="https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-xin-xi-de-biao-shi-he-chu-li-er">
        </link>
        <updated>2019-09-14T13:39:12.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1-整数运算">1. 整数运算</h3>
<h4 id="11-加法">1.1 加法</h4>
<p><strong>无符号加法：</strong> 考虑两个非负整数 x 和 y，满足 0&lt;=x, y&lt;2^w。当  x+y &gt;= 2^w 时，和发生溢出。 溢出情况就是该和减去 2^w 的结果。</p>
<p><strong>补码加法：</strong> 当 x+y 小于 -2^(w-1) 时，发生负溢出；当它大于 2^(w-1) 时，发生正溢出。负溢出导致和增加 2^w，正溢出导致和减少 2^w。</p>
<figure data-type="image" tabindex="1"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/TIM%E6%88%AA%E5%9B%BE20190908192533.png" alt="补码加法的溢出"></figure>
<h4 id="12-乘法">1.2 乘法</h4>
<p>在大多数机器上，整数乘法指令非常慢，需要 10 个或者更多的时钟周期，然而加法、减法和位运算只需要 1 个时钟周期。</p>
<p>左移一个整数等价于执行与 2 的幂相等的乘法。</p>
<p>由于整数乘法比移位和加法的代价要大得多，许多 C 语言编译器使用移位和加法运算的组合代替乘以常数因子的乘法。例如，表达式 x * 14，利用 14 = 2^3 + 2^2 + 2^1，编译器会将乘法重写为 (X &lt;&lt; 3) + (X &lt;&lt; 2) + (X &lt;&lt; 1)。</p>
<h4 id="13-除法">1.3 除法</h4>
<p>在大多数机器上，整数除法要比整数乘法更慢，需要 30 个或者更多的时钟周期。</p>
<p>除以 2 的幂可以用右移（算术右移）运算来实现。</p>
<p>不能用除以 2 的幂的除法来表示除以任意常数的除法。</p>
<h3 id="2-浮点数">2. 浮点数</h3>
<h4 id="21-二进制小数">2.1 二进制小数</h4>
<p>小数的二进制表示法只能表示被写成 x*2^y 的数，其他数值只能近似表示。例如数字 1/5 可以用十进制小数 0.2 精确表示。但是，并不能把它准确地表示为二进制小数，我们只能近似地表示它，增加二进制表示的长度可以提高表示的精度。</p>
<h4 id="22-ieee-浮点表示">2.2 IEEE 浮点表示</h4>
<p>IEEE 754 浮点标准使用 V = (-1)^s * M * 2^E 来表示一个数：</p>
<ul>
<li>符号 s：s 决定数值是负数(s=1)还是正数(s=0)</li>
<li>尾数 M：是个二进制小数，范围是 1-2-ε 或者 0-1-ε</li>
<li>阶码 E：E 的作用是对浮点数加权，这个权重是 2 的 E 次幂</li>
</ul>
<p>将浮点数的位表示划分为三个字段，分别对这些值进行编码：</p>
<ul>
<li>一个单独对符号位 s 编码符号 s</li>
<li>k 位对阶码字段 exp 编码阶码 E</li>
<li>n 位对小数字段 frac 编码尾数 M</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20190914192853.png" alt="标准浮点格式"></figure>
<p>浮点数只能近似表示实数运算，它采用向偶数舍入的方式。需要注意的是，浮点数运算不具备结合性和分配性。</p>
<p><strong>总结一下：</strong></p>
<ul>
<li>整数运算溢出会导致结果异常，编程时要格外注意整数的范围。</li>
<li>通过左移和右移来进行整数乘除运算比算术运算要高效。</li>
<li>浮点数采用 IEEE 754 标准表示，编码方式是符号、阶码和尾数。</li>
<li>浮点数是近似表示的，它的运算不精确，之前总结过<a href="https://isuperqiang.cn/post/java-bi-jiao-fu-dian-shu-de-zheng-que-fang-shi/">Java 比较浮点数的正确方式</a>。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每周 ARTS 第 23 期]]></title>
        <id>https://isuperqiang.cn/post/mei-zhou-arts-di-23-qi</id>
        <link href="https://isuperqiang.cn/post/mei-zhou-arts-di-23-qi">
        </link>
        <updated>2019-09-10T00:45:53.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-algorithm">1. Algorithm</h2>
<h3 id="62-不同路径中等">62. 不同路径（中等）</h3>
<h5 id="描述">描述：</h5>
<blockquote>
<p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。<br>
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。<br>
问总共有多少条不同的路径？</p>
</blockquote>
<h5 id="示例">示例：</h5>
<pre><code>输入: m = 3, n = 2
输出: 3
解释:
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -&gt; 向右 -&gt; 向下
2. 向右 -&gt; 向下 -&gt; 向右
3. 向下 -&gt; 向右 -&gt; 向右
</code></pre>
<h5 id="思路">思路：</h5>
<p><strong>动态规划</strong></p>
<p>令 dp[i][j] 是到达 i, j 最多路径。<br>
动态方程：dp[i][j] = dp[i-1][j] + dp[i][j-1]<br>
注意，对于第一行 dp[0][j]，或者第一列 dp[i][0]，由于都是在边界，所以只能为 1。</p>
<pre><code class="language-java">class Sulution {
    public int uniquePaths(int m, int n) {
        int[][] dp = new int[m][n];
        for (int i = 0; i &lt; m; i++) {
            dp[i][0] = 1;
        }
        for (int i = 0; i &lt; n; i++) {
            dp[0][i] = 1;
        }
        for (int i = 1; i &lt; m; i++) {
            for (int j = 1; j &lt; n; j++) {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m - 1][n - 1];
    }
}
</code></pre>
<h5 id="分析">分析：</h5>
<ul>
<li>时间复杂度：O(m*n)</li>
<li>空间复杂度：O(m*n)</li>
</ul>
<h5 id="优化">优化：</h5>
<p>使用一维数组记录变量，空间复杂度降为 O(n)。</p>
<pre><code class="language-java">class Sulution {
    public int uniquePaths(int m, int n) {
        int[] sum = new int[n];
        Arrays.fill(sum, 1);
        for (int i = 1; i &lt; m; i++) {
            for (int j = 1; j &lt; n; j++) {
                sum[j] += sum[j - 1];
            }
        }
        return sum[n - 1];
    }
}
</code></pre>
<h2 id="2-review">2. Review</h2>
<p><a href="https://medium.com/s/story/reflections-on-clean-code-8c9b683277ca">What is clean code?</a> 什么是整洁的代码？</p>
<p>作者从《Clean Code》这本书说起，它被认为是程序员的必读书，作者概括了三个关键概念：</p>
<ul>
<li>技术手艺很重要。代码不仅要正常工作，而且要让其他人长期受益。拙劣的代码在边缘磨损的速度比你想象的要快得多。</li>
<li>今天的额外努力会减轻明天痛苦。一开始写出好代码并经常重构，日后就会节省的时间和金钱。</li>
<li>你的代码不是你自己的。对作者来说，过于聪明的技巧、黑客和编程手法只是有趣的。对他人友好的代码才是可取的。</li>
</ul>
<p>那究竟什么是 Clean Code 呢？作者给出了自己的观点：</p>
<ul>
<li>整洁代码是简洁的。不是算法或系统的复杂性，而是实现上的简约。</li>
<li>整洁代码是可读的。代码规约有助于写出可读性好的代码。</li>
<li>整洁代码是经过深思熟虑的。假定未来有代码使用者，一看到你的代码就懂。</li>
<li>整洁代码是经过测试的。没人写得出完美的代码，经过测试的代码是整洁的。</li>
<li>整洁代码是经过实践的。要一直写整洁代码，不断练习来提高技能。</li>
<li>整洁代码是经常被重构的。尽可能多地重构，不要担心出问题。</li>
<li>整洁代码符合 SOLID 原则。确保你的代码灵活、可维护、长久。</li>
</ul>
<h2 id="3-tip">3. Tip</h2>
<p>读到<a href="https://book.douban.com/subject/1230413/">《深入理解计算机系统》</a> 第二章 <a href="https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-zheng-shu-biao-shi/">深入理解计算机系统之信息的表示和处理</a>，了解了整数的表示和信息存储方法。理论知识有用么？当然有用。整形溢出是编程中经常遇到的问题，知道整数的表示方式后，会尽量规避溢出的错误。比如二分法中的取中数，<code>mid = (low + high) / 2</code> 就潜在溢出的风险，而 <code>mid = low + (high - low) /2</code>则不会，这样的程序更健壮。</p>
<h2 id="4-share">4. Share</h2>
<p>都说 deadline 是第一生产力，但是也不要总拖到最后，这时往往会因为做得太快而导致质量下降。日常有规划地进行，一步一个脚印，这样才能走得更远。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[深入理解计算机系统之信息的表示和处理（一）]]></title>
        <id>https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-zheng-shu-biao-shi-xin-xi-chu-li-yi</id>
        <link href="https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-zheng-shu-biao-shi-xin-xi-chu-li-yi">
        </link>
        <updated>2019-09-07T14:14:10.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1-信息存储">1. 信息存储</h3>
<p>计算机使用字节作为最小的内存寻址单位，1 个字节等于 8 位。机器级程序将内存视为一个非常大的字节数组，称为虚拟内存。内存的每个字节都用唯一的数字来标识，称为它的地址。所有可能地址的集合称为虚拟地址空间。这个地址空间只是一个展现给机器级程序的概念性映像。</p>
<p>我们一般不直接使用 0 和 1 表示信息，那样的话数据太长了，而且可读性不好。通常把四个二进制当作一组，也就是十六进制表示字节，以 0x 或 0X 开头的数字代表十六进制的值，两个十六进制的值就是一个字节。比如：01011100 等价于 5C。</p>
<figure data-type="image" tabindex="1"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20190907220057.png" alt="十六进制表示法"></figure>
<p>字节用十六进制表示后，下面该确定它的顺序了。内存地址是递增的，是按照人类的习惯，高位在前低位在后，还是相反呢？</p>
<p>字节的排列方式有两种：</p>
<ul>
<li>大端法（big endian）：最高有效字节在前</li>
<li>小端法（little endian）：最低有效字节在前</li>
</ul>
<p>举个例子：0x01234567</p>
<table>
<thead>
<tr>
<th>地址</th>
<th>0x100</th>
<th>0x101</th>
<th>0x102</th>
<th>0x103</th>
</tr>
</thead>
<tbody>
<tr>
<td>大端法</td>
<td>01</td>
<td>23</td>
<td>45</td>
<td>67</td>
</tr>
<tr>
<td>小端法</td>
<td>67</td>
<td>45</td>
<td>23</td>
<td>01</td>
</tr>
</tbody>
</table>
<p>选择何种字节顺序，并没有技术上的优劣之分，只要坚持使用同一种规则。</p>
<p>参数 12345 的十六进制表示为 0x00003039，下面是在不同系统上测试的结果。</p>
<figure data-type="image" tabindex="2"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20190903092905.png" alt="不同数据值的字节表示"></figure>
<p>从上图可以看出，Linux 32、Windows 和 Linux 64 采用小端法表示，Sun 采用大端法表示。</p>
<h3 id="2-整数表示">2. 整数表示</h3>
<p>C 语言的整数分为无符号数和有符号数，而 Java 只有有符号数。</p>
<p>无符号数的所有位都表示值，对于 w 位长度的无符号数，它的取值范围是 0 - 2^w-1，编码表示是唯一的。举个例子：</p>
<blockquote>
<p>1011 = 1 * 2^3 + 0 * 2^2 + 1 * 2^1 + 1 * 2^0 = 11</p>
</blockquote>
<p>有符号数采用补码表示，最高位是符号位，其中 1 代表负数，0 代表正数。对于 w 位长度的无符号数，它的取值范围是 -2^(w-1) - 2^(w-1)，编码表示是唯一的。举个例子：</p>
<blockquote>
<p>1011 = -1 * 2^3 + 0 * 2^2 + 1 * 2^1 + 1 * 2^0 = -5</p>
</blockquote>
<figure data-type="image" tabindex="3"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20190907215430.png" alt="重要的数字"></figure>
<p>其中，U 表示最无符号编码，T 表示补码编码。</p>
<p>有符号数到无符号数的隐式类型转换导致某些非直观的行为，避免这类错误的一种方法是绝不使用无符号数。</p>
<p><strong>总结一下：</strong></p>
<ul>
<li>计算机用二进制表示信息，我们把计算机的二进制用十六进制表示是更友好的升华。</li>
<li>字节的排序方式有两种：大端法和小端法，区别是高位在前还是在后。</li>
<li>无符号数的所有位表示值。</li>
<li>有符号数采用补码表示，最高位是符号位。</li>
<li>无符号数和有符号数之间的转换容易出错，尽量避免使用无符号数。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每周 ARTS 第 22 期]]></title>
        <id>https://isuperqiang.cn/post/mei-zhou-arts-di-22-qi</id>
        <link href="https://isuperqiang.cn/post/mei-zhou-arts-di-22-qi">
        </link>
        <updated>2019-09-01T12:47:10.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-algorithm">1. Algorithm</h2>
<h3 id="15-三数之和中等">15. 三数之和（中等）</h3>
<h5 id="描述">描述：</h5>
<blockquote>
<p>给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。</p>
</blockquote>
<h5 id="示例">示例：</h5>
<pre><code>例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，

满足要求的三元组集合为：
[
  [-1, 0, 1],
  [-1, -1, 2]
]
</code></pre>
<h5 id="思路">思路：</h5>
<p><strong>双指针法</strong></p>
<p>首先对数组进行排序，然后固定一个数 nums[i]，使用左右指针分别指向 nums[i] 后面的两端。计算三个数的和 sum，判断 sum 是否满足为 0。如果满足则添加进结果集，否则左右指针交替向中间移动。同时注意去重。</p>
<pre><code class="language-java">class Sulution {
    public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) {
        if (nums == null || nums.length &lt; 3) {
            return Collections.emptyList();
        }
        Arrays.sort(nums);
        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();
        int length = nums.length;
        for (int i = 0; i &lt; length; i++) {
            if (nums[i] &gt; 0) {
                break;
            }
            if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) {
                continue;
            }
            int l = i + 1, r = length - 1;
            while (l &lt; r) {
                int s = nums[i] + nums[l] + nums[r];
                if (s == 0) {
                    while (l &lt; r &amp;&amp; nums[l] == nums[l + 1]) {
                        l++;
                    }
                    while (l &lt; r &amp;&amp; nums[r] == nums[r - 1]) {
                        r--;
                    }
                    result.add(Arrays.asList(nums[i], nums[l], nums[r]));
                    l++;
                    r--;
                } else if (s &gt; 0) {
                    r--;
                } else {
                    l++;
                }
            }
        }
        return result;
    }

}
</code></pre>
<h5 id="分析">分析：</h5>
<ul>
<li>时间复杂度：O(n^2)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h2 id="2-review">2. Review</h2>
<p><a href="https://medium.com/@maladdinsayed/advanced-techniques-and-ideas-for-better-coding-skills-d632e9f9675">Advanced Coding Skills, Techniques, and Ideas</a></p>
<p>作者列举了一些编程的技巧。</p>
<ul>
<li>重构可以帮助我们写出整洁的代码，可读可维护可重用。</li>
<li>不要重构生产环境中没有经过单元测试的代码，要想重构，先单元测试。</li>
<li>从代码的最深处开始重构，最深处只关注单一的逻辑，这使得重构更加容易。</li>
<li>使你的方法变得短小，通过把它们拆分成更小的方法。</li>
<li>if 语句后面总是跟着 {}，即使只有一行。</li>
<li>不要使用魔法值，因为它的可读性太差了，可以抽取出变量或者常量。</li>
<li>如果没有必要，不要使用 else 语句，比如 if 语句中有 return 时，语句块外不需要 else。</li>
<li>为你的方法、变量和测试选择有意义的命名。</li>
<li>使用你的编程语言的最大能力，这样会省力，增强代码的健壮性。</li>
<li>……</li>
</ul>
<p>代码经验都要靠积累，推荐阿里巴巴的<a href="https://github.com/alibaba/p3c">代码规约</a>。</p>
<h2 id="3-tip">3. Tip</h2>
<p>最近在读<a href="https://book.douban.com/subject/1230413/">《深入理解计算机系统》</a>，又称 CSAPP，真是神书！读完第一章，对计算机系统有了新的认识——<a href="https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-ji-suan-ji-xi-tong-man-you/">深入理解计算机系统之计算机系统漫游</a>。</p>
<h2 id="4-share">4. Share</h2>
<p>说一说如何选书。写书是一件正式的活动，作者都会认真对待。但是作者的经验水平不一样，产出的内容质量也参差不齐。对于追热点的、空洞无物的、作者资历尚浅的图书，一般不值得阅读。辨别的方式是看豆瓣评分，经过时间筛选过的经典，最值得阅读。</p>
]]></content>
    </entry>
</feed>