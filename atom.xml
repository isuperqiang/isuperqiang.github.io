<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://isuperqiang.cn</id>
    <title>落英坠露</title>
    <updated>2020-02-05T10:11:53.996Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://isuperqiang.cn"/>
    <link rel="self" href="https://isuperqiang.cn/atom.xml"/>
    <subtitle>生活不止眼前的苟且，还有诗和远方的田野。</subtitle>
    <logo>https://isuperqiang.cn/images/avatar.png</logo>
    <icon>https://isuperqiang.cn/favicon.ico</icon>
    <rights>All rights reserved 2020, 落英坠露</rights>
    <entry>
        <title type="html"><![CDATA[深入理解计算机系统之并发编程（二）]]></title>
        <id>https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-bing-fa-bian-cheng-er</id>
        <link href="https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-bing-fa-bian-cheng-er">
        </link>
        <updated>2020-01-16T13:10:44.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1-多线程程序中的共享变量">1. 多线程程序中的共享变量</h3>
<p>一组并发线程运行在一个进程的上下文中。每个线程都有自己独立的线程上下文，包括线程 ID、栈、<br>
栈指针、程序计数器、条件码和通用目的寄存器值。每个线程和其他线程共享进程上下文的剩余部分，<br>
包括用户虚拟地址空间，它是由只读文本（代码）、读/写数据、堆以及共享库代码和<br>
数据区组成的。线程也共享相同的打开文件的集合。</p>
<p>寄存器是从不共享的，虚拟内存总是共享的。</p>
<p>多线程的 C 程序中的变量根据它们的存储类型被影射到虚拟内存：</p>
<ul>
<li>全局变量：定义在函数之外的变量，虚拟内存中只有一个实例，任何线程都能引用。</li>
<li>本地自动变量：定义在函数内但没有 static 属性的变量，每个线程都有自己的实例。</li>
<li>本地静态变量：定义在函数内并有 static 属性的变量，和全部变量一样。</li>
</ul>
<p>多线程实现计数器，每个线程对共享变量操作，容易出现同步错误。</p>
<p>进度图将 n 个并发线程的执行，模型化为一条 n 维笛卡尔空间中的轨迹线。每条轴 k 对应<br>
线程 k 的进度，每个点代表线程 k 已经完成指令的状态。</p>
<p>每个线程在执行临界区（critical section）的指令时，拥有对共享变量的互斥（mutual exclusion）访问。<br>
在进度图中，两个临界区的交集形成的状态空间称为不安全区，绕开不安全区的轨迹线叫做安全轨迹线。</p>
<p>任何安全轨迹线都会正确地更新共享变量，为了保证线程化程序的正确执行，我们必须以某种方式同步线程。</p>
<figure data-type="image" tabindex="1"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20191227085650.png" alt="安全和不安全轨迹线" loading="lazy"></figure>
<h3 id="2-使用信号量同步线程">2. 使用信号量同步线程</h3>
<p>一种经典的解决线程同步问题的方法：信号量（semephore）。它是具有非负整数的全局变量，只能由两种特殊的操作处理，成为 P 和 V。P 和 V 来源于荷兰语，分别表示测试和增加。</p>
<p>P 中的测试和减一操作是不可分割的，V 中的加一操作也是不可分割的。当多个线程等待同一个信号量时，<br>
无法预测 V 操作也重启哪个线程。</p>
<p>使用信号量可以确保对共享变量的互斥访问。基本思想是将每个共享变量与一个信号量 s （初始为 1）关联起来，<br>
然后用 P(s) 和 V(s) 操作将相应的临界区包围起来。这种保护共享变量的信号量称为二元信号量，<br>
以提供互斥为目的的二元信号量称为互斥锁。</p>
<p>除了提供互斥外，信号量的另一个重要作用是调度对共享资源的访问。比如生产者-消费者问题，读者-写者问题。</p>
<h3 id="3-使用线程提高并行性">3. 使用线程提高并行性</h3>
<p>所有程序的集合被划分为不相交的顺序程序集合和并发程序的结合，并行程序是一种运行在多个处理器上的并发程序。</p>
<p>来看一个用多线程对整数序列求和的问题，将序列划分为多个不相交的区域，给每个线程分配一个区域。</p>
<ul>
<li>第一种做法，将每个线程求得的和放入共享的全局变量中，用互斥锁保护这个变量。结果性能非常差，同步操作的代价太大。</li>
<li>第二种做法，定义一个全局数组，每个对等线程把和累积在数组的不同位置。同时，使用局部变量消除不必要的内存引用。最终性能提升明显。</li>
</ul>
<p>同步开销巨大，要尽可能避免。如果无可避免，必须要用尽可能多的有用计算弥补这个开销。</p>
<p>随着线程数量的增加，程序运行时间不会一直减少，由于线程上下文切换的开销。</p>
<h3 id="4-其他并发问题">4. 其他并发问题</h3>
<p>可重入(reentrant)函数：当被多个线程调用时，不会引用任何共享数据。比不可重入的线程安全的函数高效一些，因为它不需要同步操作。</p>
<p>避免死锁(deadlock)：给定所有互斥操作的一个全序，如果每个线程都以一种顺序获得互斥锁并以相反的顺序<br>
释放，那么这个程序就是无死锁的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[libyuv 库编译]]></title>
        <id>https://isuperqiang.cn/post/libyuv-ku-bian-yi</id>
        <link href="https://isuperqiang.cn/post/libyuv-ku-bian-yi">
        </link>
        <updated>2020-01-04T12:17:26.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://chromium.googlesource.com/libyuv/libyuv">libyuv</a> 是谷歌开源的对 YUV 数据进行缩放、旋转和转换的跨平台库，可在 Windows、Linux、Mac、Android 等操作系统，x86、x64、arm 架构上进行编译运行，支持 AVX2、NEON 等 SIMD 指令加速。</p>
<p>官方介绍的几个功能：</p>
<ul>
<li>可以使用 point，bilinear 或 box 三种方法进行 YUV 的压缩</li>
<li>可以转换为 RGB 来实现渲染/特效</li>
<li>旋转 90/180/270 的角度以适配设备的竖屏模式</li>
<li>可以把 webcam 转换为 YUV 来进行压缩</li>
<li>还有一系列的平台性能优化等</li>
</ul>
<p>接下来让我们编译 libyuv，编译步骤在 Windows 和 Mac 上都验证成功，下面以 Mac 为例。</p>
<h3 id="1-clone-libyuv-源码">1. clone libyuv 源码</h3>
<p>既然要编译库，怎么少得了源码呢？</p>
<pre><code>git clone https://chromium.googlesource.com/libyuv/libyuv
</code></pre>
<h3 id="2-重命名文件夹">2. 重命名文件夹</h3>
<p>clone 的文件夹叫做 libyuv，这里要把它修改为 jni。</p>
<h3 id="3-修改-androidmk">3. 修改 Android.mk</h3>
<p>注释 jpeg 相关的代码，其他地方不用改动。</p>
<figure data-type="image" tabindex="1"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/clipboard2.png" alt="fix-jpeg1" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/clipboard3.png" alt="fix-jpeg2" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/clipboard.png" alt="fix-jpeg3" loading="lazy"></figure>
<p>下面是修改后的 Android.mk 文件内容：</p>
<pre><code># This is the Android makefile for libyuv for NDK.
LOCAL_PATH:= $(call my-dir)

include $(CLEAR_VARS)

LOCAL_CPP_EXTENSION := .cc

LOCAL_SRC_FILES := \
    source/compare.cc           \
    source/compare_common.cc    \
    source/compare_gcc.cc       \
    source/compare_mmi.cc       \
    source/compare_msa.cc       \
    source/compare_neon.cc      \
    source/compare_neon64.cc    \
    source/convert.cc           \
    source/convert_argb.cc      \
    source/convert_from.cc      \
    source/convert_from_argb.cc \
    source/convert_to_argb.cc   \
    source/convert_to_i420.cc   \
    source/cpu_id.cc            \
    source/planar_functions.cc  \
    source/rotate.cc            \
    source/rotate_any.cc        \
    source/rotate_argb.cc       \
    source/rotate_common.cc     \
    source/rotate_gcc.cc        \
    source/rotate_mmi.cc        \
    source/rotate_msa.cc        \
    source/rotate_neon.cc       \
    source/rotate_neon64.cc     \
    source/row_any.cc           \
    source/row_common.cc        \
    source/row_gcc.cc           \
    source/row_mmi.cc           \
    source/row_msa.cc           \
    source/row_neon.cc          \
    source/row_neon64.cc        \
    source/scale.cc             \
    source/scale_any.cc         \
    source/scale_argb.cc        \
    source/scale_common.cc      \
    source/scale_gcc.cc         \
    source/scale_mmi.cc         \
    source/scale_msa.cc         \
    source/scale_neon.cc        \
    source/scale_neon64.cc      \
    source/video_common.cc

common_CFLAGS := -Wall -fexceptions
# ifneq ($(LIBYUV_DISABLE_JPEG), &quot;yes&quot;)
# LOCAL_SRC_FILES += \
#     source/convert_jpeg.cc      \
#     source/mjpeg_decoder.cc     \
#     source/mjpeg_validate.cc
# common_CFLAGS += -DHAVE_JPEG
# LOCAL_SHARED_LIBRARIES := libjpeg
# endif

LOCAL_CFLAGS += $(common_CFLAGS)
LOCAL_EXPORT_C_INCLUDES := $(LOCAL_PATH)/include
LOCAL_C_INCLUDES += $(LOCAL_PATH)/include
LOCAL_EXPORT_C_INCLUDE_DIRS := $(LOCAL_PATH)/include

LOCAL_MODULE := libyuv_static
LOCAL_MODULE_TAGS := optional

include $(BUILD_STATIC_LIBRARY)

include $(CLEAR_VARS)

LOCAL_WHOLE_STATIC_LIBRARIES := libyuv_static
# 生成库的名称
LOCAL_MODULE := libyuv
# ifneq ($(LIBYUV_DISABLE_JPEG), &quot;yes&quot;)
# LOCAL_SHARED_LIBRARIES := libjpeg
# endif

# 生成静态库还是动态库
# BUILD_STATIC_LIBRSRY 静态库
# BUILD_SHARED_LIBRARY 动态库
include $(BUILD_SHARED_LIBRARY)

include $(CLEAR_VARS)
LOCAL_STATIC_LIBRARIES := libyuv_static
# LOCAL_SHARED_LIBRARIES := libjpeg
LOCAL_MODULE_TAGS := tests
LOCAL_CPP_EXTENSION := .cc
LOCAL_C_INCLUDES += $(LOCAL_PATH)/include
LOCAL_SRC_FILES := \
    unit_test/unit_test.cc        \
    unit_test/basictypes_test.cc  \
    unit_test/color_test.cc       \
    unit_test/compare_test.cc     \
    unit_test/convert_test.cc     \
    unit_test/cpu_test.cc         \
    unit_test/cpu_thread_test.cc  \
    unit_test/math_test.cc        \
    unit_test/planar_test.cc      \
    unit_test/rotate_argb_test.cc \
    unit_test/rotate_test.cc      \
    unit_test/scale_argb_test.cc  \
    unit_test/scale_test.cc       \
    unit_test/video_common_test.cc

LOCAL_MODULE := libyuv_unittest
include $(BUILD_NATIVE_TEST)
</code></pre>
<h3 id="4-新建-applicationmk">4. 新建 Application.mk</h3>
<p>在 jni 文件夹下，新建 Application.mk 文件，指定架构平台和 Android 版本，内容如下：</p>
<pre><code>APP_ABI := armeabi-v7a arm64-v8a x86 x86_64
APP_PLATFORM := android-18
</code></pre>
<h3 id="5-ndk-build-编译">5. ndk-build 编译</h3>
<p>编译前要确保本机配置好了 NDK 环境变量，如果不知道怎么做请自行百度。</p>
<p>cd 到 jni 文件夹的父级文件夹，然后执行 ndk 相关的命令。每次编译前都要先执行 <code>ndk-build clean</code> 清理缓存，最后执行 <code>ndk-build</code> 编译库，在 jni 父文件夹下就会出现两个文件夹： libs 文件夹下是动态库，obj 文件夹下是静态库。</p>
<figure data-type="image" tabindex="4"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20200104200940.png" alt="ndk-build" loading="lazy"></figure>
<p><strong>参考文章：</strong></p>
<ul>
<li><a href="https://yangandmore.github.io/2019/03/07/libYUV%E7%BC%96%E8%AF%91/">libYUV编译</a></li>
<li><a href="https://github.com/byhook/ffmpeg4android/blob/master/readme/android%E5%85%A8%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91libyuv%E5%BA%93%E5%AE%9E%E7%8E%B0YUV%E5%92%8CRGB%E7%9A%84%E8%BD%AC%E6%8D%A2.md">android全平台编译libyuv库实现YUV和RGB的转换</a></li>
<li><a href="http://www.raomengyang.com/2017/01/15/Android-libyuv%E5%BA%94%E7%94%A8%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89libyuv%E7%9A%84%E4%BD%BF%E7%94%A8/">Android libyuv应用系列（二）libyuv的使用</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[哈希算法及其应用]]></title>
        <id>https://isuperqiang.cn/post/ha-xi-suan-fa-ji-qi-ying-yong</id>
        <link href="https://isuperqiang.cn/post/ha-xi-suan-fa-ji-qi-ying-yong">
        </link>
        <updated>2019-12-27T14:29:54.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1-什么是哈希算法">1. 什么是哈希算法？</h3>
<p>将任意长度的二进制值串映射为固定长度的二进制值串，这个映射的规则就是哈希算法，而通过原始数据映射之后得到的二进制值串就是哈希值。</p>
<p>哈希算法历史悠久，业界著名的哈希算法也有很多，比如 MD5、SHA 等。在我们平时的开发中，基本上都是拿现成的直接用。</p>
<p>怎样算是优秀的哈希算法？</p>
<ul>
<li>从哈希值不能反向推导出原始数据（所以哈希算法也叫单向哈希算法）；</li>
<li>对输入数据非常敏感，哪怕原始数据只修改了一个 Bit，最后得到的哈希值也大不相同；</li>
<li>散列冲突的概率要很小，对于不同的原始数据，哈希值相同的概率非常小；</li>
<li>哈希算法的执行效率要尽量高效，针对较长的文本，也能快速地计算出哈希值。</li>
</ul>
<p>哈希算法的应用非常非常多，包括安全加密、唯一标识、数据校验、散列函数、负载均衡、数据分片、分布式存储等。</p>
<h3 id="2-应用一安全加密">2. 应用一：安全加密</h3>
<p>常用的加密哈希算法：</p>
<ul>
<li>MD5（MD5 Message-Digest Algorithm，MD5 消息摘要算法）</li>
<li>SHA（Secure Hash Algorithm，安全散列算法）</li>
<li>DES（Data Encryption Standard，数据加密标准）</li>
<li>AES（Advanced Encryption Standard，高级加密标准）</li>
</ul>
<p>对用于加密的哈希算法来说，有两点格外重要。第一点是很难根据哈希值反向推导出原始数据，第二点是散列冲突的概率要很小。</p>
<p>基于鸽巢原理，哈希算法无法避免散列冲突。一般情况下，哈希值越长的哈希算法，散列冲突的概率越低。即便哈希算法存在散列冲突的情况，但是因为哈希值的范围很大，冲突的概率极低，所以相对来说还是很难破解的。</p>
<p>越是复杂哈希算法越难破解，但同样计算时间也就越长。所以，选择哈希算法的时候，要权衡安全性和计算时间来决定用哪种哈希算法。</p>
<h3 id="3-应用二唯一标识">3. 应用二：唯一标识</h3>
<p>给每张图片取一个唯一标识，或者说信息摘要，就可以从海量图库中快速搜索一张图片。</p>
<p>哈希算法可以对大数据做信息摘要，通过一个较短的二进制编码来表示很大的数据。</p>
<h3 id="4-应用三数据校验">4. 应用三：数据校验</h3>
<p>BT 下载的文件经过哈希算法校验，用于校验数据的完整性和正确性。</p>
<h3 id="5-应用四散列函数">5. 应用四：散列函数</h3>
<p>散列函数对哈希算法的要求非常特别，更加看重的是散列的平均性和哈希算法的执行效率。</p>
<h3 id="6-应用五负载均衡">6. 应用五：负载均衡</h3>
<p>利用哈希算法替代映射表，可以实现一个会话粘滞的负载均衡策略。</p>
<p>我们可以通过哈希算法，对客户端 IP 地址或者会话 ID 计算哈希值，将取得的哈希值与服务器列表的大小进行取模运算，最终得到的值就是应该被路由到的服务器编号。 这样就可以把同一个 IP 过来的所有请求，都路由到同一个后端服务器上。</p>
<h3 id="7-应用六数据分片">7. 应用六：数据分片</h3>
<p>通过哈希算法对处理的海量数据进行分片，多机分布式处理，可以突破单机资源的限制。</p>
<ol>
<li>如何统计“搜索关键词”出现的次数？</li>
</ol>
<p>可以先对数据进行分片，然后采用多台机器处理的方法，来提高处理速度。具体的思路是这样的：为了提高处理的速度，我们用 n 台机器并行处理。从搜索记录的日志文件中，依次读出每个搜索关键词，并且通过哈希函数计算哈希值，然后再跟 n 取模，最终得到的值，就是应该被分配到的机器编号。</p>
<ol start="2">
<li>如何快速判断图片是否在图库中？</li>
</ol>
<p>通过同样的哈希算法，计算这个图片的唯一标识，然后与机器个数 n 求余取模。假设得到的值是 k，那就去编号 k 的机器构建的散列表中查找。</p>
<h3 id="8-分布式存储">8. 分布式存储</h3>
<p>利用一致性哈希算法，可以解决缓存等分布式系统的扩容、缩容导致数据大量搬移的难题。</p>
<p>假设我们有 k 个机器，数据的哈希值的范围是 [0, MAX]。我们将整个范围划分成 m 个小区间（m 远大于 k），每个机器负责 m/k 个小区间。当有新机器加入的时候，我们就将某几个小区间的数据，从原来的机器中搬移到新的机器中。这样，既不用全部重新哈希、搬移数据，也保持了各个机器上数据数量的均衡。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[深入理解计算机系统之并发编程（一）]]></title>
        <id>https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-bing-fa-bian-cheng-yi</id>
        <link href="https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-bing-fa-bian-cheng-yi">
        </link>
        <updated>2019-12-15T14:46:37.000Z</updated>
        <content type="html"><![CDATA[<p>并发不仅是操作系统内核用来运行多个应用程序的机制，还可以在应用程序中扮演重要角色。</p>
<p>现代操作系统提供三种基本的构造并发程序的方法：</p>
<ul>
<li>进程</li>
<li>I/O 多路复用</li>
<li>线程</li>
</ul>
<h3 id="1-基于进程的并发编程">1. 基于进程的并发编程</h3>
<p>每个逻辑控制流都是一个进程，由内核来调度和维护。进程有独立的虚拟地址空间，想要和其他流通信，必须使用某种显式的进程间通信（IPC）机制。我们可以使用熟悉的函数，像 fork、exec 和 waitpid 来构造进程。</p>
<p>对于在父、子进程间共享状态信息，进程有个非常清晰的模型：共享文件表，但是不共享用户地址空间。独立的地址空间确保一个进程不会覆盖另一个进程的虚拟内存，消除了许多令人迷惑的错误。同时也使得进程共享状态信息更加困难，为了共享信息，必须使用显示的 IPC 机制，但是进程控制和 IPC 的开销很高。</p>
<h3 id="2-基于-io-多路复用的并发编程">2. 基于 I/O 多路复用的并发编程</h3>
<p>I/O 多路复用（multiplexing）技术，基本思路就是使用 select 函数，要求内核挂起进程，只有在一个或者多个<br>
I/O 事件发生后，才将控制返回给应用程序。select 是个复杂的函数，有许多不同的使用场景。</p>
<p>在事件驱动程序中，某些事件会驱动、导致流的推进。而I/O 多路复用可以作为事件驱动程序的基础。在事件驱动程序中，逻辑流被模型化为状态机，一个状态机就是一组状态、输入事件、转移。<br>
当一个输入事件发生，状态机发生转移，变化为另一个状态。</p>
<p>服务器使用 I/O 多路复用技术，借助 select 函数检测输入事件的发生。当每个已连接描述符准备好可读时，服务器就为相应的状态机执行转移。</p>
<p>事件驱动设计的优点是，它比基于进程的设计具有更多对程序行为的控制。另一个优点是，每个逻辑流<br>
都能访问该进程的全部地址空间，这使得在流之间共享数据变得容易。</p>
<p>事件驱动设计的缺点是，编码复杂，不能充分利用多核处理器。</p>
<h3 id="3-基于线程的并发编程">3. 基于线程的并发编程</h3>
<p>线程就是运行在进程上下文中的逻辑流。每个线程都有自己的线程上下文，包括一个唯一的整数线程 ID、栈、栈指针、程序计数器、通用目的寄存器和条件码。所有运行在一个进程内的线程共享该进程的整个虚拟地址空间。</p>
<p>同进程一样，线程由内核自动调度，并且内核通过一个整数 ID 来识别线程。同基于 I/O 多路复用的流一样，多个线程运行在单一进程的上下文中，因此共享这个进程虚拟地址空间的所有内容，包括它的代码、数据、堆、共享库和打开的文件。</p>
<figure data-type="image" tabindex="1"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20191225065818.png" alt="并发线程执行" loading="lazy"></figure>
<p>每个进程开始生命周期都是单线程，这个线程称为主线程（main thread）。在某一时刻，主线程创建一个对等线程（peer thread），从这个时间点开始，两个线程并发地运行。最后主线程执行一个慢速系统调用，比如 read 或 sleep，或者被系统的间隔计时器中断，控制就会通过上下文切换传递到对等线程。对等线程会执行一段时间，然后控制传递回主线程，依次类推。</p>
<p>线程和进程的不同之处有：</p>
<ul>
<li>线程的上下文比进程的上下文小得多，所以线程的上下文切换要比进程的上下文切换快得多。</li>
<li>线程不像进程那样，不是按照严格的父子层次组织的，和一个进程相关的线程组成一个对等线程（池）。</li>
</ul>
<p>对等线程（池）的主要影响是，一个线程可以杀死它的任何对等线程，或者等待它的任意对等线程终止。每个对等线程都能读写相同的共享数据。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[深入理解计算机系统之网络编程（二）]]></title>
        <id>https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-wang-luo-bian-cheng-er</id>
        <link href="https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-wang-luo-bian-cheng-er">
        </link>
        <updated>2019-12-06T00:35:33.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1-套接字接口">1. 套接字接口</h3>
<p>套接字接口是一组函数，它们和 Unix I/O 函数结合，用来创建网络应用。</p>
<figure data-type="image" tabindex="1"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20191210084427.png" alt="基于套接字接口的网络应用" loading="lazy"></figure>
<p>从 Linux 内核的角度看，套接字就是通信的端点；从 Linux 程序的角度看，套接字就是有相应描述符的打开文件。</p>
<h3 id="2-web-服务器">2. Web 服务器</h3>
<p>Web 客户端和服务器之间的交互通过基于文本的 HTTP 协议。浏览器打开一个网络连接，向服务器请求某些内容。服务器响应所请求的内容，然后关闭连接。浏览器读取这些内容，并把它显示在屏幕上。</p>
<p>Web 内容是一个与 MIME 类型相关的字节序列，比如 text/html、image/jpeg 等。<br>
Web 服务器通过两种方式向客户端提供内容：</p>
<ul>
<li>取一个磁盘文件，并将它的内容返回客户端，称为静态内容。</li>
<li>运行一个可执行文件，并将它的输出返回客户端，称为动态内容。</li>
</ul>
<p>Http 请求（GET 方法）的组成是这样的：一个请求行，后面跟随多个请求报头，再跟随一个空文本行来终止报头。<br>
请求行的格式是：method URI version。请求报头的格式为：header-name: header-data。</p>
<pre><code>GET / HTTP/1.1
Host: www.qq.com

</code></pre>
<p>Http 响应的组成是这样的：一个响应行，后面跟随多个响应报头，再跟随一个终止报头的空文本行，最后跟随响应主体。<br>
响应行的格式是：version status-code status-message。</p>
<pre><code>HTTP/1.0 200 OK
MIME-Version: 1.0
Date: Jan, 11 Dec 2019 12:00:00
Server: Apache-Coyote/1.1
Content-Type: text/html
Content-Length: 42090

&lt;html&gt;
...
&lt;/html&gt;
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20191211081627.png" alt="Http事务" loading="lazy"></figure>
<p>GET 请求的参数在 URI 中。用 <code>？</code> 分隔文件名和参数，每个参数用 <code>&amp;</code> 分隔，参数不允许有空格。POST 请求的参数在请求主体中。</p>
<p>服务器程序遵守 CGI（通用网关接口）标准，CGI 可以管理客户端如何将参数传递给服务器，服务器如何将参数和其他信息传递给子进程，以及子进程如何将它的输出返回客户端。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[深入理解计算机系统之网络编程（一）]]></title>
        <id>https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-wang-luo-bian-cheng-yi</id>
        <link href="https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-wang-luo-bian-cheng-yi">
        </link>
        <updated>2019-11-29T00:20:28.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1-客户端-服务端编程模型">1. 客户端-服务端编程模型</h3>
<p>每个网络应用都是基于客户端-服务器模型。一个应用是由一个服务器进程和一个或者多个客户端进程组成。服务器管理某种资源，并且通过这种资源来为它的客户端提供某种服务。客户端和服务器是进程，而不是常提到的机器或者主机。</p>
<p>客户端-服务器模型中的基本操作是事务。这个事务不是数据库事务，没有数据库事务的任何特性，它仅仅是客户端和服务器执行的一系列步骤。</p>
<figure data-type="image" tabindex="1"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20191209080352.png" alt="客户端-服务器事务" loading="lazy"></figure>
<h3 id="2-网络">2. 网络</h3>
<p>对主机而言，网路只是另一种 I/O 设备，是数据源和数据接收方。</p>
<p>网路是一个按照地理远近组成的层次系统，最低层是局域网（LAN），最流行的局域网技术是以太网。</p>
<p>网络协议消除了不同网络之间的差异，使主机和路由器协同工作来实现数据传输，封装是数据传输的关键。</p>
<h3 id="3-全球-ip-因特网">3. 全球 IP 因特网</h3>
<p>客户端-服务器应用的组织一直保持相当的稳定。每台主机都运行实现 TCP/IP 的软件，几乎每个现代<br>
计算机都支持这个协议。客户端和服务器混合使用套接字接口函数和 Unix I/O 函数进行通信。</p>
<p>一个 IP 地址就是一个 32 位无符号整数，使用点分十进制表示法表示。为了方便人们记忆，定义了域名以及将域名映射到 IP 地址的机制。</p>
<p>套接字是连接的端点，套接字地址是由互联网地址和 16 位的整数端口组成的，用「地址：端口」来表示。当客户端发起一个请求时，<br>
客户端套接字地址中的端口是由内核自动分配的，称为临时端口。服务器套接字地址端口通常是某个知名端口，和 这个服务相对应。</p>
<figure data-type="image" tabindex="2"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20191210081750.png" alt="互联网连接分析" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[深入理解计算机系统之系统级IO]]></title>
        <id>https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-xi-tong-ji-io</id>
        <link href="https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-xi-tong-ji-io">
        </link>
        <updated>2019-11-24T13:00:15.000Z</updated>
        <content type="html"><![CDATA[<p>输入/输出(I/O) 是在主存和外部设备之间复制数据的过程。输入操作是从 I/O 设备复制到主存，输出操作是从主存复制到 I/O 设备。</p>
<h3 id="1-unix-io">1. Unix I/O</h3>
<p>一个 Linux 文件就是一个 m 个字节的序列。所有的 I/O 设备都被模型化为文件，所有的输入和输出都被当作相应文件的读和写来执行。这种将设备优雅地映射为文件的方式，允许 Linux 内核引出一个简单、低级的应用接口，称为 Unix I/O。</p>
<h3 id="2-文件">2. 文件</h3>
<p>每个 Linux 文件都有一个类型来表明它在系统中的角色：</p>
<ul>
<li>普通文件包含任意数据。</li>
<li>目录是包含一组链接的文件。</li>
<li>套接字是用来与另一个进程进行跨网络通信的文件。</li>
</ul>
<p>Linux 内核将所有文件都组织称一个目录层次结构，由名为 / 的根目录确定。</p>
<figure data-type="image" tabindex="1"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20191124201916.png" alt="Linux 目录层次结构" loading="lazy"></figure>
<p>作为其上下文的一部分，每个进程都有一个当前工作目录，来确定其在目录层次结构中的当前位置。</p>
<h3 id="3-用-rio-包健壮地读写">3. 用 RIO 包健壮地读写</h3>
<p>应用程序不该直接使用 Unix I/O 函数，而应该使用 RIO 包。RIO 包提供了两类不同的函数：无缓冲的输出输出函数和有缓冲的输入函数。RIO 包通过反复执行读写操作，直到传送完所有的请求数据，自动处理不足值。</p>
<h3 id="4-io-重定向">4. I/O 重定向</h3>
<p>Linux shell 提供了 I/O 重定向操作符，允许用户将磁盘文件和标准输入输出联系起来。例如：</p>
<p><code>linux&gt; ls &gt; foo.txt</code>。</p>
<h3 id="5-该使用哪些-io-函数">5. 该使用哪些 I/O 函数</h3>
<p>标准 I/O 库是基于 Unix I/O 实现的，并提供了一组强大的高级 I/O 例程。对于大多数应用程序而言，标准 I/O 更简单，是优于 Unix I/O 的选择。然而，因为 Unix I/O 和网络文件之间有些相互不兼容的限制，Unix I/O 更适合用于网络应用程序。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[深入理解计算机系统之虚拟内存（二）]]></title>
        <id>https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-xu-ni-nei-cun-er</id>
        <link href="https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-xu-ni-nei-cun-er">
        </link>
        <updated>2019-11-22T01:14:46.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1-内存映射">1. 内存映射</h3>
<p>Linux 通过将虚拟内存区域与磁盘上的对象关联起来，来初始化这个虚拟内存区域的内容，这个过程称为内存映射。虚拟内存区域可以映射到两种类型的对象中的一种：</p>
<ul>
<li>Linux 文件系统中的普通文件：磁盘文件的连续部分。</li>
<li>匿名文件：由内核创建，包含的都是二进制零。</li>
</ul>
<p>一旦虚拟页面被初始化，它就在由内核维护的交换空间之间换来换去。在任何时刻，交换空间都限制当前运行的进程能够分配的虚拟页面的总数。</p>
<p>一个对象可以被映射到虚拟内存的一个区域，要么作为共享对象，要么作为私有对象。进程对共享对象映射到的虚拟地址空间的写操作，对把该共享对象映射到它们虚拟内存区域的其他进程也是可见的，并且这些变化反映在磁盘上的对象中。另一方面，对于映射到私有对象的区域的改变，对其他进程来说是不可见的，并且不会反映在磁盘上的对象中。</p>
<p>许多进程有同样的只读代码区域，内存映射可以控制多个进程如何共享对象。即使对象被映射到多个共享区域，物理内存中只需要存放共享对象的一个副本。</p>
<p>私有对象使用写时复制（copy-on-write）的技术被映射到虚拟内存中。和共享对象一样，在物理内存中只保存私有对象的一个副本。当一个进程试图写私有区域内的某个页面时，写操作就会触发一个保护故障。故障处理程序会在物理内存中创建这个页面的新副本，更新页表条目指向新副本，恢复这个页面的写权限。当故障处理程序返回时，CPU 就可以正常执行写操作了。</p>
<h3 id="2-动态内存分配">2. 动态内存分配</h3>
<p>当运行时需要额外虚拟内存时，用动态内存分配器更方便，也有更好的可移植性。</p>
<p>动态内存分配器维护着一个进程的虚拟内存区域，称为堆。分配器将堆视为一组不同大小的块的集合来维护。每个块就是一个连续的虚拟内存片，要么是已分配的，要么是空闲的。</p>
<p>分配器有两种基本风格，两种风格都要求应用显式地分配块，它们的不同之处在于由哪个实体负责释放已分配的块。</p>
<ul>
<li>显式分配器要求应用显式地释放任何已分配的块。例如 C 通过调用 malloc 和 free 分配和释放块。</li>
<li>隐时分配器会自动释放不再使用的已分配的块。例如 Java 的垃圾回收。</li>
</ul>
<p>造成堆利用率很低的主要原因是碎片的现象，当有未使用的内存但不能用来满足分配请求时，就发生这种现象。分配器通常采用试图维持少量的大空闲块，而不是维持大量的小空闲块。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[深入理解计算机系统之虚拟内存（一）]]></title>
        <id>https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-xu-ni-nei-cun-yi</id>
        <link href="https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-xu-ni-nei-cun-yi">
        </link>
        <updated>2019-11-08T14:40:47.000Z</updated>
        <content type="html"><![CDATA[<p>为了更加有效地管理内存并减少出错，现代系统提供了虚拟内存（VM）的概念，它为每个进程提供了一个庞大、一致和私有的地址空间。</p>
<p>虚拟内存提供了三个重要能力：</p>
<ul>
<li>把主存看成一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据</li>
<li>为每个进程提供一致的地址空间，从而简化了内存管理</li>
<li>保护每个进程的地址空间不被其他进程破坏</li>
</ul>
<h3 id="1-物理和虚拟寻址">1. 物理和虚拟寻址</h3>
<p>早起的 PC 使用物理寻址，现代处理器使用虚拟寻址。虚拟寻址的方式需要内存管理单元（MMU）将虚拟地址转换为物理地址。</p>
<figure data-type="image" tabindex="1"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20191106085329.png" alt="物理寻址" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20191106085354.png" alt="虚拟寻址" loading="lazy"></figure>
<h3 id="2-地址空间">2. 地址空间</h3>
<p>地址空间是一个非负整数地址的有序集合。如果地址空间中的整数是连续的，那么它就是线性地址空间。</p>
<p>在带有虚拟内存的系统中，CPU 从含有 N=2^n 个地址的地址空间中生成虚拟地址，称为虚拟地址空间。</p>
<p>系统还有一个物理地址空间，对应物理内存的 M 个字节。</p>
<p>地址空间清楚地区分了数据对象（字节）和它们的属性（地址）。允许每个对象有多个独立的地址，其中每个地址都选自不同的地址空间，这就是虚拟内存的基本思想。主存中的每个字节都有一个来自虚拟地址空间的虚拟地址和来自物理地址空间的物理地址。</p>
<h3 id="3-虚拟内存作为缓存的工具">3. 虚拟内存作为缓存的工具</h3>
<p>虚拟内存被组织为一个由存放在磁盘上的 N 个连续的字节大小的单元组成的数组。每个字节都有一个唯一的虚拟地址，作为到数组的索引。磁盘上数组的内容被缓存在主存中。</p>
<p>虚拟内存被分割为称作虚拟页（VP）的大小固定块，来作为磁盘和主存之间的传输单元。类似地，物理内存被分割为物理页。在任意时刻，虚拟页面的集合都分为三个不相交的子集：未分配的、缓存的、未缓存的。</p>
<p>页表（page table）将虚拟页映射到物理页。每次 MMU（内存管理单元）中的地址翻译硬件将虚拟地址转换为物理地址时，都会读取页表。<br>
操作系统负责维护页表的内容，以及在磁盘与 DRAM 之间来回传送页。</p>
<figure data-type="image" tabindex="3"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20191115220042.png" alt="页表" loading="lazy"></figure>
<p>页表就是一个页表条目（PTE）的数组。虚拟地址空间中的每个页在页表中一个固定偏移量处都有一个 PTE。</p>
<p>DRAM 缓存不命中称为缺页（page fault）。缺页会触发缺页异常，该异常调用缺页异常处理程序，该程序会选择一个牺牲页，<br>
内核总会修改牺牲页的页表条目，牺牲页就不再缓存在主存中。当异常处理程序返回时，它会重新启动导致缺页的指令，<br>
该指令会把导致缺页的虚拟地址发送到地址翻译硬件，页命中就能由地址翻译硬件正常处理了。</p>
<p>在磁盘和内存之间传送页的活动叫做交换（swapping）或者页面调度（paging）。页从磁盘换入 DRAM 和 从 DRAM 换出磁盘。<br>
当有不命中发生时才换入页面的策略叫做按需页面调度（demand paging）。所有现在操作系统都是用按需页面调度的方式。</p>
<p>尽管在整个运行过程中程序引用的不同页面的总数可能超出物理内存总的大小，但是局部性原理保证了在任意时刻，<br>
程序将趋于在一个较小的活动页面（active page）集合上工作，这个集合叫做工作集合。</p>
<p>如果工作集的大小超出了物理内存的大小，那么程序将产生一种不幸的状态，叫做抖动（thrashing），这时页面将不断地换进换出。</p>
<h3 id="4-虚拟内存作为内存管理的工具">4. 虚拟内存作为内存管理的工具</h3>
<p>实际上，操作系统为每个进程提供了一个独立的页表，也就是一个独立的虚拟地址空间。注意，多个虚拟页面可以映射到同一个共享的物理页面上。</p>
<figure data-type="image" tabindex="4"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20191115221725.png" alt="内存管理" loading="lazy"></figure>
<h3 id="5-虚拟存在作为内存保护的工具">5. 虚拟存在作为内存保护的工具</h3>
<p>提供独立的地址空间使得区分不同进程的私有内存变得容易。地址翻译机制可以通过一种自然的方式扩展到提供更好的访问控制。CPU 每次生成一个地址时，地址翻译硬件都会读一个 PTE。所以可以通过在 PTE 上添加一些额外的许可位来控制一个虚拟页面内容的访问。</p>
<figure data-type="image" tabindex="5"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20191115222808.png" alt="内存保护" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[深入理解计算机系统之异常控制流（二）]]></title>
        <id>https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-yi-chang-kong-zhi-liu-er</id>
        <link href="https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-yi-chang-kong-zhi-liu-er">
        </link>
        <updated>2019-11-03T09:30:36.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1-进程控制">1. 进程控制</h3>
<p>每个进程都有一个唯一的正数进程 ID(PID)。</p>
<p>从程序员的角度，可以认为进程总是处于下面三种状态之一：</p>
<ul>
<li>运行。进程要么在执行，要么等待被执行。</li>
<li>停止。进程的执行被挂起，且不会被调度。</li>
<li>终止。进程永远地停止了。</li>
</ul>
<p>父进程通过 fork 函数创建一个新运行的子进程，新创建的子进程几乎但不完全与父进程相同，它们之间的最大区别是有不同的 PID。</p>
<p>当一个进程由于某种原因终止时，进程保持一种终止的状态，直到被它的父进程回收。</p>
<p>execve 函数在当前进程的上下文中加载并运行一个新程序。</p>
<h3 id="2-信号">2. 信号</h3>
<p>一个信号就是一条消息，它通知进程系统中发生某种类型的事件。</p>
<p>传递一个信号到目的进程是由两个步骤组成的：</p>
<ul>
<li>发送信号：内核通过更新目的进程上下文中的某个状态，发送一个信号给目的进程。</li>
<li>接收信号：当目的进程被内核强迫以某种方式对信号的发送做出反应时，它就接收了信号。</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20191103170627.png" alt="信号处理" loading="lazy"></figure>
<p>Unix 系统提供了大量的进程发送信号机制，这些机制都是基于进程组这个概念。每个进程只属于一个进程组，<br>
进程组由一个正整数 ID 标识。默认地，子进程和它的父进程属于同一个进程组。</p>
<p>当内核把进程 p 从内核模式切换到用户模式时，它会检查进程 p 的未被阻塞的待处理信号集合，如果集合为空，那么内核将控制传递到 p 的逻辑控制流的下一条指令。如果集合非空，那么内核选择集合中的某个信号 k，并且强制 p 接收 k。收到这个信号会触发进程采取某种行为。一旦进程完成了这个行为，那么控制就传递回 p 的逻辑控制流的下一条指令。</p>
]]></content>
    </entry>
</feed>