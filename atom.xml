<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://isuperqiang.github.io</id>
    <title>落英坠露</title>
    <updated>2021-01-11T16:42:37.049Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://isuperqiang.github.io"/>
    <link rel="self" href="https://isuperqiang.github.io/atom.xml"/>
    <subtitle>生活不止眼前的苟且，还有诗和远方的田野。</subtitle>
    <logo>https://isuperqiang.github.io/images/avatar.png</logo>
    <icon>https://isuperqiang.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 落英坠露</rights>
    <entry>
        <title type="html"><![CDATA[作为程序员的我，核心竞争力是什么]]></title>
        <id>https://isuperqiang.github.io/post/zuo-wei-cheng-xu-yuan-de-wo-he-xin-jing-zheng-li-shi-shi-me/</id>
        <link href="https://isuperqiang.github.io/post/zuo-wei-cheng-xu-yuan-de-wo-he-xin-jing-zheng-li-shi-shi-me/">
        </link>
        <updated>2020-12-15T14:08:12.000Z</updated>
        <content type="html"><![CDATA[<p>在准备面试的过程中，突然想到一个问题：面试这个岗位的人那么多，和其他人相比，你的优势在什么地方，公司为什么要录用你？<br>
在技术水平相当的情况下，很难取舍到底要录用哪个人，这时候个人核心竞争力就发挥作用了。</p>
<p>什么是核心竞争力？核心竞争力就是我们每个人身上，区别于别人的独特“优点”，比如超牛的研发能力、超强的管理能力<br>
、熟练的人际关系处理能力等等，这些就属于一个人的“核心竞争力”。</p>
<p>在工作的这几年中，积累了不少优秀的习惯，这就是我的核心竞争力。下面一一列出来：</p>
<ul>
<li>
<p><strong>万丈高楼平地起</strong></p>
<p>想要成为优秀的程序员，必须具备扎实的计算机基础。基础是最硬核最干的，基础好的人触类旁通，学什么都快。比如，之前遇到过浮点数比较相等不准确，想起来是因为浮点数是用符号位、阶码和尾数的方式表示，它本身就是不精确的，比较相等自然不精确。</p>
</li>
<li>
<p><strong>磨刀不误砍柴工</strong></p>
<p>熟练的手头工具：adb 命令、Linux 命令、Git 命令、IDE 快捷键等等，就像工匠的工具箱。追求高效的程序员都会熟练使用它们，来提升自己的开发效率。在开发中我经常使用终端命令，相比带 GUI 的操作界面，我觉得终端更加 Geek。</p>
</li>
<li>
<p><strong>无规矩不成方圆</strong></p>
<p>内部研发规范有利于降低沟通成本、提升工程质量，包括代码规范、发版规范等。目前公司的研发规范都是由我发起，然后推广到整个部门，规范后研发效能有了很大的提升。另外，积极借鉴外面大厂的经验，比如阿里巴巴的 Java/Android 开发规范。</p>
</li>
<li>
<p><strong>重复工作，事不过三</strong></p>
<p>重复三次以上的无脑劳动尽可能用脚本工具解决，把时间投入到更有价值的事情上，不会“偷懒”的程序员不是好程序员。比如，每次更新动态库，都要进行大量的文件替换，还有打包上传远端仓库，我写了一个 shell 脚本，把要执行的流程代码化，化繁为简。</p>
</li>
<li>
<p><strong>知其然，知其所以然</strong></p>
<p>对于被安排的工作，刨根问底清楚为什么要这么做，后面才是怎么做，不做没有思考能力的执行者。比如，产品经理曾提过在绿幕抠像功能页面加个调色板和取色器，我建议二选一，两个功能一起上一方面是增加使用的复杂度，另一方面是增加开发成本。</p>
</li>
<li>
<p><strong>技术沉淀，知识共享</strong></p>
<p>在技术研发的过程中，总会遇到很多问题，我一般会以文档的方式记录，然后分享到部门内部，避免大家再次踩坑。除此之外，我也会经常更新自己的<a href="https://isuperqiang.cn/">博客</a>，形成自己的技术方法论。持续不断地学习技术，记录学习的内容和所思所想，这或许能帮到后来者。</p>
</li>
<li>
<p><strong>热爱编程，兴趣使然</strong></p>
<p>因为热爱计算机，大学报了计算机专业，虽然中间有曲折，但最终还是走上了编程的道路。大学期间做过不少项目，从前端后端到移动端，接触过不少技术栈。可惜大方向没有把握好，忽略了职业规划，后来走了不少弯路。工作后积极提升技术能力，阅读过很多专业书籍，在这篇文章 <a href="https://isuperqiang.cn/post/tui-jian-gei-cheng-xu-yuan-de-shu-dan/">《给程序员的推荐书单》</a> 中聊过。</p>
</li>
<li>
<p><strong>沉稳干练，做事靠谱</strong></p>
<p>别人交代的事情，尽我所能，竭力完成。在入职第一年的年终总结会上，Tech Leader 对我的评价只有两个字：靠谱。我想这是对我最好的肯定，也是优秀的职业程序员应该做到的。所谓靠谱，就是凡事有交代，件件有着落，事事有回音。</p>
</li>
<li>
<p><strong>勤奋刻苦，踏实肯干</strong></p>
<p>这是骨子里的东西，我从小在农村长大，经历了不少艰难的日子，却从来不向生活低头。工作这几年，早上我是最早到公司的员工，几乎天天如此，晚上和同事一块下班。早到公司，每天就比别人多出来一个多小时，可以用来规划当天的工作、浏览技术文章等。</p>
</li>
<li>
<p><strong>没有最好，只有更好</strong></p>
<p>我承认自己有点代码洁癖，总想把代码写成诗一样。在闲暇之余，会组织代码重构，总是想把作品打磨得尽善尽美。然而，需求总是变化莫测，架构也随之不断迭代，完美的终点并不存在。其实为人也是这样，都想越来越好。</p>
</li>
</ul>
<p>这些都是我的肺腑之言，总结了职业上的行为习惯和价值观，我热爱这份职业，希望这条路走得远一些。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android SDK 开发经验谈]]></title>
        <id>https://isuperqiang.github.io/post/android-sdk-kai-fa-jing-yan-tan/</id>
        <link href="https://isuperqiang.github.io/post/android-sdk-kai-fa-jing-yan-tan/">
        </link>
        <updated>2020-12-09T07:59:35.000Z</updated>
        <content type="html"><![CDATA[<p>在公司做了两年多的 SDK 开发，结合自己的所知所学，分享一些 SDK 开发的经验。</p>
<h3 id="1-sdk-是什么">1. SDK 是什么</h3>
<p>相信做 Android 开发的朋友，一定使用过第三方的 SDK，比如推送 SDK、分享 SDK 等。SDK 的全称是 Software Development Kit，翻译为“软件开发工具包”。SDK 通常是为辅助开发某类软件而编写的特定软件包、框架集合等。</p>
<p>SDK 可以分为系统 SDK 和应用 SDK。所谓系统 SDK 是为使用特定的软件框架、硬件平台等所开发的工具集合。而应用 SDK 则是基于系统 SDK 开发的独立于具体业务、拥有特定功能的工具集合。</p>
<p>SDK 的使用者主要是 B 端客户，最终交付产品是代码、示例和文档，客户接入 SDK 也是和 SDK 提供方交流的过程，对外沟通的成本比对内更高，遇到的问题也会更多。所以 SDK 开发对开发者的要求比对应用开发更高。能开发好 SDK 一定能开发好应用，但能开发好应用，未必能开发好 SDK。</p>
<h3 id="2-sdk-实现目标">2. SDK 实现目标</h3>
<p>SDK 的实现目标，概括来说：简洁、稳定、高效。</p>
<h4 id="简洁">简洁</h4>
<p>对于用户而言，一款好的产品应该是简洁易用的，不该让他们花费太长的时间学习。SDK 也当如此，它不该出现复杂繁琐的对接工作，使用者通过阅读代码和文档，花费很少的时间就能做好 SDK 的对接。</p>
<p>比如当开发者需要使用 SDK 的服务时，只需要在代码中新增一行即可。在项目中初始化 SDK 只要一行代码，开发者不用关心 GLContext，内部已做好处理，也不用关心同步或异步问题。</p>
<pre><code class="language-java">public class FURenderer {
    // 定义    
    public static void setup(Context context) {
        //...
    }
}
// 一行代码调用
FURenderer.setup(context);
</code></pre>
<h4 id="稳定">稳定</h4>
<p>站在 SDK 使用者角度来看，我们期望第三方 SDK 的服务是稳定高效的，体现在提供稳定可靠的服务，同时运行时性能要高效。这就要求我们在设计实现 SDK 时要尽可能做到以下几点：</p>
<ul>
<li>对外提供稳定的 API。SDK 的 API 一旦确定，除非特殊情况不可更改，提供方变更 API 的成本非常大。</li>
<li>对外提供稳定的业务。在提供了稳定的 API 后，必须要有稳定的业务作为支撑。</li>
<li>运行时的稳定。确保 SDK 自身稳定运行，不能出现因为接入了 SDK 而导致宿主应用不稳定的情况。</li>
<li>版本稳定更新。SDK 版本迭代非常缓慢，要尽可能对使用者屏蔽迭代过程，避免带来不必要的适配成本。</li>
</ul>
<h4 id="高效">高效</h4>
<p>无论是普通的应用开发还是 SDK 开发，都应该考虑到性能问题，SDK 设计者要着重考虑以下问题：</p>
<ul>
<li>更少的内存占用。一般 SDK 和 App 运行在同一进程，此时 SDK 要管理好自己占用的内存，合理分配，注意释放。</li>
<li>更少的内存抖动。在占用更少内存的前提下，SDK 设计者必须减少频繁 GC 造成的内存抖动问题。</li>
<li>更少的电量消耗。低电量消耗和高性能表现之间很难做到权衡，可以从 CPU 计算量、屏幕刷新帧率等角度考量。</li>
</ul>
<h3 id="3-sdk-架构设计">3. SDK 架构设计</h3>
<p>SDK 的架构实现决定了后续的维护难度，所以最好能够结合实际业务确定合适的方案。以项目中的模块化开发为例，讲讲架构设计的原则。</p>
<p>遵循面向对象开发的几大原则，目的是达到三个目标：可维护性、可重用性和可扩展性。具体来讲：</p>
<ul>
<li>根据单一职责原则，将系统拆分为多个小模块，每个模块保持相对独立，降低实现类的复杂度。</li>
<li>根据接口隔离原则，为每个模块定义契约接口，接口的粒度要小，功能要细，越细小越易维护。</li>
<li>模块之间通过协议或接口通信，避免直接相互依赖，以降低耦合，互相了解最少，体现了迪米特法则。</li>
<li>根据开闭原则，定义各个模块的公共行为，通过模版方法设计模式提供骨架实现，易于功能扩展。</li>
<li>根据组合优于继承的原则，当多个模块功能叠加时，使用类的组合保证设计的灵活性。</li>
</ul>
<p>比如项目第三方 demo 的功能模块借鉴了 Java 集合框架的架构，分为契约接口、抽象类和具体实现三部分。</p>
<ul>
<li>首先定义 IEffectModule 作为特效的契约接口，包括创建、设置参数、销毁等各个功能模块的公共操作。</li>
<li>AbstractEffectModule 作为 IEffectModule 的骨架实现，实现了共同使用的方法，定义了公共的成员变量。</li>
<li>定义美颜 IFaceBeautyModule 接口，其继承 IEffectModule 接口，包括额外的设置参数操作，FaceBeautyModule 作为其实现类，同时继承 AbstractEffectModule，复用基类的代码。</li>
<li>美妆美体模块类似，先定义契约接口，然后定义具体实现，接口间相互隔离，接口内高度内聚。</li>
<li>FURenderer 实现 IFURenderer 渲染接口和  IModuleManager 模块管理接口，组合各个功能模块。</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20201226180356.png" alt="UML类图" loading="lazy"></figure>
<h3 id="4-sdk-设计规范">4. SDK 设计规范</h3>
<p>API 设计在任何开发中都非常重要，许多时候软件的质量好坏体现在 API 的设计上。在普通的应用开发中，API 只会在开发人员间流通，不会暴露给非本应用开发的其他人员。但是 SDK 作为一种服务，需要向开发者暴露一部分 API，这样才能使用 SDK 的服务。</p>
<p>下面列出一些应该重点关注的原则。</p>
<ol>
<li><strong>方法名表明其用途</strong></li>
</ol>
<p>好的方法名最直观表明它的功能，名字是自解释的，不需要额外的文档，这样做会减少不必要的沟通成本。对于开发者而言，还有什么比直接读代码更直观呢？《重构》一书中讲到，要像给自己孩子起名一样给每个变量命名，这个要求不算过分吧。</p>
<ol start="2">
<li><strong>参数的合法性检验</strong></li>
</ol>
<p>如果程序运行时出现异常，会破坏使用者的体验，影响非常不好。我们采用“防御式编程”的思想，能够避免非法输入对系统的破坏性。</p>
<p>当合法性校验不通过时，针对方法权限不同分别对应不同不同的处理策略:</p>
<ul>
<li>对于公开方法显式检查抛出异常，并使用 <code>@throw</code> 来说明抛出异常的原因</li>
<li>对于私有方法通过断言的方式来检查参数的合法。</li>
<li>检查构造方法的参数的合法性，以使对象处在统一状态。</li>
</ul>
<p>需要注意的是，如果检查的代价太大，那就需要综合考量。</p>
<ol start="3">
<li><strong>方法只实现单一功能</strong></li>
</ol>
<p>一个方法应该具有单一的功能，尽可能做更少、更专的事情，这也是单一职责原则的体现。“阿里巴巴代码规约”规定一个方法<br>
最好不要超过 80 行，对庞大的方法要拆分成更小的。</p>
<p>另外注意，宁可提供小而美的方法也不要提供大而全的方法，大而全的方法往往经常发生变动，产生风险的可能性更高。因此不如提供更小的方法以便组合使用，小而美的方法更易做到代码复用。</p>
<ol start="4">
<li><strong>访问权限控制</strong></li>
</ol>
<p>包括类方法的权限和变量的权限，能声明私有的不要公开，外部知道得越少越好。能声明静态的方法就用静态，静态方法天然线程安全，体现继承关系的用 <code>protected</code> 修饰，确保公开的方法和变量是安全可靠的。</p>
<ol start="5">
<li><strong>避免过长参数</strong></li>
</ol>
<p>过长的参数会造成记忆上困难，还有调用传参容易出错，应当尽力避免。在无法避免过长参数的情况下，考虑其他的方法进行解决:</p>
<ul>
<li>通过使用 Builder 模式来实现</li>
<li>通过将多个参数封装成类对象</li>
</ul>
<p>例如，项目里有个方法，参数非常多。</p>
<pre><code class="language-java">int onDrawFrameSingleInput(byte[] img, int w, int h, int format, byte[] readBackImg, int readBackW, int readBackH);
</code></pre>
<p>重构后，把参数封装成对象，调用方法只用构造一个对象传入，避免大量参数带来不好的体验感。</p>
<pre><code class="language-java">public class VideoFrame {
    private int width;
    private int height;
    private byte[] data;
    private byte[] readback;
    private int readbackWidth;
    private int readbackHeight;
    private int pixelFormat;
    // ...
}

int onDrawFrameSingleInput(VideoFrame videoFrame);
</code></pre>
<ol start="6">
<li><strong>慎用方法重载</strong></li>
</ol>
<p>滥用重载容易让开发者感到疑惑，在需要重载方法的时候，可以使用不同方法名来代替。对于构造函数，可以通过静态工厂来代替重载。</p>
<p>Java 中提供的 ObjectOutputStream 类就是个很好的示范：它的 write 对于每个基本类型都有一个变形，比如写出字符、写出 boolean 等操作。设计者并没有使用重载将其设计成 write(Long l)、write(Boolean b)，而是将其设计为 writeLong(l)、writeBoolean(b)。</p>
<p>例如，项目对外的处理方法全部是重载，只能根据参数区分，迷惑性非常大。修改为不同的方法名后，看到名字就知道要调用的方法，清楚了不少。</p>
<pre><code class="language-java">// 重构前
int onDrawFrame(byte[] img, int tex, int w, int h);
int onDrawFrame(byte[] img, int w, int h)；
// 重构后
int onDrawFrameDualInput(byte[] img, int tex, int w, int h);
int onDrawFrameSingleInput(byte[] img, int w, int h, int format);
</code></pre>
<ol start="7">
<li><strong>避免方法直接返回 null</strong></li>
</ol>
<p>对于需要返回数组或集合的方法，不要返回null。比如我们去买糕点店买面包，面包没了是一种正常状态，就不应该返回 null，而是返回长度为 0 的数组或集合。Java 提供了 <code>Collections.emptyXXX()</code> 表示空集合。</p>
<ol start="8">
<li><strong>避免引入第三方库</strong></li>
</ol>
<p>GitHub有许多开源的第三方库，比如网络请求 OkHttp、图片加载 Glide 等，但在 SDK 开发中，遵循的基本的原则是：</p>
<ul>
<li>最小可用性原则，即用最少的代码，如无必要勿增实体。</li>
<li>最少依赖性原则，即用最低限度的外部依赖，如无必要勿增依赖。</li>
</ul>
<p>引入第三方库可能带来下面几个问题：</p>
<ul>
<li>宿主应用的第三方库和 SDK 依赖的版本不一致，容易引起冲突，增加对接的成本。</li>
<li>开源库不断更新，SDK 也要及时更新，增加额外的维护工作量。</li>
<li>由于引入开源库，出现问题难以排查。</li>
</ul>
<ol start="9">
<li><strong>保证兼容性</strong></li>
</ol>
<p>SDK 是不断迭代的，每次发布都会有新功能和 bug 修复。对于使用者来说，升级版本不该有太大的改动，一般直接替换库文件或者修改远程依赖库的版本号就够了。避免直接对公开接口的重命名，如果旧接口废弃，要通过 <code>@Deprecated</code> 关键字标明，并给出替代方案和废弃的时间。</p>
<ol start="10">
<li><strong>减少入侵性</strong></li>
</ol>
<p>要保证较少的代码侵入主要在对外提供服务时，充分考虑开发者的使用场景来设计优良的 API。一套优良的 API 在定义时要满足绝大数开发者预期的方式——语义上要求通俗易懂，使用上要求简单可靠。具体的表现是，在正常情况下能够稳定可靠地运行，在异常情况下及时地反馈错误信息。</p>
<p>比如使用 Gradle 下载依赖库，AAR 包中有不必要的 bundle 资源，我们提供了打包 apk 时的构建配置，自由选择要打包的 bundle，减少了对宿主应用的侵入性。</p>
<pre><code class="language-groovy">    applicationVariants.all { variant -&gt;
        variant.mergeAssetsProvider.configure {
            doLast {
                delete(fileTree(dir: outputDir,
                        // 删除不必要的 bundle 文件
                        includes: ['model/ai_face_processor_lite.bundle',
                                   'model/ai_gesture.bundle',
                                   'graphics/controller.bundle',
                                   'graphics/tongue.bundle']))
            }
        }
    }
</code></pre>
<h3 id="5-sdk-交付">5. SDK 交付</h3>
<h4 id="封装包">封装包</h4>
<p>Android 平台通常使用 jar 和 aar 发布 SDK，区别是 jar 只包含代码，aar 可以包含代码、资源和动态库。一般而言 aar 是最合适的交付方式，把它上传到 maven 服务器，使用者就可以一行代码集成。对于需要灵活定制的客户，我们也会提供 SDK 的源码，弊端就是升级困难，要改动很多的代码。</p>
<p>对于代码混淆，公开接口和 native 使用的接口不要混，内部的实现细节可以混淆，以减少 SDK 包的大小。</p>
<h4 id="接入文档">接入文档</h4>
<p>接入文档用来告诉 SDK 使用者，如何使用 SDK、详细步使用骤和可能发生的问题。文档内容包括：更新记录、基本信息、API 说明、集成步骤、FAQ等。好文档的标准就是清晰明了，通俗易懂。一个完全不懂 SDK 的开发者看着文档就能对接，对于经常遇到的问题要逐条列出，专业名词要有对应的解释。</p>
<h4 id="demo-示例">Demo 示例</h4>
<p>集成 Demo 通常是一个简单的 App，用来展示如何快速地接入 SDK。Demo 的源码托管到 GitHub，方便使用者参考，其版本变更策略和 SDK 版本的变化保持一致。尽管是个 Demo，它的开发原则也要与 SDK 一致，确保高质量的交付。</p>
<p><strong>参考文章：</strong></p>
<ul>
<li><a href="https://lionoggo.blog.csdn.net/article/details/53558011">随想录:开发一流Android SDK</a></li>
<li><a href="https://juejin.cn/post/6844904100077764622">Android SDK开发规范整理</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/113505249">Android SDK 开发经验浅谈</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[给程序员的推荐书单]]></title>
        <id>https://isuperqiang.github.io/post/tui-jian-gei-cheng-xu-yuan-de-shu-dan/</id>
        <link href="https://isuperqiang.github.io/post/tui-jian-gei-cheng-xu-yuan-de-shu-dan/">
        </link>
        <updated>2020-10-29T16:19:40.000Z</updated>
        <content type="html"><![CDATA[<p>工作这么多年，虽然平时加班很多，但闲暇时间依然会读书。在我看来，读书并实践是成长的最有效途径。读书提升认知，实践改变行为，所谓知行合一。细细数来，读过不少的好书，有技术类的，也有非技术类的。下面推荐一些我认为值得读的好书：</p>
<h4 id="1-技术类">1. 技术类</h4>
<ul>
<li><a href="https://book.douban.com/subject/2130190/">Java 编程思想（第4版）</a> Java 的“圣经”级作品，包含编程思想和设计模式，从宏观视角讲解 Java 语言，经典之作值得反复阅读，适合进阶，入门级就不要看了。</li>
<li><a href="https://book.douban.com/subject/30412517/">Effective Java（第3版）</a>  Java 开发的规范，或者说最佳实践，实在的经验之谈，格外关注细节，重在培养优秀的编程习惯，同样值得拜读多次，同样适合进阶。</li>
<li><a href="https://book.douban.com/subject/10484692/">Java 并发编程实战</a> 深入 Java 并发的必读之作，一本完美的 Java 并发参考手册，JUC 源码的作者 Doug Lea 也是该书作者之一。</li>
<li><a href="https://book.douban.com/subject/2243615/">Head First 设计模式</a> 介绍了 GoF 提出的 23 种设计模式，配合插画和案例，读起来不觉枯燥，非常生动有趣，适合入门设计模式。</li>
<li><a href="https://book.douban.com/subject/25708312/">C++ Primer（第5版）</a>  经典的 C++ 教程，采用 C++11 标准编写，最近正在读，很厚的一本书。</li>
<li><a href="https://book.douban.com/subject/26912767/">深入理解计算机系统（第3版）</a> 简称“CSAPP”，程序员的必读书，详细描绘了计算机系统的实现细节，不懂底层的程序员称不上是合格的程序员。此书非常硬核，有些概念要反复理解。</li>
<li><a href="https://book.douban.com/subject/1477390/">代码大全（第2版）</a> 写代码不该局限于砌墙，更高远的是建设软件大厦。这本书介绍了软件构建的流程，还包括其中的细节和技巧，高屋建瓴，是提升编程认知的好书。</li>
<li><a href="https://book.douban.com/subject/4262627/">重构</a> 代码重构非常好的指导书，里面有许多非常规的观点和技巧，读完后你会发现项目里有太多坏代码等着修改，重构是为了使代码变得更好。</li>
<li><a href="https://book.douban.com/subject/30333948/">码出高效：Java 开发手册</a> 阿里大佬写的书，比较大众化，都是基础性的内容，总结了一些实战经验，打牢基础总没错。</li>
<li><a href="https://book.douban.com/subject/30358046/">Android 进阶解密</a> 和 <a href="https://book.douban.com/subject/26599538/">Android 开发艺术探索</a> 都是非常好的 Android 进阶书，知识面有深度和广度，也是高级工程师必备的技能。</li>
</ul>
<p>这里有份 <a href="https://m.douban.com/subject_collection/5185">豆瓣热门编程图书 Top10</a>，如果不知道怎么选，多读经典总是没错的。</p>
<h4 id="2-非技术">2. 非技术</h4>
<ul>
<li><a href="https://book.douban.com/subject/24868904/">高效能程序员的修炼</a> coding horror 博客中的精选文章集合，除了技术之外，还有职业规划、团队协作、高效工作环境等，软件开发远不是只写代码那么简单，程序员的软技能和硬技能一样重要。从这本书中可以读到骨灰级程序员的真知灼见。</li>
<li><a href="https://book.douban.com/subject/26835090/">软件能</a> 始于代码，不止代码。这本书介绍了程序员的发展的多个方面，职业、营销、学习、理财、健身等，读完真的是刷新认知。程序员不是呆子，我们的人生有多种可能性。</li>
<li><a href="https://book.douban.com/subject/1152111/">程序员修炼之道</a> 程序员的基本修养，包括软件编程、职业发展、工作习惯等方面。学校只会教你怎么写代码，不会教你软技能，这本书就是很好的指导。不要埋头写代码，抬头看路才能走对方向。</li>
</ul>
<p>技术类的书籍提升我们的硬技能，进而提升职业专业性。非技术类的书籍提升我们的软技能，少走弯路从而走得更远。</p>
<p>另外说一点，好书值得反复读，每读一遍都会有新的收获，愿你的职业发展越走越好。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每周 ARTS 第 33 期]]></title>
        <id>https://isuperqiang.github.io/post/mei-zhou-arts-di-33-qi/</id>
        <link href="https://isuperqiang.github.io/post/mei-zhou-arts-di-33-qi/">
        </link>
        <updated>2020-06-14T15:07:09.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-algorithm">1. Algorithm</h2>
<h4 id="路径总和-iii"><a href="https://leetcode-cn.com/problems/path-sum-iii/">路径总和 III</a>（简单）</h4>
<h4 id="描述">描述：</h4>
<blockquote>
<p>给定一个二叉树，它的每个结点都存放着一个整数值。找出路径和等于给定数值的路径总数。<br>
路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。<br>
二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。</p>
</blockquote>
<h4 id="示例">示例：</h4>
<pre><code>root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8

      10
     /  \
    5   -3
   / \    \
  3   2   11
 / \   \
3  -2   1

返回 3。和等于 8 的路径有:

1.  5 -&gt; 3
2.  5 -&gt; 2 -&gt; 1
3.  -3 -&gt; 11
</code></pre>
<h4 id="思路">思路：</h4>
<p>两次递归。pathSum 返回以当前节点为根的树中，路径和为目标值的路径总数；count 返回以当前节点为根的树中，有多少以该节点为开头，路径和为目标值的路径总数。</p>
<pre><code class="language-java">class Sulution {
    public int pathSum(TreeNode root, int sum) {
        if (root == null) {
            return 0;
        }
        return count(root, sum) + pathSum(root.left, sum) + pathSum(root.right, sum);
    }

    private int count(TreeNode root, int sum) {
        if (root == null) {
            return 0;
        }
        int count = 0;
        if (sum == root.val) {
            count += 1;
        }
        int diff = sum - root.val;
        return count + count(root.left, diff) + count(root.right, diff);
    }
}
</code></pre>
<h2 id="2-review">2. Review</h2>
<p><a href="https://medium.com/free-code-camp/the-most-important-skill-a-programmer-can-learn-9d410c786baf">The most important skill a programmer can learn</a> 程序员该学到的最重要技能</p>
<p>知道什么时候不写代码，该拒绝的需求就坚定拒绝。代码增多会带来很多问题，面对各种需求，我们不该被动接受，不合理的需求就不做。</p>
<h2 id="3-tip">3. Tip</h2>
<p>程序员不喜欢做重复的事情，写脚本成了偷懒的方法，shell 是最常用的脚本，可完成许多自动化的操作。<a href="https://wangdoc.com/bash/index.html">Bash脚本教程</a> 是不错的参考资料。</p>
<h2 id="4-share">4. Share</h2>
<p><a href="https://mp.weixin.qq.com/s/TIxWo9LMI3tFrz5612JWFw">caoz 的职场系列</a> 写得很受用，职场人可以多读读。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每周 ARTS 第 32 周]]></title>
        <id>https://isuperqiang.github.io/post/mei-zhou-arts-di-32-zhou/</id>
        <link href="https://isuperqiang.github.io/post/mei-zhou-arts-di-32-zhou/">
        </link>
        <updated>2020-06-07T15:22:45.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-algorithm">1. Algorithm</h2>
<h4 id="路径总和"><a href="https://leetcode-cn.com/problems/path-sum/">路径总和</a>（简单）</h4>
<h4 id="描述">描述：</h4>
<blockquote>
<p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。<br>
叶子节点是指没有子节点的节点。</p>
</blockquote>
<h4 id="示例">示例：</h4>
<pre><code>给定如下二叉树，以及目标和 sum = 22，
              5
             / \
            4   8
           /   / \
          11  13  4
         /  \      \
        7    2      1
</code></pre>
<h4 id="思路">思路：</h4>
<p>从根节点开始遍历，每次遍历时从目标和减去当前节点值，当作子节点要凑的和，在叶子节点判断是否刚好凑齐。</p>
<pre><code class="language-java">class Sulution {
    pbulic boolean hasPathSum(TreeNode root, int sum) {
        if (root == null) {
            return false;
        }
        if (root.left == null &amp;&amp; root.right == null) {
            return sum == root.val;
        }
        int csum = sum - root.val;
        return hasPathSum(root.left, csum) || hasPathSum(root.right, csum);
    }
}
</code></pre>
<h4 id="分析">分析：</h4>
<ul>
<li>时间复杂度：O(N)</li>
<li>空间复杂度：O(log(N)) or O(N)</li>
</ul>
<h2 id="2-review">2. Review</h2>
<p><a href="https://medium.com/mind-cafe/a-3-minute-hack-for-focus-youve-probably-never-heard-of-40708b788a0f">A 3-Minute Hack for Focus You’ve Probably Never Heard Of</a> 你从未听说过的 3 分钟聚焦大法</p>
<p>作者一直无法专注工作，同事分享了一个方法给他——双耳节拍。本质上，双耳节拍是重复播放的音乐。它没有实际的节拍，而是在大脑中产生的同时播放两个不同频率的音调。</p>
<p>我一直在用的产品叫「小睡眠」，它主要功能是助眠，但是也有聚焦和放松模式。配合降噪耳机，很快便进入高效工作中。</p>
<h2 id="3-tip">3. Tip</h2>
<p>接手维护老项目，开发者代码设计得烂，不知道怎么代码怎么调用，也无处安放 debug 点。这时只要创建一个异常，打印它的 stack track，就能够对调用时序一目了然。查看源码时也可以通过这种办法确定调用流程。</p>
<h2 id="4-share">4. Share</h2>
<p><a href="https://cyc2018.github.io/CS-Notes/#/">CS-Notes</a> GitHub 100k+ star 的项目，技术面试必备基础知识、Leetcode、计算机操作系统、计算机网络、系统设计、Java 等。</p>
<p>面试前可以刷一刷，主要是增加知识面的广度。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每周 ARTS 第 31 周]]></title>
        <id>https://isuperqiang.github.io/post/mei-zhou-arts-di-31-zhou/</id>
        <link href="https://isuperqiang.github.io/post/mei-zhou-arts-di-31-zhou/">
        </link>
        <updated>2020-05-26T23:46:49.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-algorithm">1. Algorithm</h2>
<h4 id="环形链表-ii"><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">环形链表 II</a>（中等）</h4>
<h4 id="描述">描述：</h4>
<blockquote>
<p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。<br>
为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。<br>
说明：不允许修改给定的链表。</p>
</blockquote>
<h4 id="示例">示例：</h4>
<pre><code>输入：head = [3,2,0,-4,2], pos = 1
输出：tail connects to node index 1
解释：链表中有一个环，其尾部连接到第二个节点。
</code></pre>
<h4 id="思路">思路：</h4>
<p>快慢指针：使用快慢指针从头遍历链表，如果两个指针相遇则表示链表有环。然后让慢指针从头开始，快指针继续向前，两者再次相遇点就是环的入口。这个地方用图解释更清晰，推荐阅读 <a href="https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/shuang-zhi-zhen-ji-qiao">双指针技巧总结</a>。</p>
<pre><code class="language-java">class Sulution {
    public ListNode detectCycle(ListNode head) {
       if (head == null || head.next == null) {
            return null;
        }
        ListNode fast = head;
        ListNode slow = head;
        boolean hasCycle = false;
        while (fast != null &amp;&amp; fast.next != null) {
            fast = fast.next.next;
            slow = slow.next;
            if (fast == slow) {
                hasCycle = true;
                break;
            }
        }
        if (!hasCycle) {
            return null;
        }
        slow = head;
        while (fast != slow) {
            fast = fast.next;
            slow = slow.next;
        }
        return slow;
    }
}
</code></pre>
<h4 id="分析">分析：</h4>
<ul>
<li>时间复杂度：O(N)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h2 id="2-review">2. Review</h2>
<p><a href="https://medium.com/backticks-tildes/the-s-o-l-i-d-principles-in-pictures-b34ce2f1e898">The S.O.L.I.D Principles in Pictures</a> 图画讲解 SOLID 原则</p>
<p>本文介绍了面向对象编程的 SOLID 原则，每个原则下面都有漫画说明，挺有趣的。</p>
<ul>
<li>单一职责原则：每个类应该只有一个职责，包含一组强相关的行为。</li>
<li>开闭原则：类应该对扩展开放，对修改关闭。扩展功能要增加行为而不是修改它。</li>
<li>里氏替换原则：如果 S 是 T 的子类，那么 T 出现的地方就该被 S 替换并不需要改动代码。</li>
<li>接口隔离原则：类不应该依赖不需要的行为，需要把行为拆分成更小的粒度。</li>
<li>依赖反转原则：高层模块不该依赖低层模块，他们都该依赖抽象；抽象不该依赖细节，细节该依赖抽象。</li>
</ul>
<h2 id="3-tip">3. Tip</h2>
<p>重构项目代码的过程中，遇到不美观的地方，用新技术方案完美解决。<a href="https://isuperqiang.cn/post/shi-yong-android-jia-gou-zu-jian-lifecycle-you-hua-dai-ma/">使用Android架构组件Lifecycle优化代码</a></p>
<h2 id="4-share">4. Share</h2>
<p>B站有个不错的视频 <a href="https://www.bilibili.com/video/BV1EW411u7th">计算机科学速成课</a>，从计算机历史、硬件、软件、编程等方面介绍，是计算机科学的基础知识，当作科普也不错，推荐大家看看。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用Android架构组件Lifecycle优化代码]]></title>
        <id>https://isuperqiang.github.io/post/shi-yong-android-jia-gou-zu-jian-lifecycle-you-hua-dai-ma/</id>
        <link href="https://isuperqiang.github.io/post/shi-yong-android-jia-gou-zu-jian-lifecycle-you-hua-dai-ma/">
        </link>
        <updated>2020-05-26T23:23:34.000Z</updated>
        <content type="html"><![CDATA[<p>Android developers 提供的支持库越来越完善，不知大家在开发中有没有升级 <a href="https://developer.android.com/jetpack">Jetpack</a>，也就是引入 androidX 包，Jetpack 确实简化了代码，提升了效率。下面介绍架构组件中的 Lifecycle，官网的介绍：<a href="https://developer.android.com/topic/libraries/architecture/lifecycle">使用生命周期感知型组件处理生命周期</a> 非常详细，我就介绍一下 Lifecycle 在开发中的实践。</p>
<h3 id="1-重构之前">1. 重构之前</h3>
<p>项目中有许多组件和 Activity 的生命周期有关联，比如 SensorManager 在 resume 时注册，pause 时解除注册。Camera 在 resume 时打开，pause 时关闭等。代码写起来就像下面这样：</p>
<pre><code class="language-java">    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        mSensorManager = (SensorManager) getSystemService(SENSOR_SERVICE);
        mSensor = mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);
    }   

    @Override
    protected void onResume() {
        super.onResume();
        mSensorManager.registerListener(this, mSensor, SensorManager.SENSOR_DELAY_NORMAL);
      // manage other components that need to respond
            // to the activity lifecycle
    }

    @Override
    protected void onPause() {
        super.onPause();
        mSensorManager.unregisterListener(this);
      // manage other components that need to respond
            // to the activity lifecycle
    }
</code></pre>
<p>如果需要响应 Activity 生命周期的组件非常多，那么代码将变得非常臃肿难以维护。组件对外暴露的状态接口太多，稍不留神就会出错，这种转发式的调用并不是优雅的做法。</p>
<h3 id="2-重构之后">2. 重构之后</h3>
<p>抽离 Sensor 相关代码形成新类，封装 Sensor 注册、解除注册和监听操作，最重要的是可感知生命周期。本质上是观察者设计模式，Activity 是 LifecycleOwner，具有 Lifecycle，是被观察者；LifeCycleSensorManager 实现 LifecyclerObserver 接口，是观察者。外部不需要传递生命周期状态进来，LifeCycleSensorManager 内部可感知生命周期。这样使用时，只要一行代码即可，非常干净清爽。</p>
<pre><code class="language-java">public final class LifeCycleSensorManager implements LifecycleObserver, SensorEventListener {
    private Sensor mSensor;
    private SensorManager mSensorManager;
    private Lifecycle mLifecycle;

    public LifeCycleSensorManager(final Context context, final Lifecycle lifecycle) {
        mSensorManager = (SensorManager) context.getSystemService(Context.SENSOR_SERVICE);
        mSensor = mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);
        lifecycle.addObserver(this);
        mLifecycle = lifecycle;
    }

    @OnLifecycleEvent(Lifecycle.Event.ON_RESUME)
    public void onResume() {
        mSensorManager.registerListener(this, mSensor, SensorManager.SENSOR_DELAY_NORMAL);
    }

    @OnLifecycleEvent(Lifecycle.Event.ON_PAUSE)
    public void onPause() {
        mSensorManager.unregisterListener(this);
    }

    @OnLifecycleEvent(Lifecycle.Event.ON_DESTROY)
    public void onDestroy() {
        mLifecycle.removeObserver(this);
    }

    @Override
    public void onSensorChanged(SensorEvent event) {
    }

    @Override
    public void onAccuracyChanged(Sensor sensor, int accuracy) {
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每周 ARTS 第 30 周]]></title>
        <id>https://isuperqiang.github.io/post/mei-zhou-arts-di-30-zhou/</id>
        <link href="https://isuperqiang.github.io/post/mei-zhou-arts-di-30-zhou/">
        </link>
        <updated>2020-05-19T00:10:13.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-algorithm">1. Algorithm</h2>
<h4 id="零钱兑换"><a href="https://leetcode-cn.com/problems/coin-change/">零钱兑换</a>（中等）</h4>
<h5 id="描述">描述：</h5>
<blockquote>
<p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。<br>
你可以认为每种硬币的数量是无限的。</p>
</blockquote>
<h5 id="示例">示例：</h5>
<pre><code>输入: coins = [1, 2, 5], amount = 11
输出: 3 
解释: 11 = 5 + 5 + 1
</code></pre>
<h5 id="思路">思路：</h5>
<p>动态规划：dp[i] 表示总金额为 i 时至少需要的硬币个数，初始赋值 amount+1 表示不可能取到的值。注意总金额要不小于硬币面值，而且保证总金额可以被硬币凑出来。</p>
<pre><code class="language-java">class Sulution {
    public int coinChange(int[] coins, int amount) {
        if (coins == null || coins.length == 0) {
            return -1;
        }
        int length = amount + 1;
        int[] dp = new int[length];
        Arrays.fill(dp, length);
        dp[0] = 0;
        for (int i = 0; i &lt; dp.length; i++) {
            for (int coin : coins) {
                if (i &gt;= coin) {
                    dp[i] = Math.min(dp[i], dp[i - coin] + 1);
                }
            }
        }
        return dp[amount] == length ? -1 : dp[amount];
    }
}
</code></pre>
<h5 id="分析">分析：</h5>
<ul>
<li>时间复杂度：O(N * k)，k 为硬币个数</li>
<li>空间复杂度：O(N)</li>
</ul>
<h2 id="2-review">2. Review</h2>
<p><a href="https://medium.com/@magnus.chatt/why-you-should-totally-switch-to-kotlin-c7bbde9e10d5">Why you should totally switch to Kotlin</a> 为什么你该完全切换到 Kotlin</p>
<p>介绍了 Kotlin 的特性，与 Java 互操作、类型推断、空安全、数据类等，Kotlin 是现代化的语言，其特性会令开发者喜欢。</p>
<h2 id="3-tip">3. Tip</h2>
<p>遇到 crash 如何解决呢？分享一下我的经验。</p>
<p>首先查看 stack trace，找到报错的类型、信息、代码文件和行数，常见的异常有 NullPointerException、ClassCastException、IndexOutOfBoundException 等，根据信息就大概可以知道报错原因。如果之前没见过这种异常，把信息复制粘贴到谷歌搜索，排名靠前的搜索结果都来自 Stack Overflow，说不定前人也碰到了类似的错误，从问题回复中就能找到答案，这就要求英文阅读能力要过关。最后如果实在搜不到，那只能请教大佬了。</p>
<h2 id="4-share">4. Share</h2>
<p>分享两个网站，收录了 Windows 和 Mac 平台上的优质软件。</p>
<ul>
<li><a href="https://github.com/Awesome-Windows/Awesome/blob/master/README-cn.md">Awesome-Windows</a></li>
<li><a href="https://github.com/jaywcjlove/awesome-mac/blob/master/README-zh.md">Awesome-Mac</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每周 ARTS 第 29 周]]></title>
        <id>https://isuperqiang.github.io/post/mei-zhou-arts-di-29-zhou/</id>
        <link href="https://isuperqiang.github.io/post/mei-zhou-arts-di-29-zhou/">
        </link>
        <updated>2020-05-12T13:19:24.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-algorithm">1. Algorithm</h2>
<h4 id="颠倒二进制位"><a href="https://leetcode-cn.com/problems/reverse-bits/">颠倒二进制位</a>（简单）</h4>
<h5 id="描述">描述：</h5>
<blockquote>
<p>颠倒给定的 32 位无符号整数的二进制位。</p>
</blockquote>
<h5 id="示例">示例：</h5>
<pre><code>输入: 00000010100101000001111010011100
输出: 00111001011110000010100101000000
解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，
因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。
</code></pre>
<h5 id="思路">思路：</h5>
<ul>
<li>逐位颠倒：从右向左遍历二进制串，用 n&amp;1 取得最右一位，然后左移该值到对应位置，和结果值求和，退出条件是 n == 0。</li>
</ul>
<pre><code class="language-java">class Sulution {
    // you need treat n as an unsigned value
    public int reverseBits(int n) {
        int ret = 0;
        for (int bitsSize = 31; n != 0; bitsSize--) {
            ret += (n &amp; 1) &lt;&lt; bitsSize;
            n = n &gt;&gt;&gt; 1;
        }
        return ret;
    }
}
</code></pre>
<h5 id="分析">分析：</h5>
<ul>
<li>时间复杂度：O(1)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h2 id="2-review">2. Review</h2>
<p><a href="https://medium.com/free-code-camp/the-code-im-still-ashamed-of-e4c021dff55e">The code I’m still ashamed of</a> 至今令我惭愧的代码</p>
<p>作者回忆了刚开始工作时为医药公司做网站，先让用户做测验然后推荐药物，目标是年轻女性。在庆功聚会前，作者看到一条新闻，一名服用药物的女子自杀了，由药物的副作用导致。回家后发现自己的妹妹也在用这种药，作者马上就制止了她。不久后作者便离职了，自此每次写代码前都要三思代码带来的影响。</p>
<blockquote>
<p>作为开发人员，我们通常是防范潜在危险和不道德行为的最后一道防线。</p>
</blockquote>
<h2 id="3-tip">3. Tip</h2>
<p>最近重构了部分项目代码，对此有些感悟。在重构的过程中，对业务会有更深的理解，编程就是把现实世界抽象成代码结构。同时看到以前代码的糟糕之处，毫不犹豫地删掉重写，目的就是提升可读性、可用性和可维护性。</p>
<p>《重构，改善既有代码的设计》这本书值得每位程序员阅读。任何一个傻瓜都能写出计算机可以理解的代码，唯有写出人类可以理解的代码，才是优秀的程序员。</p>
<h2 id="4-share">4. Share</h2>
<p>最近在看极客时间上《许式伟的架构课》，讲到操作系统很棒，特地分享出来。 <a href="https://time.geekbang.org/column/article/4b4426d9ac4cb25d7f82325a893b494f/share?code=w%2Fj%2F7UNTJpAHk25ddhtU5iTaKNYvSTs5a5gk-p9iOJs%3D">操作系统进场</a></p>
<p><strong>精华部分：</strong></p>
<p>从客户需求来说，操作系统的核心价值在于：</p>
<ul>
<li>
<p>实现软件治理，让多个软件和谐共处；</p>
</li>
<li>
<p>提供基础的编程接口，降低软件开发难度。</p>
</li>
</ul>
<p>从商业价值来说，操作系统是刚性需求，核心的流量入口，兵家必争之地。所以，围绕它的核心能力，操作系统必然会不断演化出新的形态。早期预装软件是一种流量变现的方式。后来苹果引入了 “账号 - 支付 - 应用市场” 商业闭环的收税模式。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每周 ARTS 第 28 周]]></title>
        <id>https://isuperqiang.github.io/post/mei-zhou-arts-di-28-zhou/</id>
        <link href="https://isuperqiang.github.io/post/mei-zhou-arts-di-28-zhou/">
        </link>
        <updated>2020-05-03T09:48:29.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-algorithm">1. Algorithm</h2>
<h4 id="旋转数组"><a href="https://leetcode-cn.com/problems/rotate-array/">旋转数组</a>（简单）</h4>
<h5 id="描述">描述：</h5>
<blockquote>
<p>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。<br>
尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。<br>
要求使用空间复杂度为 O(1) 的原地算法。</p>
</blockquote>
<h5 id="示例">示例：</h5>
<pre><code>输入: [1,2,3,4,5,6,7] 和 k = 3
输出: [5,6,7,1,2,3,4]
</code></pre>
<h5 id="思路">思路：</h5>
<ul>
<li>暴力解法：循环 K 次，每次移动一个元素。时间复杂度：O(k*N)，空间复杂度：O(1)。</li>
</ul>
<pre><code class="language-java">class Sulution {
    public void rotate(int[] nums, int k) {
        if (nums == null || nums.length == 0) {
            return;
        }
        int length = nums.length;
        int temp;
        for (int i = 0; i &lt; k; i++) {
            temp = nums[length - 1];
            for (int j = length - 1; j &gt; 0; j--) {
                nums[j] = nums[j - 1];
            }
            nums[0] = temp;
        }
    }
}
</code></pre>
<ul>
<li>额外空间：使用额外数组保存旋转后的元素，把原数组下标是 i 的元素放到临时数组 (i+k)%nums.length 的位置，然后写回原数组。时间复杂度：O(N)，空间复杂度：O(N)。</li>
</ul>
<pre><code class="language-java">class Sulution {
    public void rotate(int[] nums, int k) {
        if (nums == null || nums.length == 0) {
            return;
        }
        int[] temp = new int[nums.length];
        for (int i = 0; i &lt; nums.length; i++) {
            temp[(i + k) % nums.length] = nums[i];
        }
        System.arraycopy(temp, 0, nums, 0, nums.length);
    }
}
</code></pre>
<ul>
<li>环状替换：计算每个元素的最终位置，每次迭代时替换到正确位置并保存被替换的值，计算被替换值的正确位置。以 K 为步长跳跃，如果跳跃回原地，就从下一个位置继续。时间复杂度：O(N)，空间复杂度：O(1)。</li>
</ul>
<pre><code class="language-java">class Sulution {
    public void rotate(int[] nums, int k) {
        if (nums == null || nums.length == 0) {
            return;
        }
        k = k % nums.length;
        int count = 0;
        for (int start = 0; count &lt; nums.length; start++) {
            int currentI = start;
            int currentE = nums[start];
            do {
                int nextI = (currentI + k) % nums.length;
                int temp = nums[nextI];
                nums[nextI] = currentE;
                currentE = temp;
                currentI = nextI;
                count++;
            } while (start != currentI);
        }
    }
}
</code></pre>
<ul>
<li>三次反转：当我们旋转数组 k 次， k%n 个尾部元素会被移动到头部，剩下的元素会被向后移动。时间复杂度：O(N)，空间复杂度：O(1)。</li>
</ul>
<pre><code class="language-java">class Sulution {
  // 原始数组                  : 1 2 3 4 5 6 7
  // 反转所有数字后             : 7 6 5 4 3 2 1
  // 反转前 k 个数字后          : 5 6 7 4 3 2 1
  // 反转后 n-k 个数字后        : 5 6 7 1 2 3 4 --&gt; 结果
    public void rotate(int[] nums, int k) {
        if (nums == null || nums.length == 0) {
            return;
        }
        k = k % nums.length;
        reverse(nums, 0, nums.length - 1);
        reverse(nums, 0, k - 1);
        reverse(nums, k, nums.length - 1);
    }
    
    private void reverse(int[] arr, int start, int end) {
        while (start &lt; end) {
            int temp = arr[start];
            arr[start] = arr[end];
            arr[end] = temp;
            start++;
            end--;
        }
    }
}
</code></pre>
<h2 id="2-review">2. Review</h2>
<p><a href="https://levelup.gitconnected.com/programming-habits-you-should-adopt-8ab75419fb09">Programming Habits You Should Adopt</a> 你应该养成的编程习惯</p>
<p>作者列举了 7 个编程习惯：</p>
<ul>
<li>不要写重复代码。遇到重复代码，就该考虑重构了。</li>
<li>一旦认为自己完成了，开始重构吧。实现需求并不代表完成，接下来就该重构。</li>
<li>聚焦业务逻辑。不要总是专注于业务之外的技术栈，做好工作内容更重要。</li>
<li>短小精简的提交。便于回滚排查问题和代码审查。</li>
<li>一致性很关键。坚持标准的代码规范，提升代码的可维护性。</li>
<li>多做一步。完成任务意味着解决 todo，单元测试，编写文档。</li>
<li>不要停止学习。一直做自己熟练的事情，是不会得到成长的。</li>
</ul>
<h2 id="3-tip">3. Tip</h2>
<p>近期看了 Kotlin 语言，感觉是增强型的 Java，简洁灵活安全省心。同样基于 JVM，弥补 Java 的不足，编程语言总是在进化，Google 力推 Kotlin 作为 Android 开发语言是正确的。建议新项目尝试 Kotlin，老项目继续用 Java，两者还可以混编。Have a try 😃</p>
<h2 id="4-share">4. Share</h2>
<p>在 Twitter 上看到陈皓发的推文，从程序员职业发展的角度评论编程语言，有生命力、有市场需求的语言值得投入。原帖在这里：https://twitter.com/haoel/status/1254974994964086785</p>
<figure data-type="image" tabindex="1"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/EWqQTnKU4AES4-K.png" alt="有生命力语言的特征" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/EWqQRcGUcAAKt6z.png" alt="陈皓评论语言" loading="lazy"></figure>
]]></content>
    </entry>
</feed>