<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://isuperqiang.cn</id>
    <title>落英坠露</title>
    <updated>2020-04-25T11:15:35.860Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://isuperqiang.cn"/>
    <link rel="self" href="https://isuperqiang.cn/atom.xml"/>
    <subtitle>生活不止眼前的苟且，还有诗和远方的田野。</subtitle>
    <logo>https://isuperqiang.cn/images/avatar.png</logo>
    <icon>https://isuperqiang.cn/favicon.ico</icon>
    <rights>All rights reserved 2020, 落英坠露</rights>
    <entry>
        <title type="html"><![CDATA[每周 ARTS 第 27 期]]></title>
        <id>https://isuperqiang.cn/post/mei-zhou-arts-di-27-qi/</id>
        <link href="https://isuperqiang.cn/post/mei-zhou-arts-di-27-qi/">
        </link>
        <updated>2020-04-25T11:15:04.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-algorithm">1. Algorithm</h2>
<h4 id="搜索二维矩阵-ii"><a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/">搜索二维矩阵 II</a>（中等）</h4>
<h5 id="描述">描述：</h5>
<blockquote>
<p>编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性：<br>
每行的元素从左到右升序排列。<br>
每列的元素从上到下升序排列。</p>
</blockquote>
<h5 id="示例">示例：</h5>
<pre><code>现有矩阵 matrix 如下：
[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]
给定 target = 5，返回 true。
给定 target = 20，返回 false。
</code></pre>
<h5 id="思路">思路：</h5>
<p>从左下角出发，把 target 和当前值比较。如果 target 大于当前值，就往右走；如果小于，就往上走。如果等于，就返回 true。</p>
<pre><code class="language-java">class Sulution {
    public boolean searchMatrix(int[][] matrix, int target) {
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
            return false;
        }
        int row = matrix.length - 1;
        int column = 0;
        int columnLength = matrix[0].length;
        while (row &gt;= 0 &amp;&amp; column &lt; columnLength) {
            if (matrix[row][column] &gt; target) {
                row--;
            } else if (matrix[row][column] &lt; target) {
                column++;
            } else {
                return true;
            }
        }
        return false;
    }
}
</code></pre>
<h5 id="分析">分析：</h5>
<ul>
<li>时间复杂度：O(M+N)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h2 id="2-review">2. Review</h2>
<p><a href="https://medium.com/@alexewerlof/my-guiding-principles-after-20-years-of-programming-a087dc55596c">My guiding principles after 20 years of programming</a>  <a href="https://www.infoq.cn/article/VEgR7xkNIYUsSWP9Ohc3">20 年老程序员告诉你的 20 条编码原则</a></p>
<p>软件开发的历史没多久，20年经验的程序员也比较稀缺。作者总结了编程的经验和原则，对刚入门不久的新人有很大启发。比如第一条不要纠结于开发工具，不管是库、编程语言或平台。总是有人争吵什么是最好的语言，其实抛开具体业务场景谈是没有意义的。</p>
<h2 id="3-tip">3. Tip</h2>
<p>断点调试是排查问题的好方法，其效率比打印 log 要高。不管是 Native 库还是 Java 库，都可以用断点调试，一步步执行代码，查看变量值和函数跳转。</p>
<h2 id="4-share">4. Share</h2>
<p><strong>为什么需要软件架构?</strong></p>
<p>早在 1986 年的时候，人月神话的作者在讨论软件的复杂性时，谈到：软件的本质复杂性存在于复杂的业务需求中。</p>
<p>而管理复杂性，最根本的手段就是职责分离。为了实现职责分离，代码重用，架构慢慢地复现出来。架构的本质是管理复杂性。</p>
<p>没有架构，我们所有的代码都耦合在一起，人类的心智模型不擅长处理这种复杂性，架构的设立，和图书馆的图书分类，公司的组织划分等，本质都是一样的。是为了管理复杂性，以取得更高的生产力。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每周 ARTS 第 26 期]]></title>
        <id>https://isuperqiang.cn/post/mei-zhou-arts-di-26-qi/</id>
        <link href="https://isuperqiang.cn/post/mei-zhou-arts-di-26-qi/">
        </link>
        <updated>2020-04-19T14:02:16.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-algorithm">1. Algorithm</h2>
<h4 id="判定字符是否唯一"><a href="https://leetcode-cn.com/problems/is-unique-lcci/">判定字符是否唯一</a>（简单）</h4>
<h5 id="描述">描述：</h5>
<blockquote>
<p>实现一个算法，确定一个字符串 s 的所有字符是否全都不同。</p>
</blockquote>
<h5 id="示例">示例：</h5>
<pre><code>输入: s = &quot;leetcode&quot;
输出: false 
输入: s = &quot;abc&quot;
输出: true
</code></pre>
<h5 id="思路">思路：</h5>
<ul>
<li>统计次数：使用一个额外的 int 数组，统计每个字符出现的次数。</li>
<li>位运算：int 类型有 32 位，取其中的低 26 位，作为每个字符的标志位，通过左移、与、或运算，记录每个字符的对应位置。真是高级解法！</li>
</ul>
<pre><code class="language-java">class Sulution {
    public boolean isUnique1(String astr) {
        if (astr == null || astr.length() == 0) {
            return true;
        }
        int[] counts = new int[26];
        for (int i = 0, length = astr.length(); i &lt; length; i++) {
            int pos = astr.charAt(i) - 'a';
            if (counts[pos] &gt;= 1) {
                return false;
            }
            counts[pos] += 1;
        }
        return true;
    }

    public boolean isUnique2(String astr) {
        if (astr == null || astr.length() == 0) {
            return true;
        }
        int mark = 0;
        for (int i = 0, length = astr.length(); i &lt; length; i++) {
            int flag = 1 &lt;&lt; (astr.charAt(i) - 'a');
            if ((mark &amp; flag) != 0) {
                return false;
            } else {
                mark |= flag;
            }
        }
        return true;
    }
}
</code></pre>
<h5 id="分析">分析：</h5>
<p>统计次数：</p>
<ul>
<li>时间复杂度：O(N)</li>
<li>空间复杂度：O(N)</li>
</ul>
<p>位运算：</p>
<ul>
<li>时间复杂度：O(N)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h2 id="2-review">2. Review</h2>
<p><a href="https://levelup.gitconnected.com/how-to-go-from-junior-to-senior-programmer-29d53f3edd27">How to Go from Junior to Senior Programmer</a>  <a href="https://www.infoq.cn/article/6gagslvv3x5oQLpaVpv8">如何从初级程序员变成高级程序员？</a></p>
<p>从 InfoQ 看到的一篇译文，算是经验之谈。高工不是根据经验判定，而是分析的技能。深有同感，我总是把代码放在第一位，有时候忽略了业务场景，考虑问题的出发点不同，导致任务处理方式也不同。代码只是一部分，真正的目的是解决问题。</p>
<blockquote>
<p>一名程序员不会因为他会写代码而成为一名合格的程序员，而是因为在开始做任何事情之前先做分析，然后再来开展工作，这才是真正的程序员。</p>
</blockquote>
<h2 id="3-tip">3. Tip</h2>
<p>最近某 BAT 之一坑害了 pandownload，真的是令人发指！自己的产品做得烂不去反思，却耍小伎俩坑无辜的开发者。天下苦 B 久矣，作为程序员，从抵制 B 开始。推荐一个好用的木弟子 <a href="https://neoproxy.org/?rc=r1gv64bl">AgentNeo</a>，线路非常稳定，价格也实惠。通过我的链接注册，可以享受 5 元优惠 https://neoproxy.org/?rc=r1gv64bl。（结算时选择团购下单，团购代码 21853G0V，享受 8 折优惠，活动截止 2020-04-25）</p>
<h2 id="4-share">4. Share</h2>
<p>在 GitHub 上搜了一些 Android 面试资料 http://note.youdao.com/noteshare?id=a04ac812925b23f6dc112eda70079c53 愿步步高升。</p>
<p><strong>题外话：</strong></p>
<p>由于个人原因，ARTS 暂停了将近半年，后续恢复打卡，请见谅。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[深入理解计算机系统之并发编程（二）]]></title>
        <id>https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-bing-fa-bian-cheng-er/</id>
        <link href="https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-bing-fa-bian-cheng-er/">
        </link>
        <updated>2020-01-16T13:10:44.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1-多线程程序中的共享变量">1. 多线程程序中的共享变量</h3>
<p>一组并发线程运行在一个进程的上下文中。每个线程都有自己独立的线程上下文，包括线程 ID、栈、<br>
栈指针、程序计数器、条件码和通用目的寄存器值。每个线程和其他线程共享进程上下文的剩余部分，<br>
包括用户虚拟地址空间，它是由只读文本（代码）、读/写数据、堆以及共享库代码和<br>
数据区组成的。线程也共享相同的打开文件的集合。</p>
<p>寄存器是从不共享的，虚拟内存总是共享的。</p>
<p>多线程的 C 程序中的变量根据它们的存储类型被影射到虚拟内存：</p>
<ul>
<li>全局变量：定义在函数之外的变量，虚拟内存中只有一个实例，任何线程都能引用。</li>
<li>本地自动变量：定义在函数内但没有 static 属性的变量，每个线程都有自己的实例。</li>
<li>本地静态变量：定义在函数内并有 static 属性的变量，和全部变量一样。</li>
</ul>
<p>多线程实现计数器，每个线程对共享变量操作，容易出现同步错误。</p>
<p>进度图将 n 个并发线程的执行，模型化为一条 n 维笛卡尔空间中的轨迹线。每条轴 k 对应<br>
线程 k 的进度，每个点代表线程 k 已经完成指令的状态。</p>
<p>每个线程在执行临界区（critical section）的指令时，拥有对共享变量的互斥（mutual exclusion）访问。<br>
在进度图中，两个临界区的交集形成的状态空间称为不安全区，绕开不安全区的轨迹线叫做安全轨迹线。</p>
<p>任何安全轨迹线都会正确地更新共享变量，为了保证线程化程序的正确执行，我们必须以某种方式同步线程。</p>
<figure data-type="image" tabindex="1"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20191227085650.png" alt="安全和不安全轨迹线" loading="lazy"></figure>
<h3 id="2-使用信号量同步线程">2. 使用信号量同步线程</h3>
<p>一种经典的解决线程同步问题的方法：信号量（semephore）。它是具有非负整数的全局变量，只能由两种特殊的操作处理，成为 P 和 V。P 和 V 来源于荷兰语，分别表示测试和增加。</p>
<p>P 中的测试和减一操作是不可分割的，V 中的加一操作也是不可分割的。当多个线程等待同一个信号量时，<br>
无法预测 V 操作也重启哪个线程。</p>
<p>使用信号量可以确保对共享变量的互斥访问。基本思想是将每个共享变量与一个信号量 s （初始为 1）关联起来，<br>
然后用 P(s) 和 V(s) 操作将相应的临界区包围起来。这种保护共享变量的信号量称为二元信号量，<br>
以提供互斥为目的的二元信号量称为互斥锁。</p>
<p>除了提供互斥外，信号量的另一个重要作用是调度对共享资源的访问。比如生产者-消费者问题，读者-写者问题。</p>
<h3 id="3-使用线程提高并行性">3. 使用线程提高并行性</h3>
<p>所有程序的集合被划分为不相交的顺序程序集合和并发程序的结合，并行程序是一种运行在多个处理器上的并发程序。</p>
<p>来看一个用多线程对整数序列求和的问题，将序列划分为多个不相交的区域，给每个线程分配一个区域。</p>
<ul>
<li>第一种做法，将每个线程求得的和放入共享的全局变量中，用互斥锁保护这个变量。结果性能非常差，同步操作的代价太大。</li>
<li>第二种做法，定义一个全局数组，每个对等线程把和累积在数组的不同位置。同时，使用局部变量消除不必要的内存引用。最终性能提升明显。</li>
</ul>
<p>同步开销巨大，要尽可能避免。如果无可避免，必须要用尽可能多的有用计算弥补这个开销。</p>
<p>随着线程数量的增加，程序运行时间不会一直减少，由于线程上下文切换的开销。</p>
<h3 id="4-其他并发问题">4. 其他并发问题</h3>
<p>可重入(reentrant)函数：当被多个线程调用时，不会引用任何共享数据。比不可重入的线程安全的函数高效一些，因为它不需要同步操作。</p>
<p>避免死锁(deadlock)：给定所有互斥操作的一个全序，如果每个线程都以一种顺序获得互斥锁并以相反的顺序<br>
释放，那么这个程序就是无死锁的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[libyuv 库编译]]></title>
        <id>https://isuperqiang.cn/post/libyuv-ku-bian-yi/</id>
        <link href="https://isuperqiang.cn/post/libyuv-ku-bian-yi/">
        </link>
        <updated>2020-01-04T12:17:26.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://chromium.googlesource.com/libyuv/libyuv">libyuv</a> 是谷歌开源的对 YUV 数据进行缩放、旋转和转换的跨平台库，可在 Windows、Linux、Mac、Android 等操作系统，x86、x64、arm 架构上进行编译运行，支持 AVX2、NEON 等 SIMD 指令加速。</p>
<p>官方介绍的几个功能：</p>
<ul>
<li>可以使用 point，bilinear 或 box 三种方法进行 YUV 的压缩</li>
<li>可以转换为 RGB 来实现渲染/特效</li>
<li>旋转 90/180/270 的角度以适配设备的竖屏模式</li>
<li>可以把 webcam 转换为 YUV 来进行压缩</li>
<li>还有一系列的平台性能优化等</li>
</ul>
<p>接下来让我们编译 libyuv，编译步骤在 Windows 和 Mac 上都验证成功，下面以 Mac 为例。</p>
<h3 id="1-clone-libyuv-源码">1. clone libyuv 源码</h3>
<p>既然要编译库，怎么少得了源码呢？</p>
<pre><code>git clone https://chromium.googlesource.com/libyuv/libyuv
</code></pre>
<h3 id="2-重命名文件夹">2. 重命名文件夹</h3>
<p>clone 的文件夹叫做 libyuv，这里要把它修改为 jni。</p>
<h3 id="3-修改-androidmk">3. 修改 Android.mk</h3>
<p>注释 jpeg 相关的代码，其他地方不用改动。</p>
<figure data-type="image" tabindex="1"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/clipboard2.png" alt="fix-jpeg1" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/clipboard3.png" alt="fix-jpeg2" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/clipboard.png" alt="fix-jpeg3" loading="lazy"></figure>
<p>下面是修改后的 Android.mk 文件内容：</p>
<pre><code># This is the Android makefile for libyuv for NDK.
LOCAL_PATH:= $(call my-dir)

include $(CLEAR_VARS)

LOCAL_CPP_EXTENSION := .cc

LOCAL_SRC_FILES := \
    source/compare.cc           \
    source/compare_common.cc    \
    source/compare_gcc.cc       \
    source/compare_mmi.cc       \
    source/compare_msa.cc       \
    source/compare_neon.cc      \
    source/compare_neon64.cc    \
    source/convert.cc           \
    source/convert_argb.cc      \
    source/convert_from.cc      \
    source/convert_from_argb.cc \
    source/convert_to_argb.cc   \
    source/convert_to_i420.cc   \
    source/cpu_id.cc            \
    source/planar_functions.cc  \
    source/rotate.cc            \
    source/rotate_any.cc        \
    source/rotate_argb.cc       \
    source/rotate_common.cc     \
    source/rotate_gcc.cc        \
    source/rotate_mmi.cc        \
    source/rotate_msa.cc        \
    source/rotate_neon.cc       \
    source/rotate_neon64.cc     \
    source/row_any.cc           \
    source/row_common.cc        \
    source/row_gcc.cc           \
    source/row_mmi.cc           \
    source/row_msa.cc           \
    source/row_neon.cc          \
    source/row_neon64.cc        \
    source/scale.cc             \
    source/scale_any.cc         \
    source/scale_argb.cc        \
    source/scale_common.cc      \
    source/scale_gcc.cc         \
    source/scale_mmi.cc         \
    source/scale_msa.cc         \
    source/scale_neon.cc        \
    source/scale_neon64.cc      \
    source/video_common.cc

common_CFLAGS := -Wall -fexceptions
# ifneq ($(LIBYUV_DISABLE_JPEG), &quot;yes&quot;)
# LOCAL_SRC_FILES += \
#     source/convert_jpeg.cc      \
#     source/mjpeg_decoder.cc     \
#     source/mjpeg_validate.cc
# common_CFLAGS += -DHAVE_JPEG
# LOCAL_SHARED_LIBRARIES := libjpeg
# endif

LOCAL_CFLAGS += $(common_CFLAGS)
LOCAL_EXPORT_C_INCLUDES := $(LOCAL_PATH)/include
LOCAL_C_INCLUDES += $(LOCAL_PATH)/include
LOCAL_EXPORT_C_INCLUDE_DIRS := $(LOCAL_PATH)/include

LOCAL_MODULE := libyuv_static
LOCAL_MODULE_TAGS := optional

include $(BUILD_STATIC_LIBRARY)

include $(CLEAR_VARS)

LOCAL_WHOLE_STATIC_LIBRARIES := libyuv_static
# 生成库的名称
LOCAL_MODULE := libyuv
# ifneq ($(LIBYUV_DISABLE_JPEG), &quot;yes&quot;)
# LOCAL_SHARED_LIBRARIES := libjpeg
# endif

# 生成静态库还是动态库
# BUILD_STATIC_LIBRSRY 静态库
# BUILD_SHARED_LIBRARY 动态库
include $(BUILD_SHARED_LIBRARY)

include $(CLEAR_VARS)
LOCAL_STATIC_LIBRARIES := libyuv_static
# LOCAL_SHARED_LIBRARIES := libjpeg
LOCAL_MODULE_TAGS := tests
LOCAL_CPP_EXTENSION := .cc
LOCAL_C_INCLUDES += $(LOCAL_PATH)/include
LOCAL_SRC_FILES := \
    unit_test/unit_test.cc        \
    unit_test/basictypes_test.cc  \
    unit_test/color_test.cc       \
    unit_test/compare_test.cc     \
    unit_test/convert_test.cc     \
    unit_test/cpu_test.cc         \
    unit_test/cpu_thread_test.cc  \
    unit_test/math_test.cc        \
    unit_test/planar_test.cc      \
    unit_test/rotate_argb_test.cc \
    unit_test/rotate_test.cc      \
    unit_test/scale_argb_test.cc  \
    unit_test/scale_test.cc       \
    unit_test/video_common_test.cc

LOCAL_MODULE := libyuv_unittest
include $(BUILD_NATIVE_TEST)
</code></pre>
<h3 id="4-新建-applicationmk">4. 新建 Application.mk</h3>
<p>在 jni 文件夹下，新建 Application.mk 文件，指定架构平台和 Android 版本，内容如下：</p>
<pre><code>APP_ABI := armeabi-v7a arm64-v8a x86 x86_64
APP_PLATFORM := android-18
</code></pre>
<h3 id="5-ndk-build-编译">5. ndk-build 编译</h3>
<p>编译前要确保本机配置好了 NDK 环境变量，如果不知道怎么做请自行百度。</p>
<p>cd 到 jni 文件夹的父级文件夹，然后执行 ndk 相关的命令。每次编译前都要先执行 <code>ndk-build clean</code> 清理缓存，最后执行 <code>ndk-build</code> 编译库，在 jni 父文件夹下就会出现两个文件夹： libs 文件夹下是动态库，obj 文件夹下是静态库。</p>
<figure data-type="image" tabindex="4"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20200104200940.png" alt="ndk-build" loading="lazy"></figure>
<p><strong>参考文章：</strong></p>
<ul>
<li><a href="https://yangandmore.github.io/2019/03/07/libYUV%E7%BC%96%E8%AF%91/">libYUV编译</a></li>
<li><a href="https://github.com/byhook/ffmpeg4android/blob/master/readme/android%E5%85%A8%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91libyuv%E5%BA%93%E5%AE%9E%E7%8E%B0YUV%E5%92%8CRGB%E7%9A%84%E8%BD%AC%E6%8D%A2.md">android全平台编译libyuv库实现YUV和RGB的转换</a></li>
<li><a href="http://www.raomengyang.com/2017/01/15/Android-libyuv%E5%BA%94%E7%94%A8%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89libyuv%E7%9A%84%E4%BD%BF%E7%94%A8/">Android libyuv应用系列（二）libyuv的使用</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[哈希算法及其应用]]></title>
        <id>https://isuperqiang.cn/post/ha-xi-suan-fa-ji-qi-ying-yong/</id>
        <link href="https://isuperqiang.cn/post/ha-xi-suan-fa-ji-qi-ying-yong/">
        </link>
        <updated>2019-12-27T14:29:54.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1-什么是哈希算法">1. 什么是哈希算法？</h3>
<p>将任意长度的二进制值串映射为固定长度的二进制值串，这个映射的规则就是哈希算法，而通过原始数据映射之后得到的二进制值串就是哈希值。</p>
<p>哈希算法历史悠久，业界著名的哈希算法也有很多，比如 MD5、SHA 等。在我们平时的开发中，基本上都是拿现成的直接用。</p>
<p>怎样算是优秀的哈希算法？</p>
<ul>
<li>从哈希值不能反向推导出原始数据（所以哈希算法也叫单向哈希算法）；</li>
<li>对输入数据非常敏感，哪怕原始数据只修改了一个 Bit，最后得到的哈希值也大不相同；</li>
<li>散列冲突的概率要很小，对于不同的原始数据，哈希值相同的概率非常小；</li>
<li>哈希算法的执行效率要尽量高效，针对较长的文本，也能快速地计算出哈希值。</li>
</ul>
<p>哈希算法的应用非常非常多，包括安全加密、唯一标识、数据校验、散列函数、负载均衡、数据分片、分布式存储等。</p>
<h3 id="2-应用一安全加密">2. 应用一：安全加密</h3>
<p>常用的加密哈希算法：</p>
<ul>
<li>MD5（MD5 Message-Digest Algorithm，MD5 消息摘要算法）</li>
<li>SHA（Secure Hash Algorithm，安全散列算法）</li>
<li>DES（Data Encryption Standard，数据加密标准）</li>
<li>AES（Advanced Encryption Standard，高级加密标准）</li>
</ul>
<p>对用于加密的哈希算法来说，有两点格外重要。第一点是很难根据哈希值反向推导出原始数据，第二点是散列冲突的概率要很小。</p>
<p>基于鸽巢原理，哈希算法无法避免散列冲突。一般情况下，哈希值越长的哈希算法，散列冲突的概率越低。即便哈希算法存在散列冲突的情况，但是因为哈希值的范围很大，冲突的概率极低，所以相对来说还是很难破解的。</p>
<p>越是复杂哈希算法越难破解，但同样计算时间也就越长。所以，选择哈希算法的时候，要权衡安全性和计算时间来决定用哪种哈希算法。</p>
<h3 id="3-应用二唯一标识">3. 应用二：唯一标识</h3>
<p>给每张图片取一个唯一标识，或者说信息摘要，就可以从海量图库中快速搜索一张图片。</p>
<p>哈希算法可以对大数据做信息摘要，通过一个较短的二进制编码来表示很大的数据。</p>
<h3 id="4-应用三数据校验">4. 应用三：数据校验</h3>
<p>BT 下载的文件经过哈希算法校验，用于校验数据的完整性和正确性。</p>
<h3 id="5-应用四散列函数">5. 应用四：散列函数</h3>
<p>散列函数对哈希算法的要求非常特别，更加看重的是散列的平均性和哈希算法的执行效率。</p>
<h3 id="6-应用五负载均衡">6. 应用五：负载均衡</h3>
<p>利用哈希算法替代映射表，可以实现一个会话粘滞的负载均衡策略。</p>
<p>我们可以通过哈希算法，对客户端 IP 地址或者会话 ID 计算哈希值，将取得的哈希值与服务器列表的大小进行取模运算，最终得到的值就是应该被路由到的服务器编号。 这样就可以把同一个 IP 过来的所有请求，都路由到同一个后端服务器上。</p>
<h3 id="7-应用六数据分片">7. 应用六：数据分片</h3>
<p>通过哈希算法对处理的海量数据进行分片，多机分布式处理，可以突破单机资源的限制。</p>
<ol>
<li>如何统计“搜索关键词”出现的次数？</li>
</ol>
<p>可以先对数据进行分片，然后采用多台机器处理的方法，来提高处理速度。具体的思路是这样的：为了提高处理的速度，我们用 n 台机器并行处理。从搜索记录的日志文件中，依次读出每个搜索关键词，并且通过哈希函数计算哈希值，然后再跟 n 取模，最终得到的值，就是应该被分配到的机器编号。</p>
<ol start="2">
<li>如何快速判断图片是否在图库中？</li>
</ol>
<p>通过同样的哈希算法，计算这个图片的唯一标识，然后与机器个数 n 求余取模。假设得到的值是 k，那就去编号 k 的机器构建的散列表中查找。</p>
<h3 id="8-分布式存储">8. 分布式存储</h3>
<p>利用一致性哈希算法，可以解决缓存等分布式系统的扩容、缩容导致数据大量搬移的难题。</p>
<p>假设我们有 k 个机器，数据的哈希值的范围是 [0, MAX]。我们将整个范围划分成 m 个小区间（m 远大于 k），每个机器负责 m/k 个小区间。当有新机器加入的时候，我们就将某几个小区间的数据，从原来的机器中搬移到新的机器中。这样，既不用全部重新哈希、搬移数据，也保持了各个机器上数据数量的均衡。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[深入理解计算机系统之并发编程（一）]]></title>
        <id>https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-bing-fa-bian-cheng-yi/</id>
        <link href="https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-bing-fa-bian-cheng-yi/">
        </link>
        <updated>2019-12-15T14:46:37.000Z</updated>
        <content type="html"><![CDATA[<p>并发不仅是操作系统内核用来运行多个应用程序的机制，还可以在应用程序中扮演重要角色。</p>
<p>现代操作系统提供三种基本的构造并发程序的方法：</p>
<ul>
<li>进程</li>
<li>I/O 多路复用</li>
<li>线程</li>
</ul>
<h3 id="1-基于进程的并发编程">1. 基于进程的并发编程</h3>
<p>每个逻辑控制流都是一个进程，由内核来调度和维护。进程有独立的虚拟地址空间，想要和其他流通信，必须使用某种显式的进程间通信（IPC）机制。我们可以使用熟悉的函数，像 fork、exec 和 waitpid 来构造进程。</p>
<p>对于在父、子进程间共享状态信息，进程有个非常清晰的模型：共享文件表，但是不共享用户地址空间。独立的地址空间确保一个进程不会覆盖另一个进程的虚拟内存，消除了许多令人迷惑的错误。同时也使得进程共享状态信息更加困难，为了共享信息，必须使用显示的 IPC 机制，但是进程控制和 IPC 的开销很高。</p>
<h3 id="2-基于-io-多路复用的并发编程">2. 基于 I/O 多路复用的并发编程</h3>
<p>I/O 多路复用（multiplexing）技术，基本思路就是使用 select 函数，要求内核挂起进程，只有在一个或者多个<br>
I/O 事件发生后，才将控制返回给应用程序。select 是个复杂的函数，有许多不同的使用场景。</p>
<p>在事件驱动程序中，某些事件会驱动、导致流的推进。而I/O 多路复用可以作为事件驱动程序的基础。在事件驱动程序中，逻辑流被模型化为状态机，一个状态机就是一组状态、输入事件、转移。<br>
当一个输入事件发生，状态机发生转移，变化为另一个状态。</p>
<p>服务器使用 I/O 多路复用技术，借助 select 函数检测输入事件的发生。当每个已连接描述符准备好可读时，服务器就为相应的状态机执行转移。</p>
<p>事件驱动设计的优点是，它比基于进程的设计具有更多对程序行为的控制。另一个优点是，每个逻辑流<br>
都能访问该进程的全部地址空间，这使得在流之间共享数据变得容易。</p>
<p>事件驱动设计的缺点是，编码复杂，不能充分利用多核处理器。</p>
<h3 id="3-基于线程的并发编程">3. 基于线程的并发编程</h3>
<p>线程就是运行在进程上下文中的逻辑流。每个线程都有自己的线程上下文，包括一个唯一的整数线程 ID、栈、栈指针、程序计数器、通用目的寄存器和条件码。所有运行在一个进程内的线程共享该进程的整个虚拟地址空间。</p>
<p>同进程一样，线程由内核自动调度，并且内核通过一个整数 ID 来识别线程。同基于 I/O 多路复用的流一样，多个线程运行在单一进程的上下文中，因此共享这个进程虚拟地址空间的所有内容，包括它的代码、数据、堆、共享库和打开的文件。</p>
<figure data-type="image" tabindex="1"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20191225065818.png" alt="并发线程执行" loading="lazy"></figure>
<p>每个进程开始生命周期都是单线程，这个线程称为主线程（main thread）。在某一时刻，主线程创建一个对等线程（peer thread），从这个时间点开始，两个线程并发地运行。最后主线程执行一个慢速系统调用，比如 read 或 sleep，或者被系统的间隔计时器中断，控制就会通过上下文切换传递到对等线程。对等线程会执行一段时间，然后控制传递回主线程，依次类推。</p>
<p>线程和进程的不同之处有：</p>
<ul>
<li>线程的上下文比进程的上下文小得多，所以线程的上下文切换要比进程的上下文切换快得多。</li>
<li>线程不像进程那样，不是按照严格的父子层次组织的，和一个进程相关的线程组成一个对等线程（池）。</li>
</ul>
<p>对等线程（池）的主要影响是，一个线程可以杀死它的任何对等线程，或者等待它的任意对等线程终止。每个对等线程都能读写相同的共享数据。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[深入理解计算机系统之网络编程（二）]]></title>
        <id>https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-wang-luo-bian-cheng-er/</id>
        <link href="https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-wang-luo-bian-cheng-er/">
        </link>
        <updated>2019-12-06T00:35:33.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1-套接字接口">1. 套接字接口</h3>
<p>套接字接口是一组函数，它们和 Unix I/O 函数结合，用来创建网络应用。</p>
<figure data-type="image" tabindex="1"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20191210084427.png" alt="基于套接字接口的网络应用" loading="lazy"></figure>
<p>从 Linux 内核的角度看，套接字就是通信的端点；从 Linux 程序的角度看，套接字就是有相应描述符的打开文件。</p>
<h3 id="2-web-服务器">2. Web 服务器</h3>
<p>Web 客户端和服务器之间的交互通过基于文本的 HTTP 协议。浏览器打开一个网络连接，向服务器请求某些内容。服务器响应所请求的内容，然后关闭连接。浏览器读取这些内容，并把它显示在屏幕上。</p>
<p>Web 内容是一个与 MIME 类型相关的字节序列，比如 text/html、image/jpeg 等。<br>
Web 服务器通过两种方式向客户端提供内容：</p>
<ul>
<li>取一个磁盘文件，并将它的内容返回客户端，称为静态内容。</li>
<li>运行一个可执行文件，并将它的输出返回客户端，称为动态内容。</li>
</ul>
<p>Http 请求（GET 方法）的组成是这样的：一个请求行，后面跟随多个请求报头，再跟随一个空文本行来终止报头。<br>
请求行的格式是：method URI version。请求报头的格式为：header-name: header-data。</p>
<pre><code>GET / HTTP/1.1
Host: www.qq.com

</code></pre>
<p>Http 响应的组成是这样的：一个响应行，后面跟随多个响应报头，再跟随一个终止报头的空文本行，最后跟随响应主体。<br>
响应行的格式是：version status-code status-message。</p>
<pre><code>HTTP/1.0 200 OK
MIME-Version: 1.0
Date: Jan, 11 Dec 2019 12:00:00
Server: Apache-Coyote/1.1
Content-Type: text/html
Content-Length: 42090

&lt;html&gt;
...
&lt;/html&gt;
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20191211081627.png" alt="Http事务" loading="lazy"></figure>
<p>GET 请求的参数在 URI 中。用 <code>？</code> 分隔文件名和参数，每个参数用 <code>&amp;</code> 分隔，参数不允许有空格。POST 请求的参数在请求主体中。</p>
<p>服务器程序遵守 CGI（通用网关接口）标准，CGI 可以管理客户端如何将参数传递给服务器，服务器如何将参数和其他信息传递给子进程，以及子进程如何将它的输出返回客户端。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[深入理解计算机系统之网络编程（一）]]></title>
        <id>https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-wang-luo-bian-cheng-yi/</id>
        <link href="https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-wang-luo-bian-cheng-yi/">
        </link>
        <updated>2019-11-29T00:20:28.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1-客户端-服务端编程模型">1. 客户端-服务端编程模型</h3>
<p>每个网络应用都是基于客户端-服务器模型。一个应用是由一个服务器进程和一个或者多个客户端进程组成。服务器管理某种资源，并且通过这种资源来为它的客户端提供某种服务。客户端和服务器是进程，而不是常提到的机器或者主机。</p>
<p>客户端-服务器模型中的基本操作是事务。这个事务不是数据库事务，没有数据库事务的任何特性，它仅仅是客户端和服务器执行的一系列步骤。</p>
<figure data-type="image" tabindex="1"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20191209080352.png" alt="客户端-服务器事务" loading="lazy"></figure>
<h3 id="2-网络">2. 网络</h3>
<p>对主机而言，网路只是另一种 I/O 设备，是数据源和数据接收方。</p>
<p>网路是一个按照地理远近组成的层次系统，最低层是局域网（LAN），最流行的局域网技术是以太网。</p>
<p>网络协议消除了不同网络之间的差异，使主机和路由器协同工作来实现数据传输，封装是数据传输的关键。</p>
<h3 id="3-全球-ip-因特网">3. 全球 IP 因特网</h3>
<p>客户端-服务器应用的组织一直保持相当的稳定。每台主机都运行实现 TCP/IP 的软件，几乎每个现代<br>
计算机都支持这个协议。客户端和服务器混合使用套接字接口函数和 Unix I/O 函数进行通信。</p>
<p>一个 IP 地址就是一个 32 位无符号整数，使用点分十进制表示法表示。为了方便人们记忆，定义了域名以及将域名映射到 IP 地址的机制。</p>
<p>套接字是连接的端点，套接字地址是由互联网地址和 16 位的整数端口组成的，用「地址：端口」来表示。当客户端发起一个请求时，<br>
客户端套接字地址中的端口是由内核自动分配的，称为临时端口。服务器套接字地址端口通常是某个知名端口，和 这个服务相对应。</p>
<figure data-type="image" tabindex="2"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20191210081750.png" alt="互联网连接分析" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[深入理解计算机系统之系统级IO]]></title>
        <id>https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-xi-tong-ji-io/</id>
        <link href="https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-xi-tong-ji-io/">
        </link>
        <updated>2019-11-24T13:00:15.000Z</updated>
        <content type="html"><![CDATA[<p>输入/输出(I/O) 是在主存和外部设备之间复制数据的过程。输入操作是从 I/O 设备复制到主存，输出操作是从主存复制到 I/O 设备。</p>
<h3 id="1-unix-io">1. Unix I/O</h3>
<p>一个 Linux 文件就是一个 m 个字节的序列。所有的 I/O 设备都被模型化为文件，所有的输入和输出都被当作相应文件的读和写来执行。这种将设备优雅地映射为文件的方式，允许 Linux 内核引出一个简单、低级的应用接口，称为 Unix I/O。</p>
<h3 id="2-文件">2. 文件</h3>
<p>每个 Linux 文件都有一个类型来表明它在系统中的角色：</p>
<ul>
<li>普通文件包含任意数据。</li>
<li>目录是包含一组链接的文件。</li>
<li>套接字是用来与另一个进程进行跨网络通信的文件。</li>
</ul>
<p>Linux 内核将所有文件都组织称一个目录层次结构，由名为 / 的根目录确定。</p>
<figure data-type="image" tabindex="1"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20191124201916.png" alt="Linux 目录层次结构" loading="lazy"></figure>
<p>作为其上下文的一部分，每个进程都有一个当前工作目录，来确定其在目录层次结构中的当前位置。</p>
<h3 id="3-用-rio-包健壮地读写">3. 用 RIO 包健壮地读写</h3>
<p>应用程序不该直接使用 Unix I/O 函数，而应该使用 RIO 包。RIO 包提供了两类不同的函数：无缓冲的输出输出函数和有缓冲的输入函数。RIO 包通过反复执行读写操作，直到传送完所有的请求数据，自动处理不足值。</p>
<h3 id="4-io-重定向">4. I/O 重定向</h3>
<p>Linux shell 提供了 I/O 重定向操作符，允许用户将磁盘文件和标准输入输出联系起来。例如：</p>
<p><code>linux&gt; ls &gt; foo.txt</code>。</p>
<h3 id="5-该使用哪些-io-函数">5. 该使用哪些 I/O 函数</h3>
<p>标准 I/O 库是基于 Unix I/O 实现的，并提供了一组强大的高级 I/O 例程。对于大多数应用程序而言，标准 I/O 更简单，是优于 Unix I/O 的选择。然而，因为 Unix I/O 和网络文件之间有些相互不兼容的限制，Unix I/O 更适合用于网络应用程序。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[深入理解计算机系统之虚拟内存（二）]]></title>
        <id>https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-xu-ni-nei-cun-er/</id>
        <link href="https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-xu-ni-nei-cun-er/">
        </link>
        <updated>2019-11-22T01:14:46.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1-内存映射">1. 内存映射</h3>
<p>Linux 通过将虚拟内存区域与磁盘上的对象关联起来，来初始化这个虚拟内存区域的内容，这个过程称为内存映射。虚拟内存区域可以映射到两种类型的对象中的一种：</p>
<ul>
<li>Linux 文件系统中的普通文件：磁盘文件的连续部分。</li>
<li>匿名文件：由内核创建，包含的都是二进制零。</li>
</ul>
<p>一旦虚拟页面被初始化，它就在由内核维护的交换空间之间换来换去。在任何时刻，交换空间都限制当前运行的进程能够分配的虚拟页面的总数。</p>
<p>一个对象可以被映射到虚拟内存的一个区域，要么作为共享对象，要么作为私有对象。进程对共享对象映射到的虚拟地址空间的写操作，对把该共享对象映射到它们虚拟内存区域的其他进程也是可见的，并且这些变化反映在磁盘上的对象中。另一方面，对于映射到私有对象的区域的改变，对其他进程来说是不可见的，并且不会反映在磁盘上的对象中。</p>
<p>许多进程有同样的只读代码区域，内存映射可以控制多个进程如何共享对象。即使对象被映射到多个共享区域，物理内存中只需要存放共享对象的一个副本。</p>
<p>私有对象使用写时复制（copy-on-write）的技术被映射到虚拟内存中。和共享对象一样，在物理内存中只保存私有对象的一个副本。当一个进程试图写私有区域内的某个页面时，写操作就会触发一个保护故障。故障处理程序会在物理内存中创建这个页面的新副本，更新页表条目指向新副本，恢复这个页面的写权限。当故障处理程序返回时，CPU 就可以正常执行写操作了。</p>
<h3 id="2-动态内存分配">2. 动态内存分配</h3>
<p>当运行时需要额外虚拟内存时，用动态内存分配器更方便，也有更好的可移植性。</p>
<p>动态内存分配器维护着一个进程的虚拟内存区域，称为堆。分配器将堆视为一组不同大小的块的集合来维护。每个块就是一个连续的虚拟内存片，要么是已分配的，要么是空闲的。</p>
<p>分配器有两种基本风格，两种风格都要求应用显式地分配块，它们的不同之处在于由哪个实体负责释放已分配的块。</p>
<ul>
<li>显式分配器要求应用显式地释放任何已分配的块。例如 C 通过调用 malloc 和 free 分配和释放块。</li>
<li>隐时分配器会自动释放不再使用的已分配的块。例如 Java 的垃圾回收。</li>
</ul>
<p>造成堆利用率很低的主要原因是碎片的现象，当有未使用的内存但不能用来满足分配请求时，就发生这种现象。分配器通常采用试图维持少量的大空闲块，而不是维持大量的小空闲块。</p>
]]></content>
    </entry>
</feed>