<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://isuperqiang.cn</id>
    <title>落英坠露</title>
    <updated>2019-12-22T14:49:43.342Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://isuperqiang.cn"/>
    <link rel="self" href="https://isuperqiang.cn/atom.xml"/>
    <subtitle>生活不止眼前的苟且，还有诗和远方的田野。</subtitle>
    <logo>https://isuperqiang.cn/images/avatar.png</logo>
    <icon>https://isuperqiang.cn/favicon.ico</icon>
    <rights>All rights reserved 2019, 落英坠露</rights>
    <entry>
        <title type="html"><![CDATA[深入理解计算机系统之并发编程（一）]]></title>
        <id>https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-bing-fa-bian-cheng-yi</id>
        <link href="https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-bing-fa-bian-cheng-yi">
        </link>
        <updated>2019-12-15T14:46:37.000Z</updated>
        <content type="html"><![CDATA[<p>并发不仅是操作系统内核用来运行多个应用程序的机制，还可以在应用程序中扮演重要角色。</p>
<p>现代操作系统提供三种基本的构造并发程序的方法：</p>
<ul>
<li>进程</li>
<li>I/O 多路复用</li>
<li>线程</li>
</ul>
<h3 id="1-基于进程的并发编程">1. 基于进程的并发编程</h3>
<p>每个逻辑控制流都是一个进程，由内核来调度和维护。进程有独立的虚拟地址空间，想要和其他流通信，必须使用某种显式的进程间通信（IPC）机制。</p>
<p>使用熟悉的函数，像 fork、exec 和 waitpid 来构造进程。</p>
<p>对于在父、子进程间共享状态信息，进程有个非常清晰的模型：共享文件表，但是不共享用户地址空间。独立的地址空间确保一个进程不会覆盖另一个进程的虚拟内存，消除了许多令人迷惑的错误。同时也使得进程共享状态信息更加困难，为了共享信息，必须使用显示的 IPC 机制，但是进程控制和 IPC 的开销很高。</p>
<h3 id="2-基于-io-多路复用的并发编程">2. 基于 I/O 多路复用的并发编程</h3>
<p>I/O 多路复用（multiplexing）技术，基本思路就是使用 select 函数，要求内核挂起进程，只有在一个或者多个 I/O 事件发生后，才将控制返回给应用程序。</p>
<p>在事件驱动程序中，一些事件会驱动、导致流的推进。而I/O多路复用可以作为事件驱动程序的基础。在事件驱动程序中，逻辑流被模型化为状态机，一个状态机就是一组状态、输入事件、转移。<br>
当一个输入事件发生，状态机发生转移，变化为另一个状态。</p>
<h3 id="3-基于线程的并发编程">3. 基于线程的并发编程</h3>
<p>线程就是运行在进程上下文中的逻辑流。每个线程都有自己的线程上下文，包括一个唯一的整数线程ID、栈、栈指针、程序计数器、通用目的寄存器和条形码。所有运行在一个进程里的线程共享该进程的整个虚拟地址空间。</p>
<p>同进程一样，线程由内核自动调度，并且内核通过一个整数ID来识别线程。同基于I/O多路复用的流一样，多个线程运行在单一进程的上下文中，共享这个进程虚拟地址空间的所有内容，包括它的代码、数据、堆、共享库和打开的文件</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[深入理解计算机系统之网络编程（二）]]></title>
        <id>https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-wang-luo-bian-cheng-er</id>
        <link href="https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-wang-luo-bian-cheng-er">
        </link>
        <updated>2019-12-06T00:35:33.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1-套接字接口">1. 套接字接口</h3>
<p>套接字接口是一组函数，它们和 Unix I/O 函数结合，用来创建网络应用。</p>
<figure data-type="image" tabindex="1"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20191210084427.png" alt="基于套接字接口的网络应用"></figure>
<p>从 Linux 内核的角度看，套接字就是通信的端点；从 Linux 程序的角度看，套接字就是有相应描述符的打开文件。</p>
<h3 id="2-web-服务器">2. Web 服务器</h3>
<p>Web 客户端和服务器之间的交互通过基于文本的 HTTP 协议。浏览器打开一个网络连接，向服务器请求某些内容。服务器响应所请求的内容，然后关闭连接。浏览器读取这些内容，并把它显示在屏幕上。</p>
<p>Web 内容是一个与 MIME 类型相关的字节序列，比如 text/html、image/jpeg 等。<br>
Web 服务器通过两种方式向客户端提供内容：</p>
<ul>
<li>取一个磁盘文件，并将它的内容返回客户端，称为静态内容。</li>
<li>运行一个可执行文件，并将它的输出返回客户端，称为动态内容。</li>
</ul>
<p>Http 请求（GET 方法）的组成是这样的：一个请求行，后面跟随多个请求报头，再跟随一个空文本行来终止报头。<br>
请求行的格式是：method URI version。请求报头的格式为：header-name: header-data。</p>
<pre><code>GET / HTTP/1.1
Host: www.qq.com

</code></pre>
<p>Http 响应的组成是这样的：一个响应行，后面跟随多个响应报头，再跟随一个终止报头的空文本行，最后跟随响应主体。<br>
响应行的格式是：version status-code status-message。</p>
<pre><code>HTTP/1.0 200 OK
MIME-Version: 1.0
Date: Jan, 11 Dec 2019 12:00:00
Server: Apache-Coyote/1.1
Content-Type: text/html
Content-Length: 42090

&lt;html&gt;
...
&lt;/html&gt;
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20191211081627.png" alt="Http事务"></figure>
<p>GET 请求的参数在 URI 中。用 <code>？</code> 分隔文件名和参数，每个参数用 <code>&amp;</code> 分隔，参数不允许有空格。POST 请求的参数在请求主体中。</p>
<p>服务器程序遵守 CGI（通用网关接口）标准，CGI 可以管理客户端如何将参数传递给服务器，服务器如何将参数和其他信息传递给子进程，以及子进程如何将它的输出返回客户端。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[深入理解计算机系统之网络编程（一）]]></title>
        <id>https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-wang-luo-bian-cheng-yi</id>
        <link href="https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-wang-luo-bian-cheng-yi">
        </link>
        <updated>2019-11-29T00:20:28.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1-客户端-服务端编程模型">1. 客户端-服务端编程模型</h3>
<p>每个网络应用都是基于客户端-服务器模型。一个应用是由一个服务器进程和一个或者多个客户端进程组成。服务器管理某种资源，并且通过这种资源来为它的客户端提供某种服务。客户端和服务器是进程，而不是常提到的机器或者主机。</p>
<p>客户端-服务器模型中的基本操作是事务。这个事务不是数据库事务，没有数据库事务的任何特性，它仅仅是客户端和服务器执行的一系列步骤。</p>
<figure data-type="image" tabindex="1"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20191209080352.png" alt="客户端-服务器事务"></figure>
<h3 id="2-网络">2. 网络</h3>
<p>对主机而言，网路只是另一种 I/O 设备，是数据源和数据接收方。</p>
<p>网路是一个按照地理远近组成的层次系统，最低层是局域网（LAN），最流行的局域网技术是以太网。</p>
<p>网络协议消除了不同网络之间的差异，使主机和路由器协同工作来实现数据传输，封装是数据传输的关键。</p>
<h3 id="3-全球-ip-因特网">3. 全球 IP 因特网</h3>
<p>客户端-服务器应用的组织一直保持相当的稳定。每台主机都运行实现 TCP/IP 的软件，几乎每个现代<br>
计算机都支持这个协议。客户端和服务器混合使用套接字接口函数和 Unix I/O 函数进行通信。</p>
<p>一个 IP 地址就是一个 32 位无符号整数，使用点分十进制表示法表示。为了方便人们记忆，定义了域名以及将域名映射到 IP 地址的机制。</p>
<p>套接字是连接的端点，套接字地址是由互联网地址和 16 位的整数端口组成的，用「地址：端口」来表示。当客户端发起一个请求时，<br>
客户端套接字地址中的端口是由内核自动分配的，称为临时端口。服务器套接字地址端口通常是某个知名端口，和 这个服务相对应。</p>
<figure data-type="image" tabindex="2"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20191210081750.png" alt="互联网连接分析"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[深入理解计算机系统之系统级IO]]></title>
        <id>https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-xi-tong-ji-io</id>
        <link href="https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-xi-tong-ji-io">
        </link>
        <updated>2019-11-24T13:00:15.000Z</updated>
        <content type="html"><![CDATA[<p>输入/输出(I/O) 是在主存和外部设备之间复制数据的过程。输入操作是从 I/O 设备复制到主存，输出操作是从主存复制到 I/O 设备。</p>
<h3 id="1-unix-io">1. Unix I/O</h3>
<p>一个 Linux 文件就是一个 m 个字节的序列。所有的 I/O 设备都被模型化为文件，所有的输入和输出都被当作相应文件的读和写来执行。这种将设备优雅地映射为文件的方式，允许 Linux 内核引出一个简单、低级的应用接口，称为 Unix I/O。</p>
<h3 id="2-文件">2. 文件</h3>
<p>每个 Linux 文件都有一个类型来表明它在系统中的角色：</p>
<ul>
<li>普通文件包含任意数据。</li>
<li>目录是包含一组链接的文件。</li>
<li>套接字是用来与另一个进程进行跨网络通信的文件。</li>
</ul>
<p>Linux 内核将所有文件都组织称一个目录层次结构，由名为 / 的根目录确定。</p>
<figure data-type="image" tabindex="1"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20191124201916.png" alt="Linux 目录层次结构"></figure>
<p>作为其上下文的一部分，每个进程都有一个当前工作目录，来确定其在目录层次结构中的当前位置。</p>
<h3 id="3-用-rio-包健壮地读写">3. 用 RIO 包健壮地读写</h3>
<p>应用程序不该直接使用 Unix I/O 函数，而应该使用 RIO 包。RIO 包提供了两类不同的函数：无缓冲的输出输出函数和有缓冲的输入函数。RIO 包通过反复执行读写操作，直到传送完所有的请求数据，自动处理不足值。</p>
<h3 id="4-io-重定向">4. I/O 重定向</h3>
<p>Linux shell 提供了 I/O 重定向操作符，允许用户将磁盘文件和标准输入输出联系起来。例如：</p>
<p><code>linux&gt; ls &gt; foo.txt</code>。</p>
<h3 id="5-该使用哪些-io-函数">5. 该使用哪些 I/O 函数</h3>
<p>标准 I/O 库是基于 Unix I/O 实现的，并提供了一组强大的高级 I/O 例程。对于大多数应用程序而言，标准 I/O 更简单，是优于 Unix I/O 的选择。然而，因为 Unix I/O 和网络文件之间有些相互不兼容的限制，Unix I/O 更适合用于网络应用程序。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[深入理解计算机系统之虚拟内存（二）]]></title>
        <id>https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-xu-ni-nei-cun-er</id>
        <link href="https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-xu-ni-nei-cun-er">
        </link>
        <updated>2019-11-22T01:14:46.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1-内存映射">1. 内存映射</h3>
<p>Linux 通过将虚拟内存区域与磁盘上的对象关联起来，来初始化这个虚拟内存区域的内容，这个过程称为内存映射。虚拟内存区域可以映射到两种类型的对象中的一种：</p>
<ul>
<li>Linux 文件系统中的普通文件：磁盘文件的连续部分。</li>
<li>匿名文件：由内核创建，包含的都是二进制零。</li>
</ul>
<p>一旦虚拟页面被初始化，它就在由内核维护的交换空间之间换来换去。在任何时刻，交换空间都限制当前运行的进程能够分配的虚拟页面的总数。</p>
<p>一个对象可以被映射到虚拟内存的一个区域，要么作为共享对象，要么作为私有对象。进程对共享对象映射到的虚拟地址空间的写操作，对把该共享对象映射到它们虚拟内存区域的其他进程也是可见的，并且这些变化反映在磁盘上的对象中。另一方面，对于映射到私有对象的区域的改变，对其他进程来说是不可见的，并且不会反映在磁盘上的对象中。</p>
<p>许多进程有同样的只读代码区域，内存映射可以控制多个进程如何共享对象。即使对象被映射到多个共享区域，物理内存中只需要存放共享对象的一个副本。</p>
<p>私有对象使用写时复制（copy-on-write）的技术被映射到虚拟内存中。和共享对象一样，在物理内存中只保存私有对象的一个副本。当一个进程试图写私有区域内的某个页面时，写操作就会触发一个保护故障。故障处理程序会在物理内存中创建这个页面的新副本，更新页表条目指向新副本，恢复这个页面的写权限。当故障处理程序返回时，CPU 就可以正常执行写操作了。</p>
<h3 id="2-动态内存分配">2. 动态内存分配</h3>
<p>当运行时需要额外虚拟内存时，用动态内存分配器更方便，也有更好的可移植性。</p>
<p>动态内存分配器维护着一个进程的虚拟内存区域，称为堆。分配器将堆视为一组不同大小的块的集合来维护。每个块就是一个连续的虚拟内存片，要么是已分配的，要么是空闲的。</p>
<p>分配器有两种基本风格，两种风格都要求应用显式地分配块，它们的不同之处在于由哪个实体负责释放已分配的块。</p>
<ul>
<li>显式分配器要求应用显式地释放任何已分配的块。例如 C 通过调用 malloc 和 free 分配和释放块。</li>
<li>隐时分配器会自动释放不再使用的已分配的块。例如 Java 的垃圾回收。</li>
</ul>
<p>造成堆利用率很低的主要原因是碎片的现象，当有未使用的内存但不能用来满足分配请求时，就发生这种现象。分配器通常采用试图维持少量的大空闲块，而不是维持大量的小空闲块。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[深入理解计算机系统之虚拟内存（一）]]></title>
        <id>https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-xu-ni-nei-cun-yi</id>
        <link href="https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-xu-ni-nei-cun-yi">
        </link>
        <updated>2019-11-08T14:40:47.000Z</updated>
        <content type="html"><![CDATA[<p>为了更加有效地管理内存并减少出错，现代系统提供了虚拟内存（VM）的概念，它为每个进程提供了一个庞大、一致和私有的地址空间。</p>
<p>虚拟内存提供了三个重要能力：</p>
<ul>
<li>把主存看成一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据</li>
<li>为每个进程提供一致的地址空间，从而简化了内存管理</li>
<li>保护每个进程的地址空间不被其他进程破坏</li>
</ul>
<h3 id="1-物理和虚拟寻址">1. 物理和虚拟寻址</h3>
<p>早起的 PC 使用物理寻址，现代处理器使用虚拟寻址。虚拟寻址的方式需要内存管理单元（MMU）将虚拟地址转换为物理地址。</p>
<figure data-type="image" tabindex="1"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20191106085329.png" alt="物理寻址"></figure>
<figure data-type="image" tabindex="2"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20191106085354.png" alt="虚拟寻址"></figure>
<h3 id="2-地址空间">2. 地址空间</h3>
<p>地址空间是一个非负整数地址的有序集合。如果地址空间中的整数是连续的，那么它就是线性地址空间。</p>
<p>在带有虚拟内存的系统中，CPU 从含有 N=2^n 个地址的地址空间中生成虚拟地址，称为虚拟地址空间。</p>
<p>系统还有一个物理地址空间，对应物理内存的 M 个字节。</p>
<p>地址空间清楚地区分了数据对象（字节）和它们的属性（地址）。允许每个对象有多个独立的地址，其中每个地址都选自不同的地址空间，这就是虚拟内存的基本思想。主存中的每个字节都有一个来自虚拟地址空间的虚拟地址和来自物理地址空间的物理地址。</p>
<h3 id="3-虚拟内存作为缓存的工具">3. 虚拟内存作为缓存的工具</h3>
<p>虚拟内存被组织为一个由存放在磁盘上的 N 个连续的字节大小的单元组成的数组。每个字节都有一个唯一的虚拟地址，作为到数组的索引。磁盘上数组的内容被缓存在主存中。</p>
<p>虚拟内存被分割为称作虚拟页（VP）的大小固定块，来作为磁盘和主存之间的传输单元。类似地，物理内存被分割为物理页。在任意时刻，虚拟页面的集合都分为三个不相交的子集：未分配的、缓存的、未缓存的。</p>
<p>页表（page table）将虚拟页映射到物理页。每次 MMU（内存管理单元）中的地址翻译硬件将虚拟地址转换为物理地址时，都会读取页表。<br>
操作系统负责维护页表的内容，以及在磁盘与 DRAM 之间来回传送页。</p>
<figure data-type="image" tabindex="3"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20191115220042.png" alt="页表"></figure>
<p>页表就是一个页表条目（PTE）的数组。虚拟地址空间中的每个页在页表中一个固定偏移量处都有一个 PTE。</p>
<p>DRAM 缓存不命中称为缺页（page fault）。缺页会触发缺页异常，该异常调用缺页异常处理程序，该程序会选择一个牺牲页，<br>
内核总会修改牺牲页的页表条目，牺牲页就不再缓存在主存中。当异常处理程序返回时，它会重新启动导致缺页的指令，<br>
该指令会把导致缺页的虚拟地址发送到地址翻译硬件，页命中就能由地址翻译硬件正常处理了。</p>
<p>在磁盘和内存之间传送页的活动叫做交换（swapping）或者页面调度（paging）。页从磁盘换入 DRAM 和 从 DRAM 换出磁盘。<br>
当有不命中发生时才换入页面的策略叫做按需页面调度（demand paging）。所有现在操作系统都是用按需页面调度的方式。</p>
<p>尽管在整个运行过程中程序引用的不同页面的总数可能超出物理内存总的大小，但是局部性原理保证了在任意时刻，<br>
程序将趋于在一个较小的活动页面（active page）集合上工作，这个集合叫做工作集合。</p>
<p>如果工作集的大小超出了物理内存的大小，那么程序将产生一种不幸的状态，叫做抖动（thrashing），这时页面将不断地换进换出。</p>
<h3 id="4-虚拟内存作为内存管理的工具">4. 虚拟内存作为内存管理的工具</h3>
<p>实际上，操作系统为每个进程提供了一个独立的页表，也就是一个独立的虚拟地址空间。注意，多个虚拟页面可以映射到同一个共享的物理页面上。</p>
<figure data-type="image" tabindex="4"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20191115221725.png" alt="内存管理"></figure>
<h3 id="5-虚拟存在作为内存保护的工具">5. 虚拟存在作为内存保护的工具</h3>
<p>提供独立的地址空间使得区分不同进程的私有内存变得容易。地址翻译机制可以通过一种自然的方式扩展到提供更好的访问控制。CPU 每次生成一个地址时，地址翻译硬件都会读一个 PTE。所以可以通过在 PTE 上添加一些额外的许可位来控制一个虚拟页面内容的访问。</p>
<figure data-type="image" tabindex="5"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20191115222808.png" alt="内存保护"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[深入理解计算机系统之异常控制流（二）]]></title>
        <id>https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-yi-chang-kong-zhi-liu-er</id>
        <link href="https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-yi-chang-kong-zhi-liu-er">
        </link>
        <updated>2019-11-03T09:30:36.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1-进程控制">1. 进程控制</h3>
<p>每个进程都有一个唯一的正数进程 ID(PID)。</p>
<p>从程序员的角度，可以认为进程总是处于下面三种状态之一：</p>
<ul>
<li>运行。进程要么在执行，要么等待被执行。</li>
<li>停止。进程的执行被挂起，且不会被调度。</li>
<li>终止。进程永远地停止了。</li>
</ul>
<p>父进程通过 fork 函数创建一个新运行的子进程，新创建的子进程几乎但不完全与父进程相同，它们之间的最大区别是有不同的 PID。</p>
<p>当一个进程由于某种原因终止时，进程保持一种终止的状态，直到被它的父进程回收。</p>
<p>execve 函数在当前进程的上下文中加载并运行一个新程序。</p>
<h3 id="2-信号">2. 信号</h3>
<p>一个信号就是一条消息，它通知进程系统中发生某种类型的事件。</p>
<p>传递一个信号到目的进程是由两个步骤组成的：</p>
<ul>
<li>发送信号：内核通过更新目的进程上下文中的某个状态，发送一个信号给目的进程。</li>
<li>接收信号：当目的进程被内核强迫以某种方式对信号的发送做出反应时，它就接收了信号。</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20191103170627.png" alt="信号处理"></figure>
<p>Unix 系统提供了大量的进程发送信号机制，这些机制都是基于进程组这个概念。每个进程只属于一个进程组，<br>
进程组由一个正整数 ID 标识。默认地，子进程和它的父进程属于同一个进程组。</p>
<p>当内核把进程 p 从内核模式切换到用户模式时，它会检查进程 p 的未被阻塞的待处理信号集合，如果集合为空，那么内核将控制传递到 p 的逻辑控制流的下一条指令。如果集合非空，那么内核选择集合中的某个信号 k，并且强制 p 接收 k。收到这个信号会触发进程采取某种行为。一旦进程完成了这个行为，那么控制就传递回 p 的逻辑控制流的下一条指令。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[深入理解计算机系统之异常控制流（一）]]></title>
        <id>https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-yi-chang-kong-zhi-liu-yi</id>
        <link href="https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-yi-chang-kong-zhi-liu-yi">
        </link>
        <updated>2019-10-27T13:14:43.000Z</updated>
        <content type="html"><![CDATA[<p>指令1，指令性2，指令3……，这样的控制转移序列就是处理器的控制流（control flow）。</p>
<p>现代系统通过使控制流发生突变，来应对系统状态的变化，称为异常控制流（ECF），它发生在计算机系统的各个层次。</p>
<p>ECF 的重要性：</p>
<ul>
<li>ECF 是操作系统实现 I/O、进程和虚拟内存的基本机制。</li>
<li>应用程序通过使用系统调用的 ECF 形式，来向操作系统请求服务。</li>
<li>操作系统为应用程序提供了强大的 ECF 机制，用来创建新进程、等待进程终止、通知其他进程中的异常事件。</li>
<li>ECF 是计算机系统中实现并发的基本机制，比如中断应用程序执行的异常处理程序。</li>
<li>非本地跳转是一种应用层 ECF，软件异常允许程序进行非本地跳转来响应错误情况。</li>
</ul>
<h3 id="1-异常">1. 异常</h3>
<p>异常就是控制流中的突变，用来响应处理器状态中的某些变化。它一部分由硬件实现，一部分由操作系统实现。</p>
<figure data-type="image" tabindex="1"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20191026212833.png" alt="异常的剖析"></figure>
<p>在任何情况下，当处理器检测到有事件发生时，就会通过一张叫做「异常表」的跳转表，进行一个间接过程调用，交给异常处理程序去处理。<br>
当处理完成后，根据引起异常事件的类型，发生以下 3 种情况中的一种：</p>
<ul>
<li>处理程序将控制返回给当前指令。</li>
<li>处理程序将控制返回给下一条指令。</li>
<li>处理程序终止被中断的程序。</li>
</ul>
<p>异常可以分为四类：</p>
<ul>
<li>中断：来自外部 I/O 设备信号的结果，不是由专门的指令造成的。</li>
<li>陷阱：最重要的用途是在用户程序和内核之间提供一个接口——系统调用。</li>
<li>故障：由错误情况引起，可能被故障处理程序修正，比如缺页异常。</li>
<li>终止：不可恢复的致命错误造成的结果，通常是一些硬件错误。</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20191026213802.png" alt="异常的类别"></figure>
<h3 id="2-进程">2. 进程</h3>
<p>进程就是一个正在执行的程序实例，系统中的每个程序都运行在某个进程的上下文（context）中。</p>
<p>进程提供给应用程序的关键抽象：</p>
<ul>
<li>一个独立的逻辑控制流，它提供一个假象，好像程序独占地使用处理器。</li>
<li>一个私有的地址空间，它提供一个假象，好像程序独占地使用内存系统。</li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20191027200254.png" alt="进程控制流"></figure>
<p>进程是轮流使用处理器的，每个进程执行它的流的一部分，然后被抢占（暂时挂起），然后轮到其他进程。</p>
<p>进程为每个程序提供它自己私有地址空间。一般而言，和某个地址关联的内存字节是不能被其他进程读或写的。每个私有地址空间都有相同的通用结构。</p>
<figure data-type="image" tabindex="4"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20191027201327.png" alt="x86-64 linux 进程地址空间"></figure>
<p>处理器通常是用某个控制寄存器中的一个模式位，来实现限制应用可以执行的指令以及可以访问的地址空间。</p>
<p>当设置了模式位时，进程就运行在内核模式中，它可以执行指令集中的任何指令，并且可以访问系统中的任何内存位置。没有设置模式位时，进行就运行在用户模式中，不允许执行特权指令，也不允许直接引用地址空间中内核区的代码和数据。</p>
<p>运行应用程序代码的进程起初是在用户模式中的，进程从用户模式变为内核模式的唯一方法就是通过中断、故障或者陷入系统调用这样的异常。</p>
<p>操作系统内核使用一种称为「上下文切换」的异常控制流来实现多任务。内核为每个进程维持一个上下文。上下文就是内核重新启动一个被抢占的进程所需的状态。这些状态包括：通用目的寄存器、程序计数器、用户栈、环境变量等。</p>
<p>上下文切换的过程：</p>
<ul>
<li>保存当前进程的上下文</li>
<li>恢复某个先前被抢占的进程保存的上下文</li>
<li>将控制传递给这个刚恢复的进程</li>
</ul>
<p>当执行系统调用或者中断时，都可能会发生上下文切换。</p>
<figure data-type="image" tabindex="5"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20191027202847.png" alt="进程上下文切换"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[深入理解计算机系统之存储器层次结构]]></title>
        <id>https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-cun-chu-qi-ceng-ci-jie-gou</id>
        <link href="https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-cun-chu-qi-ceng-ci-jie-gou">
        </link>
        <updated>2019-10-20T07:47:51.000Z</updated>
        <content type="html"><![CDATA[<h3 id="61-存储技术">6.1 存储技术</h3>
<p>这一节主要讲述存储技术的发展，从 SRAM、DRAM、ROM 再到硬盘。</p>
<p>随机访问存储器（RAM），分为静态 RAM 和动态 RAM，前者比后者更快，但也贵得多。SRAM 应用于高速缓存，DRAM 应用于主存和帧缓冲区。</p>
<p>高速缓存存储器作为 CPU 和主存之间的缓存区域，对应用程序性能的影响最大。现代计算机频繁使用基于 SRAM 的高速缓存，试图弥补处理器和内存之间的差距。</p>
<p>数据流通过总线（bus）在 CPU 和主存之间传递，总线携带地址、数据和控制信号。</p>
<figure data-type="image" tabindex="1"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20191020101259.png" alt="连接 CPU 和主存的总线"></figure>
<p>像显示器、鼠标、键盘这样的 I/O 设备，都是通过 I/O 总线连接到 CPU 和主存的。I/O 总线比系统和内存总线慢，但可以容纳多种第三方 I/O 设备。</p>
<figure data-type="image" tabindex="2"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20191020101728.png" alt="总线结构图"></figure>
<p>CPU 使用内存映射的技术向 I/O 设备发出命令，地址空间有一块是为 I/O 设备通信保留的 I/O 端口。</p>
<h3 id="62-局部性原理">6.2 局部性原理</h3>
<p>程序倾向于引用最近引用过的数据项，或者与最近引用过的数据项邻近的数据项。</p>
<p>局部性有两种表现形式：时间局部性和空间局部性。有着良好局部性的程序比局部性差的程序运行得更快。</p>
<p>对于一个循环求数组元素之和的函数，结果 sum 每次循环都被引用，具有良好的时间局部性。而数组按顺序迭代，具有良好的空间局部性。<br>
而对于多维数组，步长会影响程序的空间局部性。</p>
<p>评价程序中局部性的一些简单原则：</p>
<ul>
<li>重复引用相同变量的程序具有良好的时间局部性。</li>
<li>对于具有步长的引用模式的程序，步长越小，空间局部性越好。在内存中以大步长跳来跳去的程序，空间局部性会很差。</li>
<li>对于取指令来说，循环具有好的时间和空间局部性。循环体越小，迭次次数越多，局部性越好。</li>
</ul>
<h3 id="63-存储器的层次结构">6.3 存储器的层次结构</h3>
<figure data-type="image" tabindex="3"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20191020152557.png" alt="存储器层次结构"></figure>
<p>一般而言，从高层到底层，存储设备变得更慢、更便宜和更大容量。</p>
<p>存储器层次结构的本质是：每一层存储设备都是较低一层的缓存。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[深入理解计算机系统之程序的机器级表示（二）]]></title>
        <id>https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-cheng-xu-de-ji-qi-ji-biao-shi-er</id>
        <link href="https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-cheng-xu-de-ji-qi-ji-biao-shi-er">
        </link>
        <updated>2019-10-13T06:07:47.000Z</updated>
        <content type="html"><![CDATA[<h3 id="过程">过程</h3>
<p>过程提供了一种封装代码的方式，用一组指定的参数和一个可选的返回值实现某种功能。形式有函数、方法、子例程等。</p>
<p>C 语言使用栈提供的后进先出的内存管理原则。栈和程序寄存器存放着传递控制和数据、分配内存需要的信息。</p>
<p>当 Q 执行时，P 及 P 以上的函数调研暂时被挂起，需要为局部变量分配存储空间，或者设置另一个过程调用。当 Q 返回时，它分配的局部存储空间都会被释放。P 的返回地址也被压入栈中，表示在 Q 返回时，从 P 的返回地址继续执行。</p>
<p>大多数过程间数据传送通过寄存器实现，寄存器最多传递 6 个整型参数，超过 6 个的部分要通过栈来传递。</p>
<figure data-type="image" tabindex="1"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20191014070514.png" alt="栈帧结构"></figure>
]]></content>
    </entry>
</feed>