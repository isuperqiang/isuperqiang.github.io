<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://isuperqiang.cn</id>
    <title>落英坠露</title>
    <updated>2019-09-22T15:25:42.278Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://isuperqiang.cn"/>
    <link rel="self" href="https://isuperqiang.cn/atom.xml"/>
    <subtitle>生活不止眼前的苟且，还有诗和远方的田野。</subtitle>
    <logo>https://isuperqiang.cn/images/avatar.png</logo>
    <icon>https://isuperqiang.cn/favicon.ico</icon>
    <rights>All rights reserved 2019, 落英坠露</rights>
    <entry>
        <title type="html"><![CDATA[每周 ARTS 第 24 期]]></title>
        <id>https://isuperqiang.cn/post/mei-zhou-arts-di-24-qi</id>
        <link href="https://isuperqiang.cn/post/mei-zhou-arts-di-24-qi">
        </link>
        <updated>2019-09-14T15:17:25.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-algorithm">1. Algorithm</h2>
<h3 id="22-生成括号中等">22. 生成括号（中等）</h3>
<h5 id="描述">描述：</h5>
<blockquote>
<p>给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。</p>
</blockquote>
<h5 id="示例">示例：</h5>
<pre><code>例如，给出 n = 3，生成结果为：
[
  &quot;((()))&quot;,
  &quot;(()())&quot;,
  &quot;(())()&quot;,
  &quot;()(())&quot;,
  &quot;()()()&quot;
]
</code></pre>
<h5 id="思路">思路：</h5>
<p><strong>动态规划</strong></p>
<p>生成 N 对括号，必然有 N 个左括号和 N 个右括号，左括号的数量大于等于右括号。要确定 N 对，首先确定 N-1 对，利用递归求解。</p>
<p>left 记录左括号的数量，right 记录右括号的数量，当左右括号的数量相等时，记录结果，结束递归。</p>
<pre><code class="language-java">class Sulution {
    public int uniquePaths(int m, int n) {
        int[][] dp = new int[m][n];
        for (int i = 0; i &lt; m; i++) {
            dp[i][0] = 1;
        }
        for (int i = 0; i &lt; n; i++) {
            dp[0][i] = 1;
        }
        for (int i = 1; i &lt; m; i++) {
            for (int j = 1; j &lt; n; j++) {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m - 1][n - 1];
    }
}
</code></pre>
<h5 id="分析">分析：</h5>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(n)</li>
</ul>
<h2 id="2-review">2. Review</h2>
<p><a href="https://blog.codinghorror.com/the-two-types-of-programmers/">The Two Types of Programmers</a> 两种程序员</p>
<p>在软件开发领域，有两种程序员：20% 的开拓者，他们对技术痴迷，紧跟最新趋势。还有 80% 的普通人，编程对于他们只是工作，工作之外不关心代码。这两类人群有着巨大的鸿沟，如果要改变软件开发的现状，就要在这两类人群之间建立连接。</p>
<h2 id="3-tip">3. Tip</h2>
<p><a href="https://mp.weixin.qq.com/s/QMhMSJ95Kl0tdE-jb1Jvgw">花椒移动端基础框架架构</a> 这篇文章总结了移动端的架构，对移动应用架构设计有参考价值。</p>
<h2 id="4-share">4. Share</h2>
<p><a href="https://mp.weixin.qq.com/s/XXSkDygqm2RY8YqmJCyJWw">总结几点“上不得台面”的技术领导经验</a></p>
<p>在我看来，身为技术领导，对技术的敬畏、诚实谦和、尊重客观、力求平等，应当是始终不变的坚持。但是，在坚韧的骨骼之外，让身段变柔软一点，总不是坏事。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[深入理解计算机系统之信息的表示和处理（二）]]></title>
        <id>https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-xin-xi-de-biao-shi-he-chu-li-er</id>
        <link href="https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-xin-xi-de-biao-shi-he-chu-li-er">
        </link>
        <updated>2019-09-14T13:39:12.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1-整数运算">1. 整数运算</h3>
<h4 id="11-加法">1.1 加法</h4>
<p><strong>无符号加法：</strong> 考虑两个非负整数 x 和 y，满足 0&lt;=x, y&lt;2^w。当  x+y &gt;= 2^w 时，和发生溢出。 溢出情况就是该和减去 2^w 的结果。</p>
<p><strong>补码加法：</strong> 当 x+y 小于 -2^(w-1) 时，发生负溢出；当它大于 2^(w-1) 时，发生正溢出。负溢出导致和增加 2^w，正溢出导致和减少 2^w。</p>
<p><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/TIM%E6%88%AA%E5%9B%BE20190908192533.png" alt="补码加法的溢出"></p>
<h4 id="12-乘法">1.2 乘法</h4>
<p>在大多数机器上，整数乘法指令非常慢，需要 10 个或者更多的时钟周期，然而加法、减法和位运算只需要 1 个时钟周期。</p>
<p>左移一个整数等价于执行与 2 的幂相等的乘法。</p>
<p>由于整数乘法比移位和加法的代价要大得多，许多 C 语言编译器使用移位和加法运算的组合代替乘以常数因子的乘法。例如，表达式 x * 14，利用 14 = 2^3 + 2^2 + 2^1，编译器会将乘法重写为 (X &lt;&lt; 3) + (X &lt;&lt; 2) + (X &lt;&lt; 1)。</p>
<h4 id="13-除法">1.3 除法</h4>
<p>在大多数机器上，整数除法要比整数乘法更慢，需要 30 个或者更多的时钟周期。</p>
<p>除以 2 的幂可以用右移（算术右移）运算来实现。</p>
<p>不能用除以 2 的幂的除法来表示除以任意常数的除法。</p>
<h3 id="2-浮点数">2. 浮点数</h3>
<h4 id="21-二进制小数">2.1 二进制小数</h4>
<p>小数的二进制表示法只能表示被写成 x*2^y 的数，其他数值只能近似表示。例如数字 1/5 可以用十进制小数 0.2 精确表示。但是，并不能把它准确地表示为二进制小数，我们只能近似地表示它，增加二进制表示的长度可以提高表示的精度。</p>
<h4 id="22-ieee-浮点表示">2.2 IEEE 浮点表示</h4>
<p>IEEE 754 浮点标准使用 V = (-1)^s * M * 2^E 来表示一个数：</p>
<ul>
<li>符号 s：s 决定数值是负数(s=1)还是正数(s=0)</li>
<li>尾数 M：是个二进制小数，范围是 1-2-ε 或者 0-1-ε</li>
<li>阶码 E：E 的作用是对浮点数加权，这个权重是 2 的 E 次幂</li>
</ul>
<p>将浮点数的位表示划分为三个字段，分别对这些值进行编码：</p>
<ul>
<li>一个单独对符号位 s 编码符号 s</li>
<li>k 位对阶码字段 exp 编码阶码 E</li>
<li>n 位对小数字段 frac 编码尾数 M</li>
</ul>
<p><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20190914192853.png" alt="标准浮点格式"></p>
<p>浮点数只能近似表示实数运算，它采用向偶数舍入的方式。需要注意的是，浮点数运算不具备结合性和分配性。</p>
<p><strong>总结一下：</strong></p>
<ul>
<li>整数运算溢出会导致结果异常，编程时要格外注意整数的范围。</li>
<li>通过左移和右移来进行整数乘除运算比算术运算要高效。</li>
<li>浮点数采用 IEEE 754 标准表示，编码方式是符号、阶码和尾数。</li>
<li>浮点数是近似表示的，它的运算不精确，之前总结过<a href="https://isuperqiang.cn/post/java-bi-jiao-fu-dian-shu-de-zheng-que-fang-shi/">Java 比较浮点数的正确方式</a>。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每周 ARTS 第 23 期]]></title>
        <id>https://isuperqiang.cn/post/mei-zhou-arts-di-23-qi</id>
        <link href="https://isuperqiang.cn/post/mei-zhou-arts-di-23-qi">
        </link>
        <updated>2019-09-10T00:45:53.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-algorithm">1. Algorithm</h2>
<h3 id="62-不同路径中等">62. 不同路径（中等）</h3>
<h5 id="描述">描述：</h5>
<blockquote>
<p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。<br>
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。<br>
问总共有多少条不同的路径？</p>
</blockquote>
<h5 id="示例">示例：</h5>
<pre><code>输入: m = 3, n = 2
输出: 3
解释:
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -&gt; 向右 -&gt; 向下
2. 向右 -&gt; 向下 -&gt; 向右
3. 向下 -&gt; 向右 -&gt; 向右
</code></pre>
<h5 id="思路">思路：</h5>
<p><strong>动态规划</strong></p>
<p>令 dp[i][j] 是到达 i, j 最多路径。<br>
动态方程：dp[i][j] = dp[i-1][j] + dp[i][j-1]<br>
注意，对于第一行 dp[0][j]，或者第一列 dp[i][0]，由于都是在边界，所以只能为 1。</p>
<pre><code class="language-java">class Sulution {
    public int uniquePaths(int m, int n) {
        int[][] dp = new int[m][n];
        for (int i = 0; i &lt; m; i++) {
            dp[i][0] = 1;
        }
        for (int i = 0; i &lt; n; i++) {
            dp[0][i] = 1;
        }
        for (int i = 1; i &lt; m; i++) {
            for (int j = 1; j &lt; n; j++) {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m - 1][n - 1];
    }
}
</code></pre>
<h5 id="分析">分析：</h5>
<ul>
<li>时间复杂度：O(m*n)</li>
<li>空间复杂度：O(m*n)</li>
</ul>
<h5 id="优化">优化：</h5>
<p>使用一维数组记录变量，空间复杂度降为 O(n)。</p>
<pre><code class="language-java">class Sulution {
    public int uniquePaths(int m, int n) {
        int[] sum = new int[n];
        Arrays.fill(sum, 1);
        for (int i = 1; i &lt; m; i++) {
            for (int j = 1; j &lt; n; j++) {
                sum[j] += sum[j - 1];
            }
        }
        return sum[n - 1];
    }
}
</code></pre>
<h2 id="2-review">2. Review</h2>
<p><a href="https://medium.com/s/story/reflections-on-clean-code-8c9b683277ca">What is clean code?</a> 什么是整洁的代码？</p>
<p>作者从《Clean Code》这本书说起，它被认为是程序员的必读书，作者概括了三个关键概念：</p>
<ul>
<li>技术手艺很重要。代码不仅要正常工作，而且要让其他人长期受益。拙劣的代码在边缘磨损的速度比你想象的要快得多。</li>
<li>今天的额外努力会减轻明天痛苦。一开始写出好代码并经常重构，日后就会节省的时间和金钱。</li>
<li>你的代码不是你自己的。对作者来说，过于聪明的技巧、黑客和编程手法只是有趣的。对他人友好的代码才是可取的。</li>
</ul>
<p>那究竟什么是 Clean Code 呢？作者给出了自己的观点：</p>
<ul>
<li>整洁代码是简洁的。不是算法或系统的复杂性，而是实现上的简约。</li>
<li>整洁代码是可读的。代码规约有助于写出可读性好的代码。</li>
<li>整洁代码是经过深思熟虑的。假定未来有代码使用者，一看到你的代码就懂。</li>
<li>整洁代码是经过测试的。没人写得出完美的代码，经过测试的代码是整洁的。</li>
<li>整洁代码是经过实践的。要一直写整洁代码，不断练习来提高技能。</li>
<li>整洁代码是经常被重构的。尽可能多地重构，不要担心出问题。</li>
<li>整洁代码符合 SOLID 原则。确保你的代码灵活、可维护、长久。</li>
</ul>
<h2 id="3-tip">3. Tip</h2>
<p>读到<a href="https://book.douban.com/subject/1230413/">《深入理解计算机系统》</a> 第二章 <a href="https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-zheng-shu-biao-shi/">深入理解计算机系统之信息的表示和处理</a>，了解了整数的表示和信息存储方法。理论知识有用么？当然有用。整形溢出是编程中经常遇到的问题，知道整数的表示方式后，会尽量规避溢出的错误。比如二分法中的取中数，<code>mid = (low + high) / 2</code> 就潜在溢出的风险，而 <code>mid = low + (high - low) /2</code>则不会，这样的程序更健壮。</p>
<h2 id="4-share">4. Share</h2>
<p>都说 deadline 是第一生产力，但是也不要总拖到最后，这时往往会因为做得太快而导致质量下降。日常有规划地进行，一步一个脚印，这样才能走得更远。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[深入理解计算机系统之信息的表示和处理（一）]]></title>
        <id>https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-zheng-shu-biao-shi-xin-xi-chu-li-yi</id>
        <link href="https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-zheng-shu-biao-shi-xin-xi-chu-li-yi">
        </link>
        <updated>2019-09-07T14:14:10.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1-信息存储">1. 信息存储</h3>
<p>计算机使用字节作为最小的内存寻址单位，1 个字节等于 8 位。机器级程序将内存视为一个非常大的字节数组，称为虚拟内存。内存的每个字节都用唯一的数字来标识，称为它的地址。所有可能地址的集合称为虚拟地址空间。这个地址空间只是一个展现给机器级程序的概念性映像。</p>
<p>我们一般不直接使用 0 和 1 表示信息，那样的话数据太长了，而且可读性不好。通常把四个二进制当作一组，也就是十六进制表示字节，以 0x 或 0X 开头的数字代表十六进制的值，两个十六进制的值就是一个字节。比如：01011100 等价于 5C。</p>
<p><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20190907220057.png" alt="十六进制表示法"></p>
<p>字节用十六进制表示后，下面该确定它的顺序了。内存地址是递增的，是按照人类的习惯，高位在前低位在后，还是相反呢？</p>
<p>字节的排列方式有两种：</p>
<ul>
<li>大端法（big endian）：最高有效字节在前</li>
<li>小端法（little endian）：最低有效字节在前</li>
</ul>
<p>举个例子：0x01234567</p>
<table>
<thead>
<tr>
<th>地址</th>
<th>0x100</th>
<th>0x101</th>
<th>0x102</th>
<th>0x103</th>
</tr>
</thead>
<tbody>
<tr>
<td>大端法</td>
<td>01</td>
<td>23</td>
<td>45</td>
<td>67</td>
</tr>
<tr>
<td>小端法</td>
<td>67</td>
<td>45</td>
<td>23</td>
<td>01</td>
</tr>
</tbody>
</table>
<p>选择何种字节顺序，并没有技术上的优劣之分，只要坚持使用同一种规则。</p>
<p>参数 12345 的十六进制表示为 0x00003039，下面是在不同系统上测试的结果。</p>
<p><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20190903092905.png" alt="不同数据值的字节表示"></p>
<p>从上图可以看出，Linux 32、Windows 和 Linux 64 采用小端法表示，Sun 采用大端法表示。</p>
<h3 id="2-整数表示">2. 整数表示</h3>
<p>C 语言的整数分为无符号数和有符号数，而 Java 只有有符号数。</p>
<p>无符号数的所有位都表示值，对于 w 位长度的无符号数，它的取值范围是 0 - 2^w-1，编码表示是唯一的。举个例子：</p>
<blockquote>
<p>1011 = 1 * 2^3 + 0 * 2^2 + 1 * 2^1 + 1 * 2^0 = 11</p>
</blockquote>
<p>有符号数采用补码表示，最高位是符号位，其中 1 代表负数，0 代表正数。对于 w 位长度的无符号数，它的取值范围是 -2^(w-1) - 2^(w-1)，编码表示是唯一的。举个例子：</p>
<blockquote>
<p>1011 = -1 * 2^3 + 0 * 2^2 + 1 * 2^1 + 1 * 2^0 = -5</p>
</blockquote>
<p><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20190907215430.png" alt="重要的数字"></p>
<p>其中，U 表示最无符号编码，T 表示补码编码。</p>
<p>有符号数到无符号数的隐式类型转换导致某些非直观的行为，避免这类错误的一种方法是绝不使用无符号数。</p>
<p><strong>总结一下：</strong></p>
<ul>
<li>计算机用二进制表示信息，我们把计算机的二进制用十六进制表示是更友好的升华。</li>
<li>字节的排序方式有两种：大端法和小端法，区别是高位在前还是在后。</li>
<li>无符号数的所有位表示值。</li>
<li>有符号数采用补码表示，最高位是符号位。</li>
<li>无符号数和有符号数之间的转换容易出错，尽量避免使用无符号数。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每周 ARTS 第 22 期]]></title>
        <id>https://isuperqiang.cn/post/mei-zhou-arts-di-22-qi</id>
        <link href="https://isuperqiang.cn/post/mei-zhou-arts-di-22-qi">
        </link>
        <updated>2019-09-01T12:47:10.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-algorithm">1. Algorithm</h2>
<h3 id="15-三数之和中等">15. 三数之和（中等）</h3>
<h5 id="描述">描述：</h5>
<blockquote>
<p>给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。</p>
</blockquote>
<h5 id="示例">示例：</h5>
<pre><code>例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，

满足要求的三元组集合为：
[
  [-1, 0, 1],
  [-1, -1, 2]
]
</code></pre>
<h5 id="思路">思路：</h5>
<p><strong>双指针法</strong></p>
<p>首先对数组进行排序，然后固定一个数 nums[i]，使用左右指针分别指向 nums[i] 后面的两端。计算三个数的和 sum，判断 sum 是否满足为 0。如果满足则添加进结果集，否则左右指针交替向中间移动。同时注意去重。</p>
<pre><code class="language-java">class Sulution {
    public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) {
        if (nums == null || nums.length &lt; 3) {
            return Collections.emptyList();
        }
        Arrays.sort(nums);
        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();
        int length = nums.length;
        for (int i = 0; i &lt; length; i++) {
            if (nums[i] &gt; 0) {
                break;
            }
            if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) {
                continue;
            }
            int l = i + 1, r = length - 1;
            while (l &lt; r) {
                int s = nums[i] + nums[l] + nums[r];
                if (s == 0) {
                    while (l &lt; r &amp;&amp; nums[l] == nums[l + 1]) {
                        l++;
                    }
                    while (l &lt; r &amp;&amp; nums[r] == nums[r - 1]) {
                        r--;
                    }
                    result.add(Arrays.asList(nums[i], nums[l], nums[r]));
                    l++;
                    r--;
                } else if (s &gt; 0) {
                    r--;
                } else {
                    l++;
                }
            }
        }
        return result;
    }

}
</code></pre>
<h5 id="分析">分析：</h5>
<ul>
<li>时间复杂度：O(n^2)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h2 id="2-review">2. Review</h2>
<p><a href="https://medium.com/@maladdinsayed/advanced-techniques-and-ideas-for-better-coding-skills-d632e9f9675">Advanced Coding Skills, Techniques, and Ideas</a></p>
<p>作者列举了一些编程的技巧。</p>
<ul>
<li>重构可以帮助我们写出整洁的代码，可读可维护可重用。</li>
<li>不要重构生产环境中没有经过单元测试的代码，要想重构，先单元测试。</li>
<li>从代码的最深处开始重构，最深处只关注单一的逻辑，这使得重构更加容易。</li>
<li>使你的方法变得短小，通过把它们拆分成更小的方法。</li>
<li>if 语句后面总是跟着 {}，即使只有一行。</li>
<li>不要使用魔法值，因为它的可读性太差了，可以抽取出变量或者常量。</li>
<li>如果没有必要，不要使用 else 语句，比如 if 语句中有 return 时，语句块外不需要 else。</li>
<li>为你的方法、变量和测试选择有意义的命名。</li>
<li>使用你的编程语言的最大能力，这样会省力，增强代码的健壮性。</li>
<li>……</li>
</ul>
<p>代码经验都要靠积累，推荐阿里巴巴的<a href="https://github.com/alibaba/p3c">代码规约</a>。</p>
<h2 id="3-tip">3. Tip</h2>
<p>最近在读<a href="https://book.douban.com/subject/1230413/">《深入理解计算机系统》</a>，又称 CSAPP，真是神书！读完第一章，对计算机系统有了新的认识——<a href="https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-ji-suan-ji-xi-tong-man-you/">深入理解计算机系统之计算机系统漫游</a>。</p>
<h2 id="4-share">4. Share</h2>
<p>说一说如何选书。写书是一件正式的活动，作者都会认真对待。但是作者的经验水平不一样，产出的内容质量也参差不齐。对于追热点的、空洞无物的、作者资历尚浅的图书，一般不值得阅读。辨别的方式是看豆瓣评分，经过时间筛选过的经典，最值得阅读。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[深入理解计算机系统之计算机系统漫游]]></title>
        <id>https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-ji-suan-ji-xi-tong-man-you</id>
        <link href="https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-ji-suan-ji-xi-tong-man-you">
        </link>
        <updated>2019-08-28T14:11:37.000Z</updated>
        <content type="html"><![CDATA[<h3 id="信息就是位上下文">信息就是位+上下文</h3>
<p>计算机系统中的所有信息——包括磁盘文件、内存中的数据以及网络上传送的数据，都是由一串比特序列表示。区分不同数据对象的唯一方法是我们读到这些数据时的上下文。比如在不同的上下文中，一个同样的字节序列可能表示一个整数、字符串或者机器指令。</p>
<p>这让我想起以前遇到的一个问题。当时用 NDK 开发，错把数组的 JVM 地址直接传给了 Native，然后程序运行失败了。同样的内存地址，也就是一段字节序列，在 JVM 和 Native 中的解释不一样，说明信息脱离上下文就没有意义了，传递信息时不能忽略上下文。</p>
<h3 id="程序被编译执行">程序被编译执行</h3>
<p>下面是用 C 语言实现 hello 程序，它是一种人类可读的文本表示，但是计算机只认由 0 和 1 组成的机器指令，C 语句需要被转化为机器语言指令，打包成可执行目标程序，以二进制的磁盘文件形式存放。</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    printf(&quot;Hello world\n&quot;);
    return 0;
}
</code></pre>
<p>在 Unix 系统上，从源文件到目标文件的转化是由编译器驱动程序完成的。</p>
<p><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/Jietu20190115-075112.jpg" alt="编译系统"></p>
<p>为什么要编译才能执行呢？因为 C 语言是高级程序设计语言，计算机无法理解 C 语言的语句。像 Python 这样的脚本语言，源代码需要边解释边执行，这是另外一种思路，本质上都是翻译为机器代码。</p>
<h3 id="系统的硬件组成">系统的硬件组成</h3>
<p><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/Jietu20190115-075221.jpg" alt="系统硬件组成"></p>
<ol>
<li>总线：贯穿整个系统的一组电子管道。在各个部件间传送定长的字节块，也就是字 word。字长是一个基本的系统参数，要么是 4 个字节（32位），要么是 8 个字节（64位）。</li>
<li>IO 设备：系统与外部世界的联系通道，通过控制器或适配器与 IO 总线相连。</li>
<li>主存：临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。</li>
<li>处理器：CPU，解释或执行存储在主存中指令的引擎。处理器的核心是一个大小为一个字的寄存器，称为程序计数器（PC）。在任何时刻，PC 都指向主存中的某条机器语言指令。</li>
</ol>
<p>上面的组成图也可以用<strong>冯·诺依曼体系结构</strong>解释。处理器负责运算和控制，主存负责存储数据和指令，IO 设备负责输入和输出。</p>
<h3 id="存储设备的层次结构">存储设备的层次结构</h3>
<p><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/Jietu20190115-075353.jpg" alt="存储器层次结构"></p>
<p>存储器层次结构的主要思想是上层的存储器作为下层存储器的高速缓存。</p>
<p>为什么要分层呢？因为硬件的读写速度不匹配。越靠近 CPU，读写速度越快，当然价格也更高。现在硬件设计的原则是用空间换时间，买电子设备还是选内存大的，因为<strong>时间比空间更值钱</strong>。</p>
<h3 id="操作系统管理硬件">操作系统管理硬件</h3>
<p>操作系统有两个基本功能：</p>
<ol>
<li>防止硬件被失控的应用程序滥用</li>
<li>向应用程序提供简单一致的机制来控制复杂的低级硬件设备</li>
</ol>
<p>操作系统通过几个抽象概念来实现这两个功能，进程、虚拟内存和文件。文件是对 IO 设备的抽象表示，虚拟内存是对主存和磁盘 IO 设备的抽象表示，进程是对处理器、内存和 IO 设备的抽象表示。虚拟机是对整个计算机的抽象，包括操作系统、处理器和程序。指令集架构是对处理器的抽象。</p>
<p><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/Jietu20190115-075700.jpg" alt="计算机系统的抽象"></p>
<p>这里讲的抽象就非常耐人寻味，它简化了系统实现的复杂性。比如，文件操作包括打开、读取、写入和关闭，IO 设备包括本地磁盘、网络存储等。对文件操作都可以抽象出统一的接口，由不同的 IO 设备实现。</p>
<h3 id="进程和线程">进程和线程</h3>
<p>进程是操作系统对一个正在运行的程序的一种抽象。处理器通过在进程间切换的机制（上下文切换）实现并行。</p>
<p>操作系统保持跟踪进程运行所需的所有状态信息，这种状态就是上下文，包括 PC 和寄存器文件的当前值以及主存的内容。上下文切换就是保存当前进程的上下文，恢复新进程的上下文，然后将控制权传递到新进程。</p>
<p><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/Jietu20190115-075513.jpg" alt="进程上下文切换"></p>
<p>从一个进程到另一个进程的切换是由操作系统的内核管理的，内核是操作系统代码常驻主存的部分。它不是一个独立的进程，而是系统管理全部进程所用代码和数据结构的集合。</p>
<p>一个进程实际上由多个线程的组成，每个线程都运行在进程的上下文中，共享同样的代码和数据。</p>
<p>所以有这样的说法：进程是资源分配的基本单位，线程是任务调度的基本单位。</p>
<p>计算机系统漫游让我们从整体上认识了系统的结构和组成，算是为接下来的学习开了个好头。好的开端是成功的一半。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每周 ARTS 第 21 期]]></title>
        <id>https://isuperqiang.cn/post/mei-zhou-arts-di-21-qi</id>
        <link href="https://isuperqiang.cn/post/mei-zhou-arts-di-21-qi">
        </link>
        <updated>2019-08-25T11:25:36.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-algorithm">1. Algorithm</h2>
<h3 id="24-两两交换链表中的节点中等">24. 两两交换链表中的节点（中等）</h3>
<h5 id="描述">描述：</h5>
<blockquote>
<p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。<br>
你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>
</blockquote>
<h5 id="示例">示例：</h5>
<pre><code>给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.
</code></pre>
<h5 id="思路">思路：</h5>
<ul>
<li>迭代法：从 head 开始遍历，改变相邻节点和它们前后节点之间的关系。</li>
</ul>
<pre><code class="language-java">class Sulution {
    public ListNode swapPairs(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        ListNode curr = head;
        ListNode result = head.next;
        ListNode next;
        ListNode prev = null;
        while (curr != null &amp;&amp; (next = curr.next) != null) {
            ListNode temp = next.next;
            next.next = curr;
            curr.next = temp;
            if (prev != null) {
                prev.next = next;
            }
            prev = curr;
            curr = temp;
        }
        return result;
    }
}
</code></pre>
<ul>
<li>递归法：先处理最后两个或一个节点，然后再从后往前处理每一对节点。</li>
</ul>
<pre><code class="language-java">class Sulution {
    public ListNode swapPairs(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        ListNode next = head.next;
        head.next = swapPairs(next.next);
        next.next = head;
        return next;
    }
}
</code></pre>
<h2 id="2-review">2. Review</h2>
<p><a href="https://medium.com/free-code-camp/how-to-use-git-efficiently-54320a236369">How to use Git efficiently</a> 如何高效地使用 Git</p>
<p>作者通过一个开发场景，讲解了 Git workflow 的使用技巧。在多人协作的开发过程中，分支是重要的代码管理手段。</p>
<p>分支主要分为三种：master、release/、feature/xxx。master 是主分支，它存放的是生产代码的拷贝，任何人都不允许在 master 分支提交代码。release 是发布分支，它从 master 分支创建，可以存在多个并行分支 release/xxx，多个项目在同一个 code base 中时，release 分支可以保证项目并行。feature 是需求分支，它通常从 release 分支创建。每个需求都可以创建新的分支，每个开发者在不同的分支上进行功能开发。然后通过 PR 把代码合并到 release 分支。</p>
<p>通过 pull request，feature 分支的代码合并到 release 分支，主管可以在合并前进行 code review。如果发生合并冲突，解决办法有两种：处理 PR 的主管解决；开发者从 release 分支 pull 最新代码合并到 feature 分支并解决冲突。</p>
<p>项目完成后，release 分支的代码合并到 master 分支，然后发布产品。</p>
<h2 id="3-tip">3. Tip</h2>
<p>最近在维护代码的过程中，发现很多地方写得不够好，重复的代码太多，代码结构有些混乱。有时间我就重构，每个点都仔细推敲，引入经典的设计模式，本着可读性和可维护性好的原则，其他人接手也容易，clean code 原则一定要牢记心间呐。</p>
<h2 id="4-share">4. Share</h2>
<p><a href="https://www.yuque.com/zenany/up/high_productivity_work">高效工作</a> 来自语雀精选</p>
<p>作者从两方面列举了高效工作的做法。</p>
<ul>
<li>增加有效工作时间</li>
<li>提高单位时间的产能</li>
</ul>
<p>高效能的三个要素：<strong>时间、能量和注意力</strong>。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每周 ARTS 第 20 期]]></title>
        <id>https://isuperqiang.cn/post/mei-zhou-arts-di-20-qi</id>
        <link href="https://isuperqiang.cn/post/mei-zhou-arts-di-20-qi">
        </link>
        <updated>2019-08-18T14:16:54.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-algorithm">1. Algorithm</h2>
<h3 id="1116-打印零与奇偶数中等">1116. 打印零与奇偶数（中等）</h3>
<h5 id="描述">描述：</h5>
<blockquote>
<p>有这样一个类 ZeroEvenOdd，相同的一个 ZeroEvenOdd 类实例将会传递给三个不同的线程：</p>
<ul>
<li>
<p>线程 A 将调用 zero()，它只输出 0 。</p>
</li>
<li>
<p>线程 B 将调用 even()，它只输出偶数。</p>
</li>
<li>
<p>线程 C 将调用 odd()，它只输出奇数。</p>
</li>
</ul>
<p>每个线程都有一个 printNumber 方法来输出一个整数。请修改给出的代码以输出整数序列 010203040506... ，其中序列的长度必须为 2n。</p>
</blockquote>
<h5 id="示例">示例：</h5>
<pre><code>输入：n = 2
输出：&quot;0102&quot;
说明：三条线程异步执行，其中一个调用 zero()，另一个线程调用 even()，最后一个线程调用odd()。正确的输出为 &quot;0102&quot;。
</code></pre>
<h5 id="思路">思路：</h5>
<p>线程同步问题，可以使用锁或者信号量解决。</p>
<ul>
<li>解法一：Lock 和 Condition</li>
</ul>
<pre><code class="language-java">    private static class ZeroEvenOdd1 {
        private final Lock lock = new ReentrantLock();
        private final Condition evenCondition = lock.newCondition();
        private final Condition oddCondition = lock.newCondition();
        private final Condition zeroCondition = lock.newCondition();
        private int n;
        private int current = 1;
        // 0 refers zero, 1 refers odd, 2 refers even
        private int state = 0;

        public ZeroEvenOdd1(int n) {
            this.n = n;
        }

        // printNumber.accept(x) outputs &quot;x&quot;, where x is an integer.
        public void zero(IntConsumer printNumber) throws InterruptedException {
            lock.lock();
            try {
                while (current &lt;= n) {
                    if (state != 0) {
                        zeroCondition.await();
                    }
                    printNumber.accept(0);
                    if ((current &amp; 1) == 0) {
                        state = 2;
                        evenCondition.signal();
                    } else {
                        state = 1;
                        oddCondition.signal();
                    }
                    zeroCondition.await();
                }
                oddCondition.signal();
                evenCondition.signal();
            } finally {
                lock.unlock();
            }
        }

        // 偶数
        public void even(IntConsumer printNumber) throws InterruptedException {
            lock.lock();
            try {
                while (current &lt;= n) {
                    if (state != 2) {
                        evenCondition.await();
                    } else {
                        printNumber.accept(current++);
                        state = 0;
                        zeroCondition.signal();
                    }
                }
            } finally {
                lock.unlock();
            }
        }

        // 奇数
        public void odd(IntConsumer printNumber) throws InterruptedException {
            lock.lock();
            try {
                while (current &lt;= n) {
                    if (state != 1) {
                        oddCondition.await();
                    } else {
                        printNumber.accept(current++);
                        state = 0;
                        zeroCondition.signal();
                    }
                }
            } finally {
                lock.unlock();
            }
        }
    }
</code></pre>
<ul>
<li>解法二：Semaphore</li>
</ul>
<pre><code class="language-java">    private static class ZeroEvenOdd2 {
        private final Semaphore zeroSemaphore = new Semaphore(1);
        private final Semaphore evenSemaphore = new Semaphore(0);
        private final Semaphore oddSemaphore = new Semaphore(0);
        private int n;

        public ZeroEvenOdd2(int n) {
            this.n = n;
        }

        // printNumber.accept(x) outputs &quot;x&quot;, where x is an integer.
        public void zero(IntConsumer printNumber) throws InterruptedException {
            for (int i = 1; i &lt;= n; i++) {
                zeroSemaphore.acquire();
                printNumber.accept(0);
                if ((i &amp; 1) == 0) {
                    evenSemaphore.release();
                } else {
                    oddSemaphore.release();
                }
            }
        }

        public void even(IntConsumer printNumber) throws InterruptedException {
            for (int i = 2; i &lt;= n; i += 2) {
                evenSemaphore.acquire();
                printNumber.accept(i);
                zeroSemaphore.release();
            }
        }

        public void odd(IntConsumer printNumber) throws InterruptedException {
            for (int i = 1; i &lt;= n; i += 2) {
                oddSemaphore.acquire();
                printNumber.accept(i);
                zeroSemaphore.release();
            }
        }
    }
</code></pre>
<h2 id="2-review">2. Review</h2>
<p><a href="https://medium.com/free-code-camp/follow-these-simple-rules-and-youll-become-a-git-and-github-master-e1045057468f">Follow these simple rules and you’ll become a Git and GitHub master</a> 遵循这些规范，你就会成为 Git 大师。</p>
<p>作者提出了三条建议：</p>
<ul>
<li>为每个新项目创建 Git 仓库</li>
<li>为每个新需求创建新分支</li>
<li>使用 pull request 合并代码到 master 分支</li>
</ul>
<p>点评：Git 是非常强大的版本控制工具，每个程序员都该熟练掌握。</p>
<h2 id="3-tip">3. Tip</h2>
<p>《高效阅读法》（levarage reading）讲了许多不一样的读书方法。读书不一定要从头开始完整读一遍，只读对自己有用的、感兴趣的地方，无关紧要的内容一律跳过，设定读书的时间限制，比如两小时读完，这样读书速度就提升了一大截。仅仅读了还不够，要运用到生活中，读以致用。 最有效的投资就是自我投资，读书是最好的自我投资。</p>
<h2 id="4-share">4. Share</h2>
<p><a href="https://mp.weixin.qq.com/s/o4CfgIcPibG_QxrsZ4x7sA">技术人如何通过了解业务，获取晋升机会？</a></p>
<p>阿里技术专家的一篇分享，对于技术和业务讲得非常中肯。下面是作者的几个观点：</p>
<ul>
<li>业务先赢是技术第一要务。技术人员首要任务是先把业务支持好，在这个前提下，再来讲技术沉淀和技术红利。</li>
<li>理解业务有助于你做技术决策去驱动业务，有助于你对资源的优先级做判断，而且还有助于提升你的研发效能。</li>
<li>理解业务更多是理解了运营决策背后的原因，理解了网站各个角色的诉求和痛点，理解了自己做的产品和项目对业务的价值和影响。</li>
<li>技术人的三大支柱：业务理解、项目管理和专业技术。一个不理解业务的研发，和流水线的工人是没有很大的区别的。</li>
<li>技术人员不一定要去这么深入理解业务或者成果出在业务上，对技术很感兴趣的同学而且有抓手的同学，就安心地去专研技术并取得结果就好，注意要取得结果，不能是说不清楚的东西。</li>
<li>对于技术上没有鲜明特色的同学，或者有技术深度但是暂时想不到什么技术挖掘点的同学，不妨去多看看业务，寻找技术驱动业务的机会。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每周 ARTS 第 19 期]]></title>
        <id>https://isuperqiang.cn/post/mei-zhou-arts-di-19-qi</id>
        <link href="https://isuperqiang.cn/post/mei-zhou-arts-di-19-qi">
        </link>
        <updated>2019-08-11T14:52:34.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-algorithm">1. Algorithm</h2>
<h3 id="46-全排列中等">46. 全排列（中等）</h3>
<h5 id="描述">描述：</h5>
<blockquote>
<p>给定一个没有重复数字的序列，返回其所有可能的全排列。</p>
</blockquote>
<h5 id="示例">示例：</h5>
<pre><code>输入: [1,2,3]
输出:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
</code></pre>
<h5 id="思路">思路：</h5>
<p>回溯法。深度优先搜索（DFS）和交换元素，</p>
<pre><code class="language-java">class Solution {
    public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) {
        if (nums == null || nums.length == 0) {
            return null;
        }
        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();
        dfs(0, nums, result);
        return result;
    }

    private void dfs(int curr, int[] nums, List&lt;List&lt;Integer&gt;&gt; result) {
        if (curr == nums.length - 1) {
            List&lt;Integer&gt; res = new ArrayList&lt;&gt;();
            for (int num : nums) {
                res.add(num);
            }
            result.add(res);
            return;
        }
        for (int i = curr; i &lt; nums.length; i++) {
            swap(nums, i, curr);
            dfs(curr + 1, nums, result);
            swap(nums, i, curr);
        }
    }

    private void swap(int[] nums, int i, int j) {
        int t = nums[i];
        nums[i] = nums[j];
        nums[j] = t;
    }
}
</code></pre>
<h2 id="2-review">2. Review</h2>
<p><a href="https://engineering.videoblocks.com/these-four-clean-code-tips-will-dramatically-improve-your-engineering-teams-productivity-b5bd121dd150">These four “clean code” tips will dramatically improve your engineering team’s productivity</a> 这四个「整洁代码」的技巧将极大地提高工程团队的生产力</p>
<p>作者列举了整洁代码的四个技巧：</p>
<ul>
<li>
<p>如果没有经过测试，代码就是不合格的</p>
<p>要写大量的测试，特别是单元测试，否则你会后悔的。</p>
</li>
<li>
<p>选择有意义的名字</p>
<p>为变量、类和函数，起一个短小准确的名字。</p>
</li>
<li>
<p>类和函数应该短小，遵循单一职责法则</p>
<p>函数不该超过 4 行，类代码不该超过 100 行。它们做并且只做一件事。</p>
<p>（点评：这里阈值太低，可以适量放大。《阿里巴巴 Java 开发手册》里讲到：方法一般不超过 80 行）</p>
</li>
<li>
<p>函数不该产生副作用</p>
<p>副作用（比如修改输入参数）是魔鬼，代码里面千万不要有，尽可能在函数契约中明确指定这一点。</p>
</li>
</ul>
<h2 id="3-tip">3. Tip</h2>
<p>有时候觉得 IDE 太重量级了，打开个工程都要十几秒。相比之下，Sublime 是轻量级的编辑器，每次几乎秒开，代码显示友好，有丰富的插件。每个程序员都该熟练使用一种 IDE 之外的编辑器，IDE 不总是可靠的，或许也尝试白板编程。</p>
<h2 id="4-share">4. Share</h2>
<p>前些天，有个头条的同行和我聊，说他们面试非常看重基础。基础是什么？我觉得包括这几项：算法和数据结构、操作系统、计算机网络、数据库原理、设计模式等。这些是经久不衰的、不依赖具体语言的基础原理。想要在编程路上走得长远，静下心来研究基础非常必要。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每周 ARTS 第 18 期]]></title>
        <id>https://isuperqiang.cn/post/mei-zhou-arts-di-18-qi</id>
        <link href="https://isuperqiang.cn/post/mei-zhou-arts-di-18-qi">
        </link>
        <updated>2019-08-04T09:41:25.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-algorithm">1. Algorithm</h2>
<h3 id="110-平衡二叉树简单">110. 平衡二叉树（简单）</h3>
<h5 id="描述">描述：</h5>
<blockquote>
<p>给定一个二叉树，判断它是否是高度平衡的二叉树。<br>
本题中，一棵高度平衡二叉树定义为：<br>
一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。</p>
</blockquote>
<h5 id="示例">示例：</h5>
<pre><code>给定二叉树 [3,9,20,null,null,15,7]
    3
   / \
  9  20
    /  \
   15   7
 返回 true
</code></pre>
<h5 id="思路">思路：</h5>
<p>平衡二叉树的条件：</p>
<ul>
<li>左子树是平衡二叉树</li>
<li>右子树是平衡二叉树</li>
<li>左右子树的高度差的绝对值不超过 1</li>
</ul>
<p>深度优先遍历，递归求解树的高度。终止条件是不满足上述三个条件之一，二叉树的最大深度可以参考第 114 题。</p>
<pre><code class="language-java">class Solution {
    public boolean isBalanced(TreeNode root) {
        return height(root) != -1;
    }
    
    private int height(TreeNode root) {
        if (root == null) {
            return 0;
        }
        int leftHeight = height(root.left);
        int rightHeight = height(root.right);
        if (leftHeight == -1 || rightHeight == -1 
                || Math.abs(leftHeight - rightHeight) &gt; 1) {
            return -1;
        }
        return Math.max(leftHeight, rightHeight) + 1;
    }
}
</code></pre>
<h5 id="分析">分析：</h5>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h2 id="2-review">2. Review</h2>
<p><a href="https://maker.pro/linux/tutorial/basic-linux-commands-for-beginners">Basic Linux Commands for Beginners</a> 为新手准备的 Linux 命令</p>
<p>Linux 是免费、开源的操作系统内核，你可以修改 Linux 上的任何东西，并用自己的名字重新发布，比如 Ubuntu、Debian、Red Hat 等版本。</p>
<p>Linux 主要应用于服务器上，世界上 90% 的服务器都运行 Linux 系统，因为它安全、快速并且免费。Android 手机占据智能机的 80%，它也是基于 Linux 内核。大多数的病毒出现在 Windows 上，而不是 Linux。</p>
<p>shell 是一个程序，它接收用户的命令，并传递给系统执行，然后显示结果。Linux 有个命令行界面，是 shell 的主要交互部分。</p>
<p>接下来，作者列举了一些基本的命令：cd/ls/pwd/mkdir/rm/touch/man/cp/mv/cat/sudo/echo/df/vi/tar/apt-get/chmod/ping 等。</p>
<h2 id="3-tip">3. Tip</h2>
<p><a href="https://github.com/robbyrussell/oh-my-zsh">oh my zsh</a> 非常强大的 shell，拥有丰富的插件和主题，只支持 macOS 和 Linux。不愧是终极 Shell，提高 10x 效率没问题。有时候一成不变挺悲哀的，尝试折腾一下才有乐趣。Have a try, you will enjoy it.</p>
<h2 id="4-share">4. Share</h2>
<p>程序员应该学习 Linux，理解设计理想，熟悉常用命令。对于高手来说，一个 Terminal 就够了。在 macOs 或 Linux 下开发，比 Windows 省心多了。首先没有字符编码的问题，其次 Unix-like 平台上有非常多的开发工具，程序员用了绝对爱不释手。另外，Unix-like 平台上的软件不像 Windows 系统上那样流氓，而且不容易感染病毒。值得庆幸的是，Windows 10 内置了 Linux，我们可以下载 Ubuntu 体验。虽然是阉割版，但用来学习够用了。</p>
]]></content>
    </entry>
</feed>