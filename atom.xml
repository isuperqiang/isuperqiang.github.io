<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://isuperqiang.github.io</id>
    <title>落英坠露</title>
    <updated>2021-01-23T04:22:32.741Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://isuperqiang.github.io"/>
    <link rel="self" href="https://isuperqiang.github.io/atom.xml"/>
    <subtitle>生活不止眼前的苟且，还有诗和远方的田野。</subtitle>
    <logo>https://isuperqiang.github.io/images/avatar.png</logo>
    <icon>https://isuperqiang.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 落英坠露</rights>
    <entry>
        <title type="html"><![CDATA[作为程序员的我，核心竞争力是什么]]></title>
        <id>https://isuperqiang.github.io/post/zuo-wei-cheng-xu-yuan-de-wo-he-xin-jing-zheng-li-shi-shi-me/</id>
        <link href="https://isuperqiang.github.io/post/zuo-wei-cheng-xu-yuan-de-wo-he-xin-jing-zheng-li-shi-shi-me/">
        </link>
        <updated>2020-12-15T14:08:12.000Z</updated>
        <content type="html"><![CDATA[<p>在准备面试的过程中，突然想到一个问题：面试这个岗位的人那么多，和其他人相比，你的优势在什么地方，公司为什么要录用你？<br>
在技术水平相当的情况下，很难取舍到底要录用哪个人，这时候个人核心竞争力就发挥作用了。</p>
<p>什么是核心竞争力？核心竞争力就是我们每个人身上，区别于别人的独特“优点”，比如超牛的研发能力、超强的管理能力<br>
、熟练的人际关系处理能力等等，这些就属于一个人的“核心竞争力”。</p>
<p>在工作的这几年中，积累了不少优秀的习惯，这就是我的核心竞争力。下面一一列出来：</p>
<ul>
<li>
<p><strong>万丈高楼平地起</strong></p>
<p>想要成为优秀的程序员，必须具备扎实的计算机基础。基础是最硬核最干的，基础好的人触类旁通，学什么都快。比如，之前遇到过浮点数比较相等不准确，想起来是因为浮点数是用符号位、阶码和尾数的方式表示，它本身就是不精确的，比较相等自然不精确。</p>
</li>
<li>
<p><strong>磨刀不误砍柴工</strong></p>
<p>熟练的手头工具：adb 命令、Linux 命令、Git 命令、IDE 快捷键等等，就像工匠的工具箱。追求高效的程序员都会熟练使用它们，来提升自己的开发效率。在开发中我经常使用终端命令，相比带 GUI 的操作界面，我觉得终端更加 Geek。</p>
</li>
<li>
<p><strong>无规矩不成方圆</strong></p>
<p>内部研发规范有利于降低沟通成本、提升工程质量，包括代码规范、发版规范等。目前公司的研发规范都是由我发起，然后推广到整个部门，规范后研发效能有了很大的提升。另外，积极借鉴外面大厂的经验，比如阿里巴巴的 Java/Android 开发规范。</p>
</li>
<li>
<p><strong>重复工作，事不过三</strong></p>
<p>重复三次以上的无脑劳动尽可能用脚本工具解决，把时间投入到更有价值的事情上，不会“偷懒”的程序员不是好程序员。比如，每次更新动态库，都要进行大量的文件替换，还有打包上传远端仓库，我写了一个 shell 脚本，把要执行的流程代码化，化繁为简。</p>
</li>
<li>
<p><strong>知其然，知其所以然</strong></p>
<p>对于被安排的工作，刨根问底清楚为什么要这么做，后面才是怎么做，不做没有思考能力的执行者。比如，产品经理曾提过在绿幕抠像功能页面加个调色板和取色器，我建议二选一，两个功能一起上一方面是增加使用的复杂度，另一方面是增加开发成本。</p>
</li>
<li>
<p><strong>技术沉淀，知识共享</strong></p>
<p>在技术研发的过程中，总会遇到很多问题，我一般会以文档的方式记录，然后分享到部门内部，避免大家再次踩坑。除此之外，我也会经常更新自己的<a href="https://isuperqiang.cn/">博客</a>，形成自己的技术方法论。持续不断地学习技术，记录学习的内容和所思所想，这或许能帮到后来者。</p>
</li>
<li>
<p><strong>热爱编程，兴趣使然</strong></p>
<p>因为热爱计算机，大学报了计算机专业，虽然中间有曲折，但最终还是走上了编程的道路。大学期间做过不少项目，从前端后端到移动端，接触过不少技术栈。可惜大方向没有把握好，忽略了职业规划，后来走了不少弯路。工作后积极提升技术能力，阅读过很多专业书籍，在这篇文章 <a href="https://isuperqiang.cn/post/tui-jian-gei-cheng-xu-yuan-de-shu-dan/">《给程序员的推荐书单》</a> 中聊过。</p>
</li>
<li>
<p><strong>沉稳干练，做事靠谱</strong></p>
<p>别人交代的事情，尽我所能，竭力完成。在入职第一年的年终总结会上，Tech Leader 对我的评价只有两个字：靠谱。我想这是对我最好的肯定，也是优秀的职业程序员应该做到的。所谓靠谱，就是凡事有交代，件件有着落，事事有回音。</p>
</li>
<li>
<p><strong>勤奋刻苦，踏实肯干</strong></p>
<p>这是骨子里的东西，我从小在农村长大，经历了不少艰难的日子，却从来不向生活低头。工作这几年，早上我是最早到公司的员工，几乎天天如此，晚上和同事一块下班。早到公司，每天就比别人多出来一个多小时，可以用来规划当天的工作、浏览技术文章等。</p>
</li>
<li>
<p><strong>没有最好，只有更好</strong></p>
<p>我承认自己有点代码洁癖，总想把代码写成诗一样。在闲暇之余，会组织代码重构，总是想把作品打磨得尽善尽美。然而，需求总是变化莫测，架构也随之不断迭代，完美的终点并不存在。其实为人也是这样，都想越来越好。</p>
</li>
</ul>
<p>这些都是我的肺腑之言，总结了职业上的行为习惯和价值观，我热爱这份职业，希望这条路走得远一些。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android SDK 开发经验谈]]></title>
        <id>https://isuperqiang.github.io/post/android-sdk-kai-fa-jing-yan-tan/</id>
        <link href="https://isuperqiang.github.io/post/android-sdk-kai-fa-jing-yan-tan/">
        </link>
        <updated>2020-12-09T07:59:35.000Z</updated>
        <content type="html"><![CDATA[<p>在公司做了一年多的 SDK 开发，结合自己的所知所学，分享一些 SDK 开发的经验。</p>
<h3 id="1-sdk-是什么">1. SDK 是什么</h3>
<p>相信做 Android 开发的朋友，一定使用过第三方的 SDK，比如推送 SDK、分享 SDK 等。SDK 的全称是 Software Development Kit，翻译为“软件开发工具包”。SDK 通常是为辅助开发某类软件而编写的特定软件包、框架集合等。</p>
<p>SDK 可以分为系统 SDK 和应用 SDK。所谓系统 SDK 是为使用特定的软件框架、硬件平台等所开发的工具集合。而应用 SDK 则是基于系统 SDK 开发的独立于具体业务、拥有特定功能的工具集合。</p>
<p>SDK 的使用者主要是 B 端客户，最终交付产品是代码、示例和文档，客户接入 SDK 也是和 SDK 提供方交流的过程，对外沟通的成本比对内更高，遇到的问题也会更多。所以 SDK 开发对开发者的要求比对应用开发更高。能开发好 SDK 一定能开发好应用，但能开发好应用，未必能开发好 SDK。</p>
<h3 id="2-sdk-实现目标">2. SDK 实现目标</h3>
<p>SDK 的实现目标，概括来说：简洁、稳定、高效。</p>
<h4 id="简洁">简洁</h4>
<p>对于用户而言，一款好的产品应该是简洁易用的，不该让他们花费太长的时间学习。SDK 也当如此，它不该出现复杂繁琐的对接工作，使用者通过阅读代码和文档，花费很少的时间就能做好 SDK 的对接。</p>
<p>比如当开发者需要使用 SDK 的服务时，只需要在代码中新增一行即可。在项目中初始化 SDK 只要一行代码，开发者不用关心 GLContext，内部已做好处理，也不用关心同步或异步问题。</p>
<pre><code class="language-java">public class FURenderer {
    // 定义    
    public static void setup(Context context) {
        //...
    }
}
// 一行代码调用
FURenderer.setup(context);
</code></pre>
<h4 id="稳定">稳定</h4>
<p>站在 SDK 使用者角度来看，我们期望第三方 SDK 的服务是稳定高效的，体现在提供稳定可靠的服务，同时运行时性能要高效。这就要求我们在设计实现 SDK 时要尽可能做到以下几点：</p>
<ul>
<li>对外提供稳定的 API。SDK 的 API 一旦确定，除非特殊情况不可更改，提供方变更 API 的成本非常大。</li>
<li>对外提供稳定的业务。在提供了稳定的 API 后，必须要有稳定的业务作为支撑。</li>
<li>运行时的稳定。确保 SDK 自身稳定运行，不能出现因为接入了 SDK 而导致宿主应用不稳定的情况。</li>
<li>版本稳定更新。SDK 版本迭代非常缓慢，要尽可能对使用者屏蔽迭代过程，避免带来不必要的适配成本。</li>
</ul>
<h4 id="高效">高效</h4>
<p>无论是普通的应用开发还是 SDK 开发，都应该考虑到性能问题，SDK 设计者要着重考虑以下问题：</p>
<ul>
<li>更少的内存占用。一般 SDK 和 App 运行在同一进程，此时 SDK 要管理好自己占用的内存，合理分配，注意释放。</li>
<li>更少的内存抖动。在占用更少内存的前提下，SDK 设计者必须减少频繁 GC 造成的内存抖动问题。</li>
<li>更少的电量消耗。低电量消耗和高性能表现之间很难做到权衡，可以从 CPU 计算量、屏幕刷新帧率等角度考量。</li>
</ul>
<h3 id="3-sdk-架构设计">3. SDK 架构设计</h3>
<p>SDK 的架构实现决定了后续的维护难度，所以最好能够结合实际业务确定合适的方案。以项目中的模块化开发为例，讲讲架构设计的原则。</p>
<p>遵循面向对象开发的几大原则，目的是达到三个目标：可维护性、可重用性和可扩展性。具体来讲：</p>
<ul>
<li>根据单一职责原则，将系统拆分为多个小模块，每个模块保持相对独立，降低实现类的复杂度。</li>
<li>根据接口隔离原则，为每个模块定义契约接口，接口的粒度要小，功能要细，越细小越易维护。</li>
<li>模块之间通过协议或接口通信，避免直接相互依赖，以降低耦合，互相了解最少，体现了迪米特法则。</li>
<li>根据开闭原则，定义各个模块的公共行为，通过模版方法设计模式提供骨架实现，易于功能扩展。</li>
<li>根据组合优于继承的原则，当多个模块功能叠加时，使用类的组合保证设计的灵活性。</li>
</ul>
<p>比如项目第三方 demo 的功能模块借鉴了 Java 集合框架的架构，分为契约接口、抽象类和具体实现三部分。</p>
<ul>
<li>首先定义 IEffectModule 作为特效的契约接口，包括创建、设置参数、销毁等各个功能模块的公共操作。</li>
<li>AbstractEffectModule 作为 IEffectModule 的骨架实现，实现了共同使用的方法，定义了公共的成员变量。</li>
<li>定义美颜 IFaceBeautyModule 接口，其继承 IEffectModule 接口，包括额外的设置参数操作，FaceBeautyModule 作为其实现类，同时继承 AbstractEffectModule，复用基类的代码。</li>
<li>美妆美体模块类似，先定义契约接口，然后定义具体实现，接口间相互隔离，接口内高度内聚。</li>
<li>FURenderer 实现 IFURenderer 渲染接口和  IModuleManager 模块管理接口，组合各个功能模块。</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20201226180356.png" alt="UML类图" loading="lazy"></figure>
<h3 id="4-sdk-设计规范">4. SDK 设计规范</h3>
<p>API 设计在任何开发中都非常重要，许多时候软件的质量好坏体现在 API 的设计上。在普通的应用开发中，API 只会在开发人员间流通，不会暴露给非本应用开发的其他人员。但是 SDK 作为一种服务，需要向开发者暴露一部分 API，这样才能使用 SDK 的服务。</p>
<p>下面列出一些应该重点关注的原则。</p>
<ol>
<li><strong>方法名表明其用途</strong></li>
</ol>
<p>好的方法名最直观表明它的功能，名字是自解释的，不需要额外的文档，这样做会减少不必要的沟通成本。对于开发者而言，还有什么比直接读代码更直观呢？《重构》一书中讲到，要像给自己孩子起名一样给每个变量命名，这个要求不算过分吧。</p>
<ol start="2">
<li><strong>参数的合法性检验</strong></li>
</ol>
<p>如果程序运行时出现异常，会破坏使用者的体验，影响非常不好。我们采用“防御式编程”的思想，能够避免非法输入对系统的破坏性。</p>
<p>当合法性校验不通过时，针对方法权限不同分别对应不同不同的处理策略:</p>
<ul>
<li>对于公开方法显式检查抛出异常，并使用 <code>@throw</code> 来说明抛出异常的原因</li>
<li>对于私有方法通过断言的方式来检查参数的合法。</li>
<li>检查构造方法的参数的合法性，以使对象处在统一状态。</li>
</ul>
<p>需要注意的是，如果检查的代价太大，那就需要综合考量。</p>
<ol start="3">
<li><strong>方法只实现单一功能</strong></li>
</ol>
<p>一个方法应该具有单一的功能，尽可能做更少、更专的事情，这也是单一职责原则的体现。“阿里巴巴代码规约”规定一个方法<br>
最好不要超过 80 行，对庞大的方法要拆分成更小的。</p>
<p>另外注意，宁可提供小而美的方法也不要提供大而全的方法，大而全的方法往往经常发生变动，产生风险的可能性更高。因此不如提供更小的方法以便组合使用，小而美的方法更易做到代码复用。</p>
<ol start="4">
<li><strong>访问权限控制</strong></li>
</ol>
<p>包括类方法的权限和变量的权限，能声明私有的不要公开，外部知道得越少越好。能声明静态的方法就用静态，静态方法天然线程安全，体现继承关系的用 <code>protected</code> 修饰，确保公开的方法和变量是安全可靠的。</p>
<ol start="5">
<li><strong>避免过长参数</strong></li>
</ol>
<p>过长的参数会造成记忆上困难，还有调用传参容易出错，应当尽力避免。在无法避免过长参数的情况下，考虑其他的方法进行解决:</p>
<ul>
<li>通过使用 Builder 模式来实现</li>
<li>通过将多个参数封装成类对象</li>
</ul>
<p>例如，项目里有个方法，参数非常多。</p>
<pre><code class="language-java">int onDrawFrameSingleInput(byte[] img, int w, int h, int format, byte[] readBackImg, int readBackW, int readBackH);
</code></pre>
<p>重构后，把参数封装成对象，调用方法只用构造一个对象传入，避免大量参数带来不好的体验感。</p>
<pre><code class="language-java">public class VideoFrame {
    private int width;
    private int height;
    private byte[] data;
    private byte[] readback;
    private int readbackWidth;
    private int readbackHeight;
    private int pixelFormat;
    // ...
}

int onDrawFrameSingleInput(VideoFrame videoFrame);
</code></pre>
<ol start="6">
<li><strong>慎用方法重载</strong></li>
</ol>
<p>滥用重载容易让开发者感到疑惑，在需要重载方法的时候，可以使用不同方法名来代替。对于构造函数，可以通过静态工厂来代替重载。</p>
<p>Java 中提供的 ObjectOutputStream 类就是个很好的示范：它的 write 对于每个基本类型都有一个变形，比如写出字符、写出 boolean 等操作。设计者并没有使用重载将其设计成 write(Long l)、write(Boolean b)，而是将其设计为 writeLong(l)、writeBoolean(b)。</p>
<p>例如，项目对外的处理方法全部是重载，只能根据参数区分，迷惑性非常大。修改为不同的方法名后，看到名字就知道要调用的方法，清楚了不少。</p>
<pre><code class="language-java">// 重构前
int onDrawFrame(byte[] img, int tex, int w, int h);
int onDrawFrame(byte[] img, int w, int h)；
// 重构后
int onDrawFrameDualInput(byte[] img, int tex, int w, int h);
int onDrawFrameSingleInput(byte[] img, int w, int h, int format);
</code></pre>
<ol start="7">
<li><strong>避免方法直接返回 null</strong></li>
</ol>
<p>对于需要返回数组或集合的方法，不要返回null。比如我们去买糕点店买面包，面包没了是一种正常状态，就不应该返回 null，而是返回长度为 0 的数组或集合。Java 提供了 <code>Collections.emptyXXX()</code> 表示空集合。</p>
<ol start="8">
<li><strong>避免引入第三方库</strong></li>
</ol>
<p>GitHub有许多开源的第三方库，比如网络请求 OkHttp、图片加载 Glide 等，但在 SDK 开发中，遵循的基本的原则是：</p>
<ul>
<li>最小可用性原则，即用最少的代码，如无必要勿增实体。</li>
<li>最少依赖性原则，即用最低限度的外部依赖，如无必要勿增依赖。</li>
</ul>
<p>引入第三方库可能带来下面几个问题：</p>
<ul>
<li>宿主应用的第三方库和 SDK 依赖的版本不一致，容易引起冲突，增加对接的成本。</li>
<li>开源库不断更新，SDK 也要及时更新，增加额外的维护工作量。</li>
<li>由于引入开源库，出现问题难以排查。</li>
</ul>
<ol start="9">
<li><strong>保证兼容性</strong></li>
</ol>
<p>SDK 是不断迭代的，每次发布都会有新功能和 bug 修复。对于使用者来说，升级版本不该有太大的改动，一般直接替换库文件或者修改远程依赖库的版本号就够了。避免直接对公开接口的重命名，如果旧接口废弃，要通过 <code>@Deprecated</code> 关键字标明，并给出替代方案和废弃的时间。</p>
<ol start="10">
<li><strong>减少入侵性</strong></li>
</ol>
<p>要保证较少的代码侵入主要在对外提供服务时，充分考虑开发者的使用场景来设计优良的 API。一套优良的 API 在定义时要满足绝大数开发者预期的方式——语义上要求通俗易懂，使用上要求简单可靠。具体的表现是，在正常情况下能够稳定可靠地运行，在异常情况下及时地反馈错误信息。</p>
<p>比如使用 Gradle 下载依赖库，AAR 包中有不必要的 bundle 资源，我们提供了打包 apk 时的构建配置，自由选择要打包的 bundle，减少了对宿主应用的侵入性。</p>
<pre><code class="language-groovy">    applicationVariants.all { variant -&gt;
        variant.mergeAssetsProvider.configure {
            doLast {
                delete(fileTree(dir: outputDir,
                        // 删除不必要的 bundle 文件
                        includes: ['model/ai_face_processor_lite.bundle',
                                   'model/ai_gesture.bundle',
                                   'graphics/controller.bundle',
                                   'graphics/tongue.bundle']))
            }
        }
    }
</code></pre>
<h3 id="5-sdk-交付">5. SDK 交付</h3>
<h4 id="封装包">封装包</h4>
<p>Android 平台通常使用 jar 和 aar 发布 SDK，区别是 jar 只包含代码，aar 可以包含代码、资源和动态库。一般而言 aar 是最合适的交付方式，把它上传到 maven 服务器，使用者就可以一行代码集成。对于需要灵活定制的客户，我们也会提供 SDK 的源码，弊端就是升级困难，要改动很多的代码。</p>
<p>对于代码混淆，公开接口和 native 使用的接口不要混，内部的实现细节可以混淆，以减少 SDK 包的大小。</p>
<h4 id="接入文档">接入文档</h4>
<p>接入文档用来告诉 SDK 使用者，如何使用 SDK、详细步使用骤和可能发生的问题。文档内容包括：更新记录、基本信息、API 说明、集成步骤、FAQ等。好文档的标准就是清晰明了，通俗易懂。一个完全不懂 SDK 的开发者看着文档就能对接，对于经常遇到的问题要逐条列出，专业名词要有对应的解释。</p>
<h4 id="demo-示例">Demo 示例</h4>
<p>集成 Demo 通常是一个简单的 App，用来展示如何快速地接入 SDK。Demo 的源码托管到 GitHub，方便使用者参考，其版本变更策略和 SDK 版本的变化保持一致。尽管是个 Demo，它的开发原则也要与 SDK 一致，确保高质量的交付。</p>
<p><strong>参考文章：</strong></p>
<ul>
<li><a href="https://lionoggo.blog.csdn.net/article/details/53558011">随想录:开发一流Android SDK</a></li>
<li><a href="https://juejin.cn/post/6844904100077764622">Android SDK开发规范整理</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/113505249">Android SDK 开发经验浅谈</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用Android架构组件Lifecycle优化代码]]></title>
        <id>https://isuperqiang.github.io/post/shi-yong-android-jia-gou-zu-jian-lifecycle-you-hua-dai-ma/</id>
        <link href="https://isuperqiang.github.io/post/shi-yong-android-jia-gou-zu-jian-lifecycle-you-hua-dai-ma/">
        </link>
        <updated>2020-11-10T23:23:34.000Z</updated>
        <content type="html"><![CDATA[<p>Android developers 提供的支持库越来越完善，不知大家在开发中有没有升级 <a href="https://developer.android.com/jetpack">Jetpack</a>，也就是引入 androidX 包，Jetpack 确实简化了代码，提升了效率。下面介绍架构组件中的 Lifecycle，官网的介绍：<a href="https://developer.android.com/topic/libraries/architecture/lifecycle">使用生命周期感知型组件处理生命周期</a> 非常详细，我就介绍一下 Lifecycle 在开发中的实践。</p>
<h3 id="1-重构之前">1. 重构之前</h3>
<p>项目中有许多组件和 Activity 的生命周期有关联，比如 SensorManager 在 resume 时注册，pause 时解除注册。Camera 在 resume 时打开，pause 时关闭等。代码写起来就像下面这样：</p>
<pre><code class="language-java">    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        mSensorManager = (SensorManager) getSystemService(SENSOR_SERVICE);
        mSensor = mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);
    }   

    @Override
    protected void onResume() {
        super.onResume();
        mSensorManager.registerListener(this, mSensor, SensorManager.SENSOR_DELAY_NORMAL);
      // manage other components that need to respond
            // to the activity lifecycle
    }

    @Override
    protected void onPause() {
        super.onPause();
        mSensorManager.unregisterListener(this);
      // manage other components that need to respond
            // to the activity lifecycle
    }
</code></pre>
<p>如果需要响应 Activity 生命周期的组件非常多，那么代码将变得非常臃肿难以维护。组件对外暴露的状态接口太多，稍不留神就会出错，这种转发式的调用并不是优雅的做法。</p>
<h3 id="2-重构之后">2. 重构之后</h3>
<p>抽离 Sensor 相关代码形成新类，封装 Sensor 注册、解除注册和监听操作，最重要的是可感知生命周期。本质上是观察者设计模式，Activity 是 LifecycleOwner，具有 Lifecycle，是被观察者；LifeCycleSensorManager 实现 LifecyclerObserver 接口，是观察者。外部不需要传递生命周期状态进来，LifeCycleSensorManager 内部可感知生命周期。这样使用时，只要一行代码即可，非常干净清爽。</p>
<pre><code class="language-java">public final class LifeCycleSensorManager implements LifecycleObserver, SensorEventListener {
    private Sensor mSensor;
    private SensorManager mSensorManager;
    private Lifecycle mLifecycle;

    public LifeCycleSensorManager(final Context context, final Lifecycle lifecycle) {
        mSensorManager = (SensorManager) context.getSystemService(Context.SENSOR_SERVICE);
        mSensor = mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);
        lifecycle.addObserver(this);
        mLifecycle = lifecycle;
    }

    @OnLifecycleEvent(Lifecycle.Event.ON_RESUME)
    public void onResume() {
        mSensorManager.registerListener(this, mSensor, SensorManager.SENSOR_DELAY_NORMAL);
    }

    @OnLifecycleEvent(Lifecycle.Event.ON_PAUSE)
    public void onPause() {
        mSensorManager.unregisterListener(this);
    }

    @OnLifecycleEvent(Lifecycle.Event.ON_DESTROY)
    public void onDestroy() {
        mLifecycle.removeObserver(this);
    }

    @Override
    public void onSensorChanged(SensorEvent event) {
    }

    @Override
    public void onAccuracyChanged(Sensor sensor, int accuracy) {
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[给程序员的推荐书单]]></title>
        <id>https://isuperqiang.github.io/post/tui-jian-gei-cheng-xu-yuan-de-shu-dan/</id>
        <link href="https://isuperqiang.github.io/post/tui-jian-gei-cheng-xu-yuan-de-shu-dan/">
        </link>
        <updated>2020-10-29T16:19:40.000Z</updated>
        <content type="html"><![CDATA[<p>工作这么多年，虽然平时加班很多，但闲暇时间依然会读书。在我看来，读书并实践是成长的最有效途径。读书提升认知，实践改变行为，所谓知行合一。细细数来，读过不少的好书，有技术类的，也有非技术类的。下面推荐一些我认为值得读的好书：</p>
<h4 id="1-技术类">1. 技术类</h4>
<ul>
<li><a href="https://book.douban.com/subject/2130190/">Java 编程思想（第4版）</a> Java 的“圣经”级作品，包含编程思想和设计模式，从宏观视角讲解 Java 语言，经典之作值得反复阅读，适合进阶，入门级就不要看了。</li>
<li><a href="https://book.douban.com/subject/30412517/">Effective Java（第3版）</a>  Java 开发的规范，或者说最佳实践，实在的经验之谈，格外关注细节，重在培养优秀的编程习惯，同样值得拜读多次，同样适合进阶。</li>
<li><a href="https://book.douban.com/subject/10484692/">Java 并发编程实战</a> 深入 Java 并发的必读之作，一本完美的 Java 并发参考手册，JUC 源码的作者 Doug Lea 也是该书作者之一。</li>
<li><a href="https://book.douban.com/subject/2243615/">Head First 设计模式</a> 介绍了 GoF 提出的 23 种设计模式，配合插画和案例，读起来不觉枯燥，非常生动有趣，适合入门设计模式。</li>
<li><a href="https://book.douban.com/subject/25708312/">C++ Primer（第5版）</a>  经典的 C++ 教程，采用 C++11 标准编写，最近正在读，很厚的一本书。</li>
<li><a href="https://book.douban.com/subject/26912767/">深入理解计算机系统（第3版）</a> 简称“CSAPP”，程序员的必读书，详细描绘了计算机系统的实现细节，不懂底层的程序员称不上是合格的程序员。此书非常硬核，有些概念要反复理解。</li>
<li><a href="https://book.douban.com/subject/1477390/">代码大全（第2版）</a> 写代码不该局限于砌墙，更高远的是建设软件大厦。这本书介绍了软件构建的流程，还包括其中的细节和技巧，高屋建瓴，是提升编程认知的好书。</li>
<li><a href="https://book.douban.com/subject/4262627/">重构</a> 代码重构非常好的指导书，里面有许多非常规的观点和技巧，读完后你会发现项目里有太多坏代码等着修改，重构是为了使代码变得更好。</li>
<li><a href="https://book.douban.com/subject/30333948/">码出高效：Java 开发手册</a> 阿里大佬写的书，比较大众化，都是基础性的内容，总结了一些实战经验，打牢基础总没错。</li>
<li><a href="https://book.douban.com/subject/30358046/">Android 进阶解密</a> 和 <a href="https://book.douban.com/subject/26599538/">Android 开发艺术探索</a> 都是非常好的 Android 进阶书，知识面有深度和广度，也是高级工程师必备的技能。</li>
</ul>
<p>这里有份 <a href="https://m.douban.com/subject_collection/5185">豆瓣热门编程图书 Top10</a>，如果不知道怎么选，多读经典总是没错的。</p>
<h4 id="2-非技术">2. 非技术</h4>
<ul>
<li><a href="https://book.douban.com/subject/24868904/">高效能程序员的修炼</a> coding horror 博客中的精选文章集合，除了技术之外，还有职业规划、团队协作、高效工作环境等，软件开发远不是只写代码那么简单，程序员的软技能和硬技能一样重要。从这本书中可以读到骨灰级程序员的真知灼见。</li>
<li><a href="https://book.douban.com/subject/26835090/">软件能</a> 始于代码，不止代码。这本书介绍了程序员的发展的多个方面，职业、营销、学习、理财、健身等，读完真的是刷新认知。程序员不是呆子，我们的人生有多种可能性。</li>
<li><a href="https://book.douban.com/subject/1152111/">程序员修炼之道</a> 程序员的基本修养，包括软件编程、职业发展、工作习惯等方面。学校只会教你怎么写代码，不会教你软技能，这本书就是很好的指导。不要埋头写代码，抬头看路才能走对方向。</li>
</ul>
<p>技术类的书籍提升我们的硬技能，进而提升职业专业性。非技术类的书籍提升我们的软技能，少走弯路从而走得更远。</p>
<p>另外说一点，好书值得反复读，每读一遍都会有新的收获，愿你的职业发展越走越好。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android I/O 那些事儿]]></title>
        <id>https://isuperqiang.github.io/post/android-io-na-xie-shi-er/</id>
        <link href="https://isuperqiang.github.io/post/android-io-na-xie-shi-er/">
        </link>
        <updated>2020-10-01T04:47:01.000Z</updated>
        <summary type="html"><![CDATA[<p>I/O 操作是编程离不开的话题，它不仅是读写那么简单，还涉及底层的文件系统和存储设备。I/O 的快慢影响程序的执行效率，这篇文章主要介绍 Android 平台 I/O 的方式和使用场景。</p>
]]></summary>
        <content type="html"><![CDATA[<p>I/O 操作是编程离不开的话题，它不仅是读写那么简单，还涉及底层的文件系统和存储设备。I/O 的快慢影响程序的执行效率，这篇文章主要介绍 Android 平台 I/O 的方式和使用场景。</p>
<!-- more -->
<h3 id="1-linux-io-的基本组成">1. Linux I/O 的基本组成</h3>
<p>众所周知，Android 基于 Linux 系统，先介绍一些 Linux 上 I/O 的知识。</p>
<p>I/O 操作由应用程序、文件系统和磁盘共同完成，应用程序将 I/O 命令发送给文件系统，文件系统在合适的时间把 I/O 指令发送给磁盘。I/O 的流程如下图：</p>
<figure data-type="image" tabindex="1"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20190603080604.png" alt="I/O操作" loading="lazy"></figure>
<p>CPU 和内存的速度比磁盘快得多，I/O 操作的瓶颈在于磁盘的性能。为了降低磁盘对应用程序的影响，文件系统要进行各种各样的优化。</p>
<h4 id="文件系统">文件系统</h4>
<p>简单来说，文件系统就是存储和组织数据的方式。应用程序调用 read() 方法，系统会通过中断从用户空间进入内核空间，然后经过虚拟文件系统、具体文件系统、页缓存。</p>
<figure data-type="image" tabindex="2"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20190603081904.png" alt="Linux-I/O架构" loading="lazy"></figure>
<ul>
<li>虚拟文件系统（VFS）。主要用于屏蔽具体的文件系统，为应用程序的操作提供一个统一的接口。</li>
<li>文件系统（File System）。ext4、F2FS 都是具体文件系统实现。每个文件系统都有适合自己的场景。</li>
<li>页缓存（Page Cache）。文件系统对数据的缓存，读文件时先检查页缓存，如果命中就不去读磁盘。</li>
</ul>
<h4 id="磁盘">磁盘</h4>
<p>磁盘指的是系统的存储设备，常见的有机械硬盘、固态硬盘等。如果发现应用程序要读的数据没有在页缓存中，这时候就需要真正向磁盘发起 I/O 请求。磁盘 I/O 的过程要先经过内核的通用块层、I/O 调度层、设备驱动层，最后才会交给具体的硬件设备处理。</p>
<figure data-type="image" tabindex="3"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20190603082924.png" alt="磁盘架构" loading="lazy"></figure>
<ul>
<li>通用块层。接收上层发出的磁盘请求，并最终发出 I/O 请求。它与 VPS 的作用类似。</li>
<li>I/O 调度层。根据设置的调度算法对请求合并和排序。不能接收到磁盘请求就立刻交给驱动层处理。</li>
<li>块设备驱动层。根据具体的物理设备，选择对应的驱动程序，通过操控硬件设备完成最终的 I/O 请求。</li>
</ul>
<h3 id="2-android-上的-io">2. Android 上的 I/O</h3>
<p>Android 现在普遍使用的是 Linux 常用的 ext4 文件系统。F2FS（Flash-Friendly File System）是三星为闪存研发的文件系统，它针对闪存进行了大量优化，F2FS 文件系统在小文件的随机读写方面比 ext4 更快。随着 Google、华为的投入和使用，F2FS 应该会成为 Android 主流的文件系统。</p>
<p>Android 手机使用闪存作为存储设备，也就是我们常说的 ROM。前几年闪存通常使用 eMMC 标准，近年来采用性能更好的 UFS 2.0/2.1 标准。手机存储也朝着体积更小、功耗更低、速度更快、容量更大的方向发展，闪存的随机读写速度甚至比 SSD 还快。</p>
<h4 id="手机变卡">手机变卡</h4>
<p>Android 手机用久了会变卡，除了系统升级、设备折旧等因素，还和 I/O 有密切关系。I/O 操作变慢的原因有下面几条：</p>
<ul>
<li>内存不足。系统回收 Page Cache 和 Buffer Cache 的内存，大部分的写操作会直接落盘，导致性能低下。</li>
<li>写入放大。闪存重复写入需要先进行擦除，一次写入会引起整个块数据的迁移，导致写入时间非常久。</li>
<li>设备性能差。在高负载的情况下容易出现瓶颈。</li>
</ul>
<h4 id="文件损坏">文件损坏</h4>
<p>文件损坏是令人头疼的问题，大多是由不正确的操作导致的。文件损坏的原因可以从应用程序、文件系统和磁盘三个角度来分析：</p>
<ul>
<li>应用程序。大部分的 I/O 方法都不是原子操作，文件的跨进程或者多线程写入、使用一个已经关闭的文件描述符 fd 来操作文件，都有可能导致数据被覆盖或者删除。</li>
<li>文件系统。虽说内核崩溃或者系统突然断电都有可能导致文件系统损坏，不过文件系统也做了很多的保护措施。例如 system 分区保证只读不可写，增加异常检查和恢复机制。</li>
<li>磁盘。手机上使用的闪存是电子式的存储设备，所以在资料传输过程可能会发生电子遗失等现象导致数据错误。</li>
</ul>
<h3 id="3-io-的三种方式">3. I/O 的三种方式</h3>
<p>I/O 有三种方式：标准 I/O、mmap 和 Direct I/O。</p>
<figure data-type="image" tabindex="4"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20190604090403.png" alt="I/O的方式" loading="lazy"></figure>
<h4 id="标准-io">标准 I/O</h4>
<p>应用程序平时用到 read/write 操作都属于标准 I/O，也就是缓存 I/O（Buffered I/O）。它的关键特性有：</p>
<ul>
<li>对于读操作，当应用程序读取某块数据时，如果这块数据已经在页缓存中，那么就不需要经过物理读盘操作。</li>
<li>对于写操作，应用程序会先将数据写到页缓存中去，不需要等全部数据被写回磁盘，系统会定期将页缓存中的数据刷到磁盘上。</li>
</ul>
<p>缓存 I/O 可以很大程度减少真正读写磁盘的次数，从而提升性能。但是延迟写机制可能会导致数据丢失。在实际应用中，如果某些数据非常重要，我们应该采用同步写机制。</p>
<p>读操作时，数据会先从磁盘拷贝到 Page Cache 中，然后再从 Page Cache 拷贝到应用程序的用户空间，这样就会多一次内存拷贝。内存相对磁盘是高速设备，即使多拷贝一次，也比真正读一次硬盘要快。</p>
<h4 id="mmap">mmap</h4>
<p>mmap 把文件映射到进程的地址空间，提高了 I/O 的性能。</p>
<p>mmap 的优点有：</p>
<ul>
<li>减少系统调用。只需要一次 mmap() 系统调用，后续所有的调用像操作内存一样。</li>
<li>减少数据拷贝。mmap 只需要从磁盘拷贝一次，由于做过内存映射，不需要再拷贝回用户空间。</li>
<li>可靠性高。mmap 把数据写入页缓存后，跟缓存 I/O 的延迟写机制一样。</li>
</ul>
<p>存在的缺点：</p>
<ul>
<li>虚拟内存增大。Apk、Dex、so 都是通过 mmap 读取。mmap 会导致虚拟内存增大，mmap 大文件容易出现 OOM。</li>
<li>磁盘延迟。mmap 通过缺页中断向磁盘发起真正的磁盘 I/O，不能通过 mmap 消除磁盘 I/O 的延迟。</li>
</ul>
<p>在 Android 中可以将文件通过 <a href="https://developer.android.com/reference/android/os/MemoryFile">MemoryFile</a> 或者 <a href="https://developer.android.com/reference/java/nio/MappedByteBuffer">MappedByteBuffer</a> 映射到内存，然后进行读写，使用这种方式对于小文件和频繁读写操作的文件还是有一定优势的。</p>
<p>mmap 比较适合对同一块区域频繁读写的情况，推荐使用 I/O 线程来操作。用户日志、数据上报都满足这种场景，另外需要跨进程同步的时候，mmap 也是一个不错的选择。Android 跨进程通信有自己独有的 Binder 机制，它内部也是使用 mmap 实现。</p>
<h4 id="direct-io">Direct I/O</h4>
<p>一些数据库自己实现了数据和索引的缓存管理，对页缓存的依赖没那么强烈。它们想绕开页缓存机制，减少一次数据拷贝，它的数据也不会污染页缓存。</p>
<p>直接 I/O 访问文件方式减少了一次数据拷贝和一些系统调用的耗时，很大程度降低了 CPU 的使用率以及内存的占用。负面影响就是读写操作都是同步执行，导致应用程序等待。</p>
<h3 id="4-同步与异步-io">4. 同步与异步 I/O</h3>
<p>多线程阻塞式在 I/O 操作上的并没有优势，I/O 操作的主要瓶颈在于磁盘带宽。所以 I/O 操作不能开大量的线程。</p>
<p>NIO 是非阻塞 I/O，将 I/O 以事件的方式通知，可以减少线程切换的开销。NIO 的最大作用不是减少读取文件的耗时，而是最大化提升应用整体的 CPU 利用率。</p>
<p>另外，非常推荐 Square 的 <a href="https://github.com/square/okio">Okio</a>，它支持同步和异步 I/O，也做了比较多的优化。</p>
<p>I/O 优化对提升应用的体验非常有用，希望上面所讲的内容对你有帮助。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android 图像绘制与渲染原理分析]]></title>
        <id>https://isuperqiang.github.io/post/android-tu-xiang-hui-zhi-yu-xuan-ran-yuan-li-fen-xi/</id>
        <link href="https://isuperqiang.github.io/post/android-tu-xiang-hui-zhi-yu-xuan-ran-yuan-li-fen-xi/">
        </link>
        <updated>2020-09-18T04:50:33.000Z</updated>
        <summary type="html"><![CDATA[<p>UI 开发是 Android 中的基本操作，优美绚丽的界面是最容易打动人的。但是，Android 的碎片化太严重，各种硬件层出不穷，为了实现设计师妹子的效果，再苦再累也是值得。下面我会介绍 Android 绘制的内容，知其所以然很重要。</p>
]]></summary>
        <content type="html"><![CDATA[<p>UI 开发是 Android 中的基本操作，优美绚丽的界面是最容易打动人的。但是，Android 的碎片化太严重，各种硬件层出不穷，为了实现设计师妹子的效果，再苦再累也是值得。下面我会介绍 Android 绘制的内容，知其所以然很重要。</p>
<!-- more -->
<h3 id="1-屏幕与适配">1. 屏幕与适配</h3>
<p>对于屏幕碎片化问题，Android 推荐使用 dp 作为尺寸单位，首先要了解 dp、px、density 等概念。</p>
<figure data-type="image" tabindex="1"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/e3094e900dccacb9d9e72063ca3084ce.png" alt="Android屏幕尺寸概念" loading="lazy"></figure>
<p>使用 dp 是 Android 推荐的屏幕适配方式，但是以下存在问题：dpi 与 ppi 不一致导致控件大小不统一。</p>
<p>目前业界常用的 UI 适配方法主要有下面几种：</p>
<ul>
<li>限制符适配。包括宽高限定符和 smallestWidth 限定符适配，可以参考：<a href="https://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650826381&amp;idx=1&amp;sn=5b71b7f1654b04a55fca25b0e90a4433&amp;chksm=80b7b213b7c03b0598f6014bfa2f7de12e1f32ca9f7b7fc49a2cf0f96440e4a7897d45c788fb&amp;scene=21#wechat_redirect">Android 目前稳定高效的UI适配方案</a></li>
<li>今日头条适配方案。通过反射修改系统的 density，可以参考 <a href="https://mp.weixin.qq.com/s/oSBUA7QKMWZURm1AHMyubA">一种极低成本的Android屏幕适配方式</a></li>
</ul>
<h3 id="2-cpu-与-gpu">2. CPU 与 GPU</h3>
<p>UI 渲染依赖两个核心硬件：CPU 和 GPU。UI 组件在绘制到屏幕之前，需要经过栅格化操作，而栅格化非常耗时。GPU 主要用于处理图形运算，可以加快栅格化的过程。</p>
<figure data-type="image" tabindex="2"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/1c94e50372ff29ef68690da92c6b468d.png" alt="软硬件绘制" loading="lazy"></figure>
<p>对于硬件绘制，Android 使用 OpenGL 在 GPU 上完成，OpenGL 是扩平台的图形 API，为 2D/3D 图形处理硬件制定了标准的软件接口。软件绘制使用的是 Skia 库，它能在低端设备上呈现高质量的 2D 跨平台图形。</p>
<h3 id="3-渲染">3. 渲染</h3>
<p>Android 图形系统的整体架构和它包含的主要组件。</p>
<figure data-type="image" tabindex="3"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/7efc5431b860634224f1cd7dda8abd66.png" alt="Android图形系统" loading="lazy"></figure>
<p>如果把应用程序图形渲染过程当作一次绘画过程。那么绘画过程中，Android 的各个图形组件的作用是：</p>
<ul>
<li>
<p>画笔：Skia 或者 OpenGL。我们可以用 Skia 画笔绘制 2D 图形，也可以用 OpenGL 来绘 制2D/3D图形。正如前面所说,前者使用CPU绘制,后者使用 GPU 绘制。</p>
</li>
<li>
<p>画纸：Surface。所有的元素都在 Surface 这张画纸上进行绘制和渲染。在 Android 中，Window 是 View 的容器，每个窗口都会关联一个 Surface。而 Windowmanager 则负责管理这些窗口，并且把它们的数据传递给 Surfaceflinger。</p>
</li>
<li>
<p>画板：Graphic Buffer。Graphic Buffer 缓冲用于应用程序图形的绘制，在 Android 4.1 之前使用的是双冲机制；在 Android 4.1 之后，使用的是三缓冲机制。</p>
</li>
<li>
<p>显示：Surfaceflinger。它将 Windowmanager 提供的所有 Surface，通过硬件合成器 Hardware Composer 合成并输出到显示屏。</p>
</li>
</ul>
<h3 id="4-硬件加速">4. 硬件加速</h3>
<p>从 Android 3.0 开始，支持硬件加速，到 4.0 时，默认开启硬件加速。</p>
<figure data-type="image" tabindex="4"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/79c315275abac0823971e5d6b9657be8.png" alt="硬件加速绘制" loading="lazy"></figure>
<p>硬件加速绘制与软件绘制整个流程差异非常大，最核心就是我们通过 GPU 完成 Graphic Buffer 的内容绘制。此外硬件绘制还引入了ー个 Display List 的概念，每个 View 内部都有个 Displaylist，当某个 View 需要重绘时，将它标记为 Dirty。</p>
<p>当需要重绘时，仅仅只需要重绘一个 View 的 Display List，而不是像软件绘制那样需要向上递归。这样可以大大减少绘图的操作数量，因而提高了渲染效率。</p>
<p>硬件加速大大提高来 Android 系统显示和刷新的速度，但是也存在一些问题：一方面内存消耗，OpenGL API 和Graphic Buffer 缓冲区占用内存。还存在兼容性问题。</p>
<p><a href="https://source.android.com/devices/graphics">官方文档</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[深入理解 Java 中的 override 和 overload]]></title>
        <id>https://isuperqiang.github.io/post/shen-ru-li-jie-java-zhong-de-override-he-overload/</id>
        <link href="https://isuperqiang.github.io/post/shen-ru-li-jie-java-zhong-de-override-he-overload/">
        </link>
        <updated>2020-08-20T03:25:13.000Z</updated>
        <summary type="html"><![CDATA[<p>override 和 overload，分别翻译为覆写和重载，是 Java 多态（Polymorphism）的两种代表类型。下面详细分析一下 override 和 overload 的使用方式。</p>
]]></summary>
        <content type="html"><![CDATA[<p>override 和 overload，分别翻译为覆写和重载，是 Java 多态（Polymorphism）的两种代表类型。下面详细分析一下 override 和 overload 的使用方式。</p>
<!-- more -->
<h3 id="1-override">1. override</h3>
<p>override 出现在继承关系中，子类覆写父类的实例方法，为它提供专门的实现。举个例子：</p>
<pre><code class="language-java">public class Animal {
    public void bark() {
        System.out.println(&quot;动物叫声&quot;);
    }
}

public class Cat extends Animal {
    @Override
    public void bark() {
        System.out.println(&quot;喵喵&quot;);
    }
}

    public static void main(String[] args) {
        // 向上转型
				Animal cat = new Cat();
        cat.bark(); // 打印 喵喵
    }
</code></pre>
<p>override 的绑定发生在运行期，属于动态绑定，由实例对象决定调用哪个方法，动态绑定是多态性得以实现的重要因素。这里有几点需要注意的地方：</p>
<ul>
<li>子类的方法访问权限只能相同或变大。比如父类方法是 protected，子类可以是 public，不能是 private。</li>
<li>抛出异常和返回值只能变小，它们能够转型成父类对象。比如父类方法返回值 Number，子类可以返回 Integer，不能返回 Object。</li>
<li>方法签名必须完全相同。方法签名包括方法名称和参数列表，是 JVM 标识方法的唯一索引，不包括返回值，其中参数列表分为类型和个数。</li>
<li>覆写方法必须要加上 <code>@Override</code> 注解，为了使编译器自动检查覆写是否满足规则。</li>
</ul>
<p>覆写只能用于类的不被 final 和 private 修饰的实例方法，不能用于静态方法，如果父类和子类中存在同名的静态方法，那么两者都可以被正常调用。</p>
<h3 id="2-overload">2. overload</h3>
<p>overload 出现在同一个类中，多个方法具有相同名字、不同的参数。举个例子：</p>
<pre><code class="language-java">public class Cat {
    public void bark() {
        System.out.println(&quot;喵喵&quot;);
    }

    public void bark(int num) {
        for (int i = 1; i &lt;= num; i++) {
            System.out.println(&quot;第 &quot; + i + &quot; 声喵喵&quot;);
        }
    }
}
</code></pre>
<p>overload 的绑定发生在编译期，属于静态绑定，由方法签名决定调用哪个方法。需要注意的是，方法签名包括方法名称、参数类型和个数，不包括返回值。</p>
<p>当重载的方法参数比较复杂时，JVM 选择合适的目标方法的顺序如下：</p>
<ul>
<li>精确匹配</li>
<li>如果是基本数据类型，自动转换成更大表示范围的基本类型</li>
<li>通过自动拆箱与装箱</li>
<li>通过子类向上转型继承路线依次匹配</li>
<li>通过可变参数匹配</li>
</ul>
<p>下面通过例子说明。</p>
<ol>
<li>基本数据类型优先于包装数据类型。</li>
</ol>
<pre><code class="language-java">    public void mo(int a) {
        System.out.println(&quot;primary int type&quot;);
    }

    public void mo(Integer a) {
        System.out.println(&quot;wrapper int type&quot;);
    }

    Cat cat = new Cat();
    cat.mo(1); // 打印 primary int type
</code></pre>
<ol start="2">
<li>更大范围的基本数据类型优先于包装数据类型。</li>
</ol>
<pre><code class="language-java">    public void mo(long a) {
        System.out.println(&quot;primary long type&quot;);
    }

    public void mo(Integer a) {
        System.out.println(&quot;wrapper int type&quot;);
    }
    
    Cat cat = new Cat();
    cat.mo(1); // 打印 primary long type
</code></pre>
<ol start="3">
<li>null 可以匹配任何类对象，从最底层子类依次向上查找。</li>
</ol>
<pre><code class="language-java">    public void mo(Integer a) {
        System.out.println(&quot;wrapper int type&quot;);
    }

    public void mo(Object a) {
        System.out.println(&quot;object type&quot;);
    }

//  如果包含 String 参数，那么编译器不知道匹配哪个，直接报错。
//  public void mo(String s) {
//      System.out.println(&quot;string type&quot;);
//  }

    Cat cat = new Cat();
    cat.mo(null); // 打印 wrapper int type
</code></pre>
<ol start="4">
<li>自动装箱和拆箱优先于可变参数。</li>
</ol>
<pre><code class="language-java">    public void mo(Integer a, Integer b){
        System.out.println(&quot;double wrapper int type&quot;);
    }

    public void mo(int... a) {
        System.out.println(&quot;primary int array type&quot;);
    }
    
    Cat cat = new Cat();
    cat.mo(1, 2); // 打印 double wrapper int type
</code></pre>
<p>...</p>
<p>重载的参数类型应该简洁些，这样才能提高代码的可读性。</p>
<h3 id="3-总结">3. 总结</h3>
<p>override 和 overload 有很多不同之处：</p>
<ul>
<li>override 属于动态绑定，在运行期通过实例对象决定调用的方法；overload 属于静态绑定，在编译期通过方法签名决定调用的方法。</li>
<li>override 基于继承关系，需要父类和子类参与；overload 出现在同一个类中，通过方法签名区分。</li>
<li>static、final、private 方法不能被 override，但是可以被 overload。</li>
<li>override 关注方法返回值，overload 不关注返回值。</li>
<li>override 的方法参数必须一样，overload 的方法参数必须不同。</li>
<li>overload 的性能比 override 更好些，应为它是静态绑定。</li>
</ul>
<p><strong>参考：</strong></p>
<ul>
<li>《码出高效：Java开发手册》</li>
<li><a href="https://stackoverflow.com/questions/19017258/static-vs-dynamic-binding-in-java">Static Vs. Dynamic Binding in Java</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[一个 CS 科班生的编程之路]]></title>
        <id>https://isuperqiang.github.io/post/wo-de-bian-cheng-zhi-lu/</id>
        <link href="https://isuperqiang.github.io/post/wo-de-bian-cheng-zhi-lu/">
        </link>
        <updated>2020-07-02T09:31:14.000Z</updated>
        <content type="html"><![CDATA[<p>上大学之前，我没有接触过编程，用电脑就是玩玩游戏，上个网啥的。对电脑有这么点兴趣，就报了计算机科学与技术专业（也叫 CS），从此走上了敲代码的不归路…</p>
<p>大一的课程就有 C 语言，操作性非常强，要上机考试，题目是写个函数做数学运算。我觉得用 C 语言作为编程入门并不合适，因为它不如 Java、Python 等语言高级（这里的高级是指对开发者友好），光是指针就把人搞得晕晕乎乎。C 是非常接近底层的语言，开发操作系统、硬件驱动还行，没有人拿它来做应用层。做不出简单的小应用，比如小游戏或者网页，就缺少及时的正向反馈，所以大家都没有学习的兴趣。</p>
<p>之后学习了 web  开发，俗称前端，做过几个小网站，慢慢体会了编程的乐趣，这期间用的是 HTML、CSS、JavaScript、PHP。网页其实就是一种经过排版的文档，浏览器就是解释器，HTML 和 CSS 就是排版工具，它们的属性超级多，组合的样式也十分丰富。</p>
<p>JavaScript 能让这些静态的页面动起来，网页的交互也变得更加炫酷。作为 GitHub 上最受欢迎的语言，JavaScript 十分傲娇，各种框架层出不穷。PHP 是后端的脚本语言，这里不讨论它是不是最好的语言，给我的感觉就是不愠不火，比起 JavaScript 低调不少。</p>
<p>下面 Java 登场了，这门课叫「面向对象程序设计」，至今我面向的只有屏幕，请问哪来的对象 (-｡-;。言归正传，到目前，我认为 Java 是综合能力最强的编程语言，虚拟机的存在保证了安全性和跨平台，活跃的社区和庞大的开源库让开发者无后顾之忧。长盛不衰的 Java 后端主要用来构建企业级应用，近些年流行的 Android 也采用 Java 开发，这才是工业级的编程语言。</p>
<p>那时候对 Java 没上心，外面的世界接触也少，没想到 Java 这么强大，纠结中就浪费了不少时间。这是大学遗憾的事情之一，没有用心钻研 Java，只能后面慢慢补呗。</p>
<p>期间有两门数据库的课程，主要学的是基本的 SQL 语句和设计数据表（基于 MySQL），还算比较简单。计算机网络也是认真学过的一门课程，网络模型是编程的基础，这个不用解释。编译原理非常难，直接面向机器，什么 CPU 指令、寄存器啊，总之就是难以理解。操作系统也是，涉及许多调度算法，已经忘得差不多了。总之就是越往底层越难学，越往上越容易。</p>
<p>数据结构是门非常重要的课，副院长亲自授课，她这个人教学很认真，大家都不敢怠慢，在所有课程里面这门课的质量还是很高的。常用的数据结构有这么几个：数组、链表、哈希表等，是每个程序员必须熟知的。对于编程，有个公式是这样的：</p>
<blockquote>
<p>程序 = 逻辑 + 控制 + 数据结构</p>
</blockquote>
<p>你看，不懂数据结构谈何编程，逻辑和控制就是算法，这个也是逃不掉的。</p>
<p>毕业设计是自己动手做的，就是一个简单的记账 app。那时候感觉自己是全能啊，原型自己想，界面自己画，代码自己写。整个 app 设计参考了随手记和挖财，连图标素材都是从人家安装包里「借」来的。每隔一段时间就向老师汇报，当时确实非常用心，最后答辩的时候老师们都很满意。</p>
<p>写了这么多，其实我想说的是，<strong>技术洞察力</strong>真的非常重要，直接决定了你的选择，你以后的发展，现在看有多少在用 .net 开发的，再看看有多少用 Java 开发的。往后看，我觉得 Python 和 Go 会有不错的发展，Python 在 AI 领域大有作为，Go 介于 C 和 Java 之间，各自都有适用的场景，以后的事让时间来验证吧。</p>
<p>另外一点就是<strong>基本功</strong>，比如上面说的算法和数据结构、网路模型、计算机原理等。万丈高楼平地起，勿在浮沙筑高台。只有掌握本质原理，才能在瞬息万变的技术世界游刃有余。</p>
<p>这是我编程这么多年来的经历和感受，<strong>编程是门手艺活儿</strong>，既然选择了，那就做下去吧。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[《Effective Java》— Java 进阶必备]]></title>
        <id>https://isuperqiang.github.io/post/lesslesseffective-javagreatergreater-java-jin-jie-bi-bei/</id>
        <link href="https://isuperqiang.github.io/post/lesslesseffective-javagreatergreater-java-jin-jie-bi-bei/">
        </link>
        <updated>2020-06-29T04:06:47.000Z</updated>
        <summary type="html"><![CDATA[<p>《Effective Java》是 Java 领域的经典之作，其影响力不亚于《Think in Java》。它是每个 Java 开发者的必读书籍，值得多次阅读品味，并不断实践其中的经验技巧。</p>
]]></summary>
        <content type="html"><![CDATA[<p>《Effective Java》是 Java 领域的经典之作，其影响力不亚于《Think in Java》。它是每个 Java 开发者的必读书籍，值得多次阅读品味，并不断实践其中的经验技巧。</p>
<!-- more -->
<p>两年前读过此书，当时自身技术水平并不算高，对于其中的原则不求甚解。现在重温以前的笔记，加上这两年的编程经验，竟然有种豁然开朗的感觉。<br>
「书读百遍，其义自见。」古人说得有道理啊。</p>
<p>这里简单介绍几条开发中经常用到的技巧，比如 Builder、对象方法、接口定义等。</p>
<h3 id="1-存在多个构造参数时考虑使用构建器builder">1. 存在多个构造参数时，考虑使用构建器（Builder）</h3>
<p>这里讲的就是构建者模式，使用 Builder 给对象设置构造参数，从而去除重叠的构造方法。</p>
<p>在第三方库中，比如 OkHttp、Retrofit，经常见到这样的设计。我们用 Builder 设置参数，然后调用 build 方法构造对象，代码看起来非常清爽，没有多余的构造参数，使用起来也方便。</p>
<p>如果类的构造方法中有多个参数，而且参数可选，Builder 模式是不错的选择。</p>
<h3 id="2-使用私有构造器或者枚举类型强化-singleton-属性">2. 使用私有构造器或者枚举类型强化 Singleton 属性</h3>
<p>单例模式推荐使用静态内部类，保证线程安全的同时，延迟对象的初始化。枚举的话，不是很推荐。</p>
<h3 id="3-避免创建不必要的对象">3. 避免创建不必要的对象</h3>
<p>创建对象是有开销的，对于不可变的（可以理解为无状态的）对象，可以始终被重用。善于使用缓存（cache）是好的习惯，我们要做一个环保的程序员。比如 Android Message 里面的对象池，就是一种优化策略。</p>
<p>优先使用基本数据类型而不是装箱数据类型，因为基本类型占用更少的内存空间，对于移动端来说，内存优化是一个永恒的话题。</p>
<h3 id="4-覆盖-equals-时总要覆盖-hashcode始终覆盖-tostring">4. 覆盖 equals 时总要覆盖 hashCode，始终覆盖 toString</h3>
<p>对于一般的 Java Bean 对象，我都会重写其 toString 方法， 这样在打印日志的时候，就能看见它的内部数据，这点非常有用。</p>
<p>对于需要作为 HashMap 的键的对象，一定要重写 hashCode 和 equals 方法，这样有利于散列表均匀分布，提升查找的性能。<br>
另外，两个对象 equals 相等，hashCode 必须相等；hashCode 相等，equals不一定相等。这个很好理解，equals 保证 HashMap 键的唯一性；hashCode 相等表示两个对象放在 HashMap 数组的同一个位置上。</p>
<p>提示：现在的 IDE 实在是太傻瓜式了，可以一键生成 toString, equals 和 hashCode 方法，这时候有什么理由不重写呢。</p>
<h3 id="5-接口优于抽象类">5. 接口优于抽象类</h3>
<p>接口本质上是一种规范，用来定义通用的规则，然后各个功能提供者进行不同的实现。这里，我想到了一条软件设计原则--接口隔离，是说一个接口只用来定义一种规范，每个接口都是独立的，不能让一个接口有多个定义。</p>
<p>骨架实现，AbstractXXX，为抽象类提供了实现上的帮助，又不强加抽象类定义类型的限制。比如 Java 里面的 AbstractList，是列表类的抽象实现，其子类有 ArrayList 和 LinkedList 等。</p>
<h3 id="6-优先考虑静态成员类">6. 优先考虑静态成员类</h3>
<p>静态成员类不持有外部类的引用，所以不会造成内存泄漏问题，主要是用来辅助外部类。还有匿名内部类，比如直接创建的 Runnable，建议内部保持简短，大约 10 行或者更少些，否则影响程序的可读性。</p>
<h3 id="7-列表优先于数组">7. 列表优先于数组</h3>
<p>列表和数组的不同点：</p>
<ul>
<li>数组是可变的，泛型是不可变的。</li>
<li>数组是具体化的，泛型通过擦除来实现的。</li>
</ul>
<p>数组提供了运行时的类型安全，但是没有编译时的类型安全。列表里面有许多实用的方法，而数组就没有提供哦。建议优先使用集合类型 List<E>，而不是数组类型 E[]。</p>
<h3 id="8-使用枚举代替-int-常量">8. 使用枚举代替 int 常量</h3>
<p>枚举类型是实例受控的，它们是单例的泛化，本质上是单元素的枚举。枚举的优点是易读性好，更加安全，功能强大。但是与 int 类型相比，枚举有些性能缺点：装载和初始化枚举时会有时间和空间的成本。在 Android 端，通常不建议使用。</p>
<h3 id="9-for-each-循环优先于传统的-for-循环">9. for-each 循环优先于传统的 for 循环</h3>
<p>for-each 循环在简洁性和预防 bug 方面优于传统的 for 循环，而且没有性能损失，应该尽可能地使用 for-each。</p>
<p>这一点深有感触，IDE 通常会提示使用 for-each，毕竟简洁就是美啊。</p>
<h3 id="10-如果需要精确的答案请避免使用-float-和-double">10. 如果需要精确的答案，请避免使用 float 和 double</h3>
<p>float 和 double 并没有提供完全精确的结果，所以不应该用于需要精确计算的场合，尤其是货币计算。如果想要系统记录十进制小数点，可以使用 BigDecimal。</p>
<p>float 类型确实是个坑，经常会出现计算不准确的问题，一般推荐使用双精度浮点型 double。</p>
<p>以上就是从《Effective Java》里面摘录的十条编程建议，另外还有好多干货呢，赶快去阅读吧。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每周 ARTS 第 33 期]]></title>
        <id>https://isuperqiang.github.io/post/mei-zhou-arts-di-33-qi/</id>
        <link href="https://isuperqiang.github.io/post/mei-zhou-arts-di-33-qi/">
        </link>
        <updated>2020-06-14T15:07:09.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-algorithm">1. Algorithm</h2>
<h4 id="路径总和-iii"><a href="https://leetcode-cn.com/problems/path-sum-iii/">路径总和 III</a>（简单）</h4>
<h4 id="描述">描述：</h4>
<blockquote>
<p>给定一个二叉树，它的每个结点都存放着一个整数值。找出路径和等于给定数值的路径总数。<br>
路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。<br>
二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。</p>
</blockquote>
<h4 id="示例">示例：</h4>
<pre><code>root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8

      10
     /  \
    5   -3
   / \    \
  3   2   11
 / \   \
3  -2   1

返回 3。和等于 8 的路径有:

1.  5 -&gt; 3
2.  5 -&gt; 2 -&gt; 1
3.  -3 -&gt; 11
</code></pre>
<h4 id="思路">思路：</h4>
<p>两次递归。pathSum 返回以当前节点为根的树中，路径和为目标值的路径总数；count 返回以当前节点为根的树中，有多少以该节点为开头，路径和为目标值的路径总数。</p>
<pre><code class="language-java">class Sulution {
    public int pathSum(TreeNode root, int sum) {
        if (root == null) {
            return 0;
        }
        return count(root, sum) + pathSum(root.left, sum) + pathSum(root.right, sum);
    }

    private int count(TreeNode root, int sum) {
        if (root == null) {
            return 0;
        }
        int count = 0;
        if (sum == root.val) {
            count += 1;
        }
        int diff = sum - root.val;
        return count + count(root.left, diff) + count(root.right, diff);
    }
}
</code></pre>
<h2 id="2-review">2. Review</h2>
<p><a href="https://medium.com/free-code-camp/the-most-important-skill-a-programmer-can-learn-9d410c786baf">The most important skill a programmer can learn</a> 程序员该学到的最重要技能</p>
<p>知道什么时候不写代码，该拒绝的需求就坚定拒绝。代码增多会带来很多问题，面对各种需求，我们不该被动接受，不合理的需求就不做。</p>
<h2 id="3-tip">3. Tip</h2>
<p>程序员不喜欢做重复的事情，写脚本成了偷懒的方法，shell 是最常用的脚本，可完成许多自动化的操作。<a href="https://wangdoc.com/bash/index.html">Bash脚本教程</a> 是不错的参考资料。</p>
<h2 id="4-share">4. Share</h2>
<p><a href="https://mp.weixin.qq.com/s/TIxWo9LMI3tFrz5612JWFw">caoz 的职场系列</a> 写得很受用，职场人可以多读读。</p>
]]></content>
    </entry>
</feed>