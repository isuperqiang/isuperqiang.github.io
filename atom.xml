<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://isuperqiang.cn</id>
    <title>落英坠露</title>
    <updated>2019-07-28T11:41:37.138Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://isuperqiang.cn"/>
    <link rel="self" href="https://isuperqiang.cn/atom.xml"/>
    <subtitle>生活不止眼前的苟且，还有诗和远方的田野。</subtitle>
    <logo>https://isuperqiang.cn/images/avatar.png</logo>
    <icon>https://isuperqiang.cn/favicon.ico</icon>
    <rights>All rights reserved 2019, 落英坠露</rights>
    <entry>
        <title type="html"><![CDATA[每周 ARTS 第 17 期]]></title>
        <id>https://isuperqiang.cn/post/mei-zhou-arts-di-17-qi</id>
        <link href="https://isuperqiang.cn/post/mei-zhou-arts-di-17-qi">
        </link>
        <updated>2019-07-28T11:37:11.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-algorithm">1. Algorithm</h2>
<h3 id="1114-按序打印简单">1114. 按序打印（简单）</h3>
<h5 id="描述">描述：</h5>
<blockquote>
<p>三个不同的线程将会共用一个 Foo 实例，它们会被异步启动。</p>
<ul>
<li>
<p>线程 A 将会调用 one() 方法</p>
</li>
<li>
<p>线程 B 将会调用 two() 方法</p>
</li>
<li>
<p>线程 C 将会调用 three() 方法</p>
<p>请设计修改程序，以确保 two() 方法在 one() 方法之后被执行，three() 方法在 two() 方法之后被执行。</p>
</li>
</ul>
</blockquote>
<h5 id="示例">示例：</h5>
<pre><code>输入: [1,2,3]
输出: &quot;onetwothree&quot;
解释: 
有三个线程会被异步启动。
输入 [1,2,3] 表示线程 A 将会调用 one() 方法，线程 B 将会调用 two() 方法，线程 C 将会调用 three() 方法。
正确的输出是 &quot;onetwothree&quot;。
</code></pre>
<h5 id="思路">思路：</h5>
<p>排序的思路就是 线程 C 等待线程 B 执行完毕，线程 B 等待线程 A 执行完毕，通过线程阻塞的方式实现，JUC 提供了许多的多线程工具类。</p>
<ul>
<li>解法一：CountDownLoatch</li>
</ul>
<pre><code class="language-java">  /**
     * 通过 CountDownLatch
     */
    public static class Foo1 {
        private CountDownLatch countDownLatchSecond = new CountDownLatch(1);
        private CountDownLatch countDownLatchThird = new CountDownLatch(1);

        public void first(Runnable printFirst) throws InterruptedException {
            printFirst.run();
            countDownLatchSecond.countDown();
        }

        public void second(Runnable printSecond) throws InterruptedException {
            countDownLatchSecond.await();
            printSecond.run();
            countDownLatchThird.countDown();
        }

        public void third(Runnable printThird) throws InterruptedException {
            countDownLatchThird.await();
            printThird.run();
        }
    }
</code></pre>
<ul>
<li>解法二：Object 内置锁</li>
</ul>
<pre><code class="language-java">    /**
     * 通过 Object 内置锁
     */
    public static class Foo2 {
        private final Object lock = new Object();
        private int state = 1;

        public void first(Runnable printFirst) throws InterruptedException {
            synchronized (lock) {
                printFirst.run();
                state = 2;
                lock.notifyAll();
            }
        }

        public void second(Runnable printSecond) throws InterruptedException {
            synchronized (lock) {
                while (state != 2) {
                    lock.wait();
                }
                printSecond.run();
                state = 3;
                lock.notifyAll();
            }
        }

        public void third(Runnable printThird) throws InterruptedException {
            synchronized (lock) {
                while (state != 3) {
                    lock.wait();
                }
                printThird.run();
            }
        }
    }
</code></pre>
<ul>
<li>解法三：Lock 和 Condition</li>
</ul>
<pre><code class="language-java">    /**
     * 通过 Lock 和 Condition
     */
    public static class Foo3 {
        private Lock lock = new ReentrantLock();
        private Condition condition = lock.newCondition();
        private int state = 1;

        public void first(Runnable printFirst) throws InterruptedException {
            lock.lock();
            try {
                printFirst.run();
                state = 2;
                condition.signalAll();
            } finally {
                lock.unlock();
            }
        }

        public void second(Runnable printSecond) throws InterruptedException {
            lock.lock();
            try {
                while (state != 2) {
                    condition.await();
                }
                printSecond.run();
                state = 3;
                condition.signalAll();
            } finally {
                lock.unlock();
            }
        }

        public void third(Runnable printThird) throws InterruptedException {
            lock.lock();
            try {
                while (state != 3) {
                    condition.await();
                }
                printThird.run();
            } finally {
                lock.unlock();
            }
        }
    }
</code></pre>
<ul>
<li>解法四：Semaphore</li>
</ul>
<pre><code class="language-java">    /**
     * 通过 Semaphore
     */
    public static class Foo4 {
        private Semaphore semaphoreSecond = new Semaphore(0);
        private Semaphore semaphoreThird = new Semaphore(0);

        public void first(Runnable printFirst) throws InterruptedException {
            printFirst.run();
            semaphoreSecond.release();
        }

        public void second(Runnable printSecond) throws InterruptedException {
            semaphoreSecond.acquire();
            printSecond.run();
            semaphoreThird.release();
        }

        public void third(Runnable printThird) throws InterruptedException {
            semaphoreThird.acquire();
            printThird.run();
        }
    }
</code></pre>
<hr>
<h2 id="2-review">2. Review</h2>
<p><a href="https://www.lifehack.org/articles/technology/20-tips-use-google-search-efficiently.html">20 Google Search Tips to Use Google More Efficiently</a> 用好谷歌搜索的 20 条技巧</p>
<ol>
<li>使用 Tab 分类，比如图片、新闻、视频等</li>
<li>使用双引号，精确匹配关键词，比如： “浪潮之巅 吴军”</li>
<li>使用连字符 <code>-</code> 排除词语，比如：见识 -吴军</li>
<li>使用冒号 <code>site:url</code> 搜索指定网站，比如：吴军 site:dangdang.com</li>
<li>查找链接到另一个页面的页面 <code>link:url</code>，比如：link:qq.com</li>
<li>使用星号 <code>*</code> 通配符，比如：生活不止 * 苟且</li>
<li>查找与其他网站相似的网站 <code>related:url</code>，比如：related:amazon.com</li>
<li>用谷歌搜索做数学，比如：8 * 5 + 5</li>
<li>一个搜索多个关键词 <code>OR</code>，比如：巧克力 OR 白巧克力</li>
<li>搜索一系列数字 <code>..</code>，比如：41..43</li>
<li>保持简单，比如：附近的披萨店</li>
<li>逐渐添加搜索词，比如：
<ul>
<li>首先尝试：工作面试</li>
<li>其次尝试：准备工作面试</li>
<li>再次尝试：如何准备工作面试</li>
</ul>
</li>
<li>使用网站会用的词汇，比如：“我头疼”可以换成“头痛缓解”</li>
<li>只用重要的词汇，比如：
<ul>
<li>不要用：我从哪儿可以找到提供配送的餐馆？</li>
<li>而要用：附近的餐馆</li>
</ul>
</li>
<li>谷歌搜索有快捷方式，就像上面的计算器一样。比如：北京时间、杭州天气</li>
<li>拼写不那么重要，谷歌搜索会帮你纠正语法和词汇。</li>
<li>使用描述性词语，比如：如何安装 Ubuntu 的驱动？</li>
<li>查找特定文件 <code>filetype:pdf</code>，比如：文明之光 filetype:pdf</li>
<li>货币和单位换算，</li>
<li>追踪你的包裹</li>
</ol>
<p>谷歌搜索是最棒的搜索工具，比某度好一万倍，善用谷歌是一种高效的方式。</p>
<h2 id="3-tip">3. Tip</h2>
<p>推荐一个静态博客写作客户端 <a href="https://github.com/getgridea/gridea">Gridea</a>，使用它可以方便地管理文章，进行分类、打标签等，一键同步到 GitHub，提供了多套主题，支持配置域名和评论功能，Windows、Mac 、Linux 全平台支持。我的<a href="https://isuperqiang.cn/">博客</a>托管在 GitHub 上，以前使用 <a href="https://hexo.io/zh-cn/">Hexo</a> 发布，但是没有本地管理功能，想修改文章非常麻烦。现在用 Gridea 发布，果然优雅了不少啊。</p>
<h2 id="4-share">4. Share</h2>
<p>程序员一般不喜欢写文档，遇到问题时又骂别人不写文档。在我看来，文档和代码一样重要，开源库的 API 文档写得清晰明了，开发者使用时也省心。最怕的是，过了一段时间，自己的代码都捋不清了。所以，尽可能多些文档吧，为了自己也为了接盘侠 :)</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每周 ARTS 第 16 期]]></title>
        <id>https://isuperqiang.cn/post/mei-zhou-arts-di-16-qi</id>
        <link href="https://isuperqiang.cn/post/mei-zhou-arts-di-16-qi">
        </link>
        <updated>2019-07-20T10:26:43.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-algorithm">1. Algorithm</h2>
<h3 id="152-乘积最大子序列中等">152. 乘积最大子序列（中等）</h3>
<h5 id="描述">描述：</h5>
<blockquote>
<p>给定一个整数数组 nums ，找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）。</p>
</blockquote>
<h5 id="示例">示例：</h5>
<pre><code>输入: [2,3,-2,4]
输出: 6
解释: 子数组 [2,3] 有最大乘积 6。
</code></pre>
<h5 id="思路">思路：</h5>
<ul>
<li>解法一：暴力解法，遍历数组，逐个求出连续子序列的乘积，和当前最大值比较，找到最大值。</li>
<li>解法二：动态规划，遍历数组，计算当前最大值，并不断更新。当前最大乘积 max，当前最小乘积 min。由于存在负数，会导致最大的变成最小的，最小的变成最大的。所以分两种情况讨论：
<ul>
<li>nums[i] &gt; 0 时，max = Max(max * nums[i], nums[i]); min = Min(min * num[i], num[i]);</li>
<li>nums[i] &lt; 0 时，max = Max(min * nums[i], nums[i]); min = Min(max * num[i], num[i]);</li>
</ul>
</li>
</ul>
<pre><code class="language-java">class Solution {
    public int maxProduct1(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }
        int max = nums[0];
        int temp;
        for (int i = 0; i &lt; nums.length; i++) {
            temp = nums[i];
            if (temp &gt; max) {
                max = temp;
            }
            for (int j = i + 1; j &lt; nums.length; j++) {
                temp *= nums[j];
                if (temp &gt; max) {
                    max = temp;
                }
            }
        }
        return max;
    }

    public int maxProduct2(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }
        int ret = nums[0];
        int min = nums[0];
        int max = nums[0];
        for (int i = 1; i &lt; nums.length; i++) {
            if (nums[i] &lt; 0) {
                int temp = min;
                min = max;
                max = temp;
            }
            max = Math.max(max * nums[i], nums[i]);
            min = Math.min(min * nums[i], nums[i]);
            ret = Math.max(ret, max);
        }
        return ret;
    }
}
</code></pre>
<h5 id="分析">分析：</h5>
<ul>
<li>时间复杂度：
<ul>
<li>解法一：O(n^2)</li>
<li>解法二：O(n)</li>
</ul>
</li>
<li>空间复杂度都是 O(1)</li>
</ul>
<hr>
<h2 id="2-review">2. Review</h2>
<p><a href="http://tutorials.jenkov.com/java-concurrency/java-memory-model.html">Java Memory  Model</a> 主要讲述了 Java 内存模型、硬件内存架构和两者之间的差异。</p>
<p>Java 内存模型把内存分为线程栈和堆。每个线程都有各自的线程栈，线程栈内部包含方法调用信息和方法内局部变量，它不能被其他线程访问。线程栈存储的局部变量，包括「基本数据类型和引用变量」的拷贝，而引用的对象存储在堆中。堆用来存储应用创建的对象，不管是局部对象还是成员对象，不论是哪个线程创建的。</p>
<p>硬件内存架构包含 CPU 寄存器、高速缓存和 RAM 主存，按照前面的顺序，读写速度越来越慢，容量越来越大。当 CPU 读取数据时，会把数据缓存在寄存器和高速缓存中。当 CPU 写回数据时，会把数据从寄存器和高速缓存刷新到 RAM。</p>
<p>Java 内存模型和硬件模型架构不同，通常线程栈和堆在 RAM 中，但有时也会在寄存器和高速缓存中。当变量存储在计算机的不同位置时，就会引发两个主要问题：多线程读写变量的可见性和竞态条件。使用 volatile 可以解决可见性问题，synchronized 可以解决竞态条件。</p>
<h2 id="3-tip">3. Tip</h2>
<p>刷题的时候看到了 override 和 overload，结合前段时间读过的《码出高效：Java开发手册》中的内容，重新梳理了一下知识点：<a href="https://isuperqiang.cn/post/shen-ru-li-jie-java-zhong-de-override-he-overload/">深入理解 Java 中的 override 和 overload</a>。</p>
<h2 id="4-share">4. Share</h2>
<p>多学一些东西总没有错，所谓「技多不压身」。别人不懂的你能做，别人现学现查，你信手拈来，别人浮于表面，你深入原理。这都是机会，是优势，机会总是留给有准备的人。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[深入理解 Java 中的 override 和 overload]]></title>
        <id>https://isuperqiang.cn/post/shen-ru-li-jie-java-zhong-de-override-he-overload</id>
        <link href="https://isuperqiang.cn/post/shen-ru-li-jie-java-zhong-de-override-he-overload">
        </link>
        <updated>2019-07-20T03:25:13.000Z</updated>
        <summary type="html"><![CDATA[<p>override 和 overload，分别翻译为覆写和重载，是 Java 多态（Polymorphism）的两种代表类型。下面详细分析一下 override 和 overload 的使用方式。</p>
]]></summary>
        <content type="html"><![CDATA[<p>override 和 overload，分别翻译为覆写和重载，是 Java 多态（Polymorphism）的两种代表类型。下面详细分析一下 override 和 overload 的使用方式。</p>
<!-- more -->
<h3 id="1-override">1. override</h3>
<p>override 出现在继承关系中，子类覆写父类的实例方法，为它提供专门的实现。举个例子：</p>
<pre><code class="language-java">public class Animal {
    public void bark() {
        System.out.println(&quot;动物叫声&quot;);
    }
}

public class Cat extends Animal {
    @Override
    public void bark() {
        System.out.println(&quot;喵喵&quot;);
    }
}

    public static void main(String[] args) {
        // 向上转型
				Animal cat = new Cat();
        cat.bark(); // 打印 喵喵
    }
</code></pre>
<p>override 的绑定发生在运行期，属于动态绑定，由实例对象决定调用哪个方法，动态绑定是多态性得以实现的重要因素。这里有几点需要注意的地方：</p>
<ul>
<li>子类的方法访问权限只能相同或变大。比如父类方法是 protected，子类可以是 public，不能是 private。</li>
<li>抛出异常和返回值只能变小，它们能够转型成父类对象。比如父类方法返回值 Number，子类可以返回 Integer，不能返回 Object。</li>
<li>方法签名必须完全相同。方法签名包括方法名称和参数列表，是 JVM 标识方法的唯一索引，不包括返回值，其中参数列表分为类型和个数。</li>
<li>覆写方法必须要加上 <code>@Override</code> 注解，为了使编译器自动检查覆写是否满足规则。</li>
</ul>
<p>覆写只能用于类的不被 final 和 private 修饰的实例方法，不能用于静态方法，如果父类和子类中存在同名的静态方法，那么两者都可以被正常调用。</p>
<h3 id="2-overload">2. overload</h3>
<p>overload 出现在同一个类中，多个方法具有相同名字、不同的参数。举个例子：</p>
<pre><code class="language-java">public class Cat {
    public void bark() {
        System.out.println(&quot;喵喵&quot;);
    }

    public void bark(int num) {
        for (int i = 1; i &lt;= num; i++) {
            System.out.println(&quot;第 &quot; + i + &quot; 声喵喵&quot;);
        }
    }
}
</code></pre>
<p>overload 的绑定发生在编译期，属于静态绑定，由方法签名决定调用哪个方法。需要注意的是，方法签名包括方法名称、参数类型和个数，不包括返回值。</p>
<p>当重载的方法参数比较复杂时，JVM 选择合适的目标方法的顺序如下：</p>
<ul>
<li>精确匹配</li>
<li>如果是基本数据类型，自动转换成更大表示范围的基本类型</li>
<li>通过自动拆箱与装箱</li>
<li>通过子类向上转型继承路线依次匹配</li>
<li>通过可变参数匹配</li>
</ul>
<p>下面通过例子说明。</p>
<ol>
<li>基本数据类型优先于包装数据类型。</li>
</ol>
<pre><code class="language-java">    public void mo(int a) {
        System.out.println(&quot;primary int type&quot;);
    }

    public void mo(Integer a) {
        System.out.println(&quot;wrapper int type&quot;);
    }

    Cat cat = new Cat();
    cat.mo(1); // 打印 primary int type
</code></pre>
<ol start="2">
<li>更大范围的基本数据类型优先于包装数据类型。</li>
</ol>
<pre><code class="language-java">    public void mo(long a) {
        System.out.println(&quot;primary long type&quot;);
    }

    public void mo(Integer a) {
        System.out.println(&quot;wrapper int type&quot;);
    }
    
    Cat cat = new Cat();
    cat.mo(1); // 打印 primary long type
</code></pre>
<ol start="3">
<li>null 可以匹配任何类对象，从最底层子类依次向上查找。</li>
</ol>
<pre><code class="language-java">    public void mo(Integer a) {
        System.out.println(&quot;wrapper int type&quot;);
    }

    public void mo(Object a) {
        System.out.println(&quot;object type&quot;);
    }

//  如果包含 String 参数，那么编译器不知道匹配哪个，直接报错。
//  public void mo(String s) {
//      System.out.println(&quot;string type&quot;);
//  }

    Cat cat = new Cat();
    cat.mo(null); // 打印 wrapper int type
</code></pre>
<ol start="4">
<li>自动装箱和拆箱优先于可变参数。</li>
</ol>
<pre><code class="language-java">    public void mo(Integer a, Integer b){
        System.out.println(&quot;double wrapper int type&quot;);
    }

    public void mo(int... a) {
        System.out.println(&quot;primary int array type&quot;);
    }
    
    Cat cat = new Cat();
    cat.mo(1, 2); // 打印 double wrapper int type
</code></pre>
<p>...</p>
<p>重载的参数类型应该简洁些，这样才能提高代码的可读性。</p>
<h3 id="3-总结">3. 总结</h3>
<p>override 和 overload 有很多不同之处：</p>
<ul>
<li>override 属于动态绑定，在运行期通过实例对象决定调用的方法；overload 属于静态绑定，在编译期通过方法签名决定调用的方法。</li>
<li>override 基于继承关系，需要父类和子类参与；overload 出现在同一个类中，通过方法签名区分。</li>
<li>static、final、private 方法不能被 override，但是可以被 overload。</li>
<li>override 关注方法返回值，overload 不关注返回值。</li>
<li>override 的方法参数必须一样，overload 的方法参数必须不同。</li>
<li>overload 的性能比 override 更好些，应为它是静态绑定。</li>
</ul>
<p><strong>参考：</strong></p>
<ul>
<li>《码出高效：Java开发手册》</li>
<li><a href="https://stackoverflow.com/questions/19017258/static-vs-dynamic-binding-in-java">Static Vs. Dynamic Binding in Java</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每周 ARTS 第 15 期]]></title>
        <id>https://isuperqiang.cn/post/mei-zhou-arts-di-15-qi</id>
        <link href="https://isuperqiang.cn/post/mei-zhou-arts-di-15-qi">
        </link>
        <updated>2019-07-14T12:05:07.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-algorithm">1. Algorithm</h2>
<h3 id="287-寻找重复数中等">287. 寻找重复数（中等）</h3>
<h5 id="描述">描述：</h5>
<blockquote>
<p>给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。</p>
</blockquote>
<h5 id="示例">示例：</h5>
<pre><code>输入: [1,3,4,2,2]
输出: 2
</code></pre>
<h5 id="说明">说明：</h5>
<ul>
<li>不能更改原数组（假设数组是只读的）。</li>
<li>只能使用额外的 O(1) 的空间。</li>
<li>时间复杂度小于 O(n2) 。</li>
<li>数组中只有一个重复的数字，但它可能不止重复出现一次。</li>
</ul>
<h5 id="思路">思路：</h5>
<p>数组元素在 [0, n] 之间，可以作为数组索引使用。先通过快慢指针找到相交点，然后两个指针分别从零位置和相交点一起向前遍历，直到找出相同的值。</p>
<pre><code class="language-java">class Solution {
    public int findDuplicate(int[] nums) {
        if (nums == null || nums.length == 0) {
            return -1;
        }

        int fast = nums[0];
        int slow = nums[0];
        do {
            slow = nums[slow];
            fast = nums[nums[fast]];
        } while (fast != slow);

        slow = nums[0];
        while (fast != slow) {
            slow = nums[slow];
            fast = nums[fast];
        }
        return fast;
    }
}
</code></pre>
<h5 id="分析">分析：</h5>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<hr>
<h2 id="2-review">2. Review</h2>
<p><a href="https://medium.com/@rhamedy/key-habits-and-things-i-wish-i-knew-earlier-as-a-developer-43c9466a0407">Key habits and things I wish I knew earlier as a developer</a> 作为开发者，我希望尽早知道的习惯和事情</p>
<p>作者总结了开发者应该尽早熟知的东西，比如习惯、技能、观念等。</p>
<ul>
<li>有效地使用搜索引擎</li>
<li>使用现代化的 IDE 提高生产力</li>
<li>学习 Linux</li>
<li>学习 Git</li>
<li>自我学习，跟随技术潮流</li>
<li>至少精通一门编程语言</li>
<li>聚焦简约</li>
<li>加入团体或者论坛</li>
<li>建立你的个人档案</li>
<li>提问，提问，提问</li>
<li>写代码前先在纸上比划</li>
<li>遵守技术规范，先写测试用例</li>
<li>在日常中解决难题和挑战</li>
<li>开始白板编程</li>
<li>高效地管理时间</li>
<li>保护个人隐私</li>
<li>跟随激励你的个人和组织</li>
<li>参加技术活动</li>
<li>拥抱错误消息</li>
<li>选择正确类型的公司作为事业</li>
<li>建立一套工作方案，不断迭代使其完美</li>
<li>对自己 SEO</li>
</ul>
<p>下面几点需要注意：</p>
<ul>
<li>不轻言放弃</li>
<li>不拷贝工程代码</li>
<li>不要推迟</li>
<li>不要忽略其他学科</li>
<li>不要沉迷社交网络</li>
<li>不是失去希望</li>
</ul>
<h2 id="3-tip">3. Tip</h2>
<p><a href="https://brew.sh/">Homebrew</a> 真是 Mac 上的神器，软件开发包都可以通过命令安装，自动配置环境变量，brew cask 还可以安装 GUI 应用程序。brew 在手，软件我有。</p>
<h2 id="4-share">4. Share</h2>
<p>公司 Q2 季度考核，根据实际情况，自评打了高分，我觉得是对的。caoz 有篇文章：<a href="https://mp.weixin.qq.com/s/0emM3IyruRxhBzMVPpeTpQ">你矜持，你活该</a> 讲过。</p>
<p>职场不要太矜持，合作沟通的时候姿态低一些，争取权益的时候胆子大一些。</p>
<p>创业不能太矜持， 宣传营销的时候，该吹牛的时候敢吹牛，不要怕丢脸。业务合作的时候，该低姿态的时候低姿态，不要老端着。</p>
<p>有些技术人才我知道的，在企业不是很顺心，有些权益期待但没有落实，又觉得老板一直对自己不错，总觉得不好意思提要求，其实该争取的要争取，人家稍微温情两句，自己就开始自责了，哪那么多戏。</p>
<p>你矜持，你端着，你失去好机会，你权益无保障，你自废武功，你男/女神被人追跑了，你活该。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每周 ARTS 第 14 期]]></title>
        <id>https://isuperqiang.cn/post/mei-zhou-arts-di-14-qi</id>
        <link href="https://isuperqiang.cn/post/mei-zhou-arts-di-14-qi">
        </link>
        <updated>2019-07-07T08:25:11.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-algorithm">1. Algorithm</h2>
<h3 id="78-子集中等">78. 子集（中等）</h3>
<h5 id="描述">描述：</h5>
<blockquote>
<p>给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。解集不能包含重复的子集。</p>
</blockquote>
<h5 id="示例">示例：</h5>
<pre><code>输入: nums = [1,2,3]
输出:
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]
</code></pre>
<h5 id="思路">思路：</h5>
<p>利用二进制与位运算：<br>
数组中的每个元素，都有两个状态：在子数组中和不在子数组中。所有状态的组合就是所有的子数组。<br>
遍历 000 到 111，也就是 0 到 7，判断每个比特位是否为 1，如果是 1，那么将对应数字加入子数组。</p>
<pre><code class="language-java">class Solution {
    public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) {
        if (nums == null || nums.length == 0) {
            return Collections.emptyList();
        }

        List&lt;Integer&gt; subList;
        int resultLength = 1 &lt;&lt; nums.length;
        List&lt;List&lt;Integer&gt;&gt; resultList = new ArrayList&lt;&gt;(resultLength);
        for (int i = 0, numsLength = nums.length; i &lt; resultLength; i++) {
            subList = new ArrayList&lt;&gt;(numsLength);
            for (int j = 0; j &lt; numsLength; j++) {
                if ((i &gt;&gt; j &amp; 1) == 1) {
                    subList.add(nums[j]);
                }
            }
            resultList.add(subList);
        }
        return resultList;
    }
}
</code></pre>
<h5 id="分析">分析：</h5>
<ul>
<li>时间复杂度：O(n^2)</li>
<li>空间复杂度：O(n)</li>
</ul>
<hr>
<h2 id="2-review">2. Review</h2>
<p><a href="https://blog.usejournal.com/what-i-learned-in-my-first-two-years-as-a-software-engineer-4e374fdcf0fd">What I Learned in My First Two Years as a Software Engineer</a> 在我做软件工程师的前两年里学到了什么</p>
<p>作者讲了两个故事。</p>
<p>第一个故事，读大学时导师布置任务，完成好的学生会被分到一组，完成差的学生要么努力挤进好学生队伍，要么放弃，好学生不会帮助差学生，导师奖励做得好的学生。然而进入公司后，如果再采用这种原则，同事之间不免发生矛盾。完成任务不是唯一的事情，与同事的关系和硬技能同样重要。</p>
<p>第二个故事，作者在结对编程时遇到了 Bob，Bob 经常对项目提出问题，帮助作者解决潜在的 bug，此时无招胜有招，因此作者非常佩服 Bob。优秀的问题解决者在给出方案之前，会提出很多问题，用论证影响团队的成员，表现出领导力。</p>
<p>最后，作者总结了一些教训。处理好与同事的关系，编程不比家庭、友谊、健康重要，尽可能做最好的工程师。</p>
<h2 id="3-tip">3. Tip</h2>
<p>《Java并发编程实战》中讲到单例设计模式的几种线程安全的实现方式：延迟初始化、提前初始化、延迟初始化占位类和双重检查锁。其中，双重检查锁的实例变量要声明为 volatile 才有效，作者称其为糟糕的实现，不如静态的占位类优雅。</p>
<h2 id="4-share">4. Share</h2>
<p>近期在优化项目代码，发现在渲染每帧图像的时候，存在大量无用的对象创建。这么来看，Android 屏幕的刷新速率是 60 FPS，高密集地创建对象导致堆空间占满，造成频繁的垃圾回收，不利于程序的性能。我们要避免这种操作，做一个环保的程序员。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每周 ARTS 第 13 期]]></title>
        <id>https://isuperqiang.cn/post/mei-zhou-arts-di-13-qi</id>
        <link href="https://isuperqiang.cn/post/mei-zhou-arts-di-13-qi">
        </link>
        <updated>2019-06-30T11:50:17.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-algorithm">1. Algorithm</h2>
<h4 id="242-有效的字母异位词简单">242. 有效的字母异位词（简单）</h4>
<h5 id="描述">描述：</h5>
<blockquote>
<p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p>
</blockquote>
<h5 id="示例">示例：</h5>
<pre><code>输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot;
输出: true
</code></pre>
<h5 id="思路">思路：</h5>
<p>统计 s 中每个字母出现的次数，遍历 t 中的字母减去相应的次数。如果次数小于 0，那么认为是 false。</p>
<pre><code class="language-java">class Solution {
    public boolean isAnagram(String s, String t) {
        if (s == null || t == null || s.length() != t.length()) {
            return false;
        }

        int[] counter = new int[26];
        for (int i = 0, size = s.length(); i &lt; size; i++) {
            counter[s.charAt(i) - 'a']++;
        }
        for (int i = 0, size = t.length(); i &lt; size; i++) {
            char c = t.charAt(i);
            counter[c - 'a']--;
            if (counter[c - 'a'] &lt; 0) {
                return false;
            }
        }
        return true;
    }
}
</code></pre>
<h5 id="分析">分析：</h5>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<hr>
<h2 id="2-review">2. Review</h2>
<p><a href="https://medium.com/devtrailsio/how-to-become-a-better-software-developer-dd16072c974e">How to Become a Better Software Developer</a> 如何成为更好的软件开发者</p>
<p>作者分享了一些提升技能和高效工作的方法，这里简单列举几条：</p>
<ul>
<li>从端到端理解流程。程序员不要低头写代码，应该关注软件开发的其他方面，比如产品、设计、测试等。</li>
<li>理解客户的需求。客户不懂技术，我们要赢得客户的信任，多站在客户的角度考虑。</li>
<li>为工作选择正确的工具。不要限制自己思维，要提出不同的方案。尝试新事物时，要注意到安全性。</li>
<li>站在巨人的肩膀上。不要重复造轮子，但是可以通过重新实现来学习。</li>
<li>关心自己如何工作。提升个人和团队的研发效能，比如完善的工作流程、项目计划等。</li>
<li>专注于基础。IT 行业瞬息万变，新框架层出不穷，唯有基础知识是一成不变的。</li>
<li>其他的经验：积极分享知识，不要指责自己和他人，不要做刺头。</li>
</ul>
<h2 id="3-tip">3. Tip</h2>
<p>最近在读《Java并发编程实战》，里面讲了一些线程安全的技巧和概念，比如原子性、可见性、不可变对象。线程安全的核心在于对共享和可变的对象进行访问控制，采用同步机制（synchronized），同步的代码块保持精细。不可变对象一定是线程安全的，比如 String。加锁机制可以确保可见性和原子性，而 volatile 只能保证可见性。</p>
<h2 id="4-share">4. Share</h2>
<p>19 年过半，我发现有些目标做到一半就停止了，执行力还需要提高。计划-执行-坚持。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每周 ARTS 第 12 期]]></title>
        <id>https://isuperqiang.cn/post/mei-zhou-arts-di-12-qi</id>
        <link href="https://isuperqiang.cn/post/mei-zhou-arts-di-12-qi">
        </link>
        <updated>2019-06-23T13:53:36.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-algorithm">1. Algorithm</h2>
<h3 id="108-将有序数组转换为二叉搜索树简单">108. 将有序数组转换为二叉搜索树（简单）</h3>
<h5 id="描述">描述：</h5>
<blockquote>
<p>将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。本题中，一个高度平衡二叉树是指一个二叉树每个节点的左右两个子树的高度差的绝对值不超过 1。</p>
</blockquote>
<h5 id="示例">示例：</h5>
<pre><code>给定有序数组: [-10,-3,0,5,9],
一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：

      0
     / \
   -3   9
   /   /
 -10  5
</code></pre>
<h5 id="思路">思路：</h5>
<p>以数组的中间元素为根节点，将数组分为左右两部分，用递归的方法对两个子数组分别构建左右子树。</p>
<pre><code class="language-java">class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        if (nums == null || nums.length == 0) {
            return null;
        }
        return toBst(nums, 0, nums.length - 1);
    }

    private TreeNode toBst(int[] nums, int l, int r) {
        if (l &gt; r) {
            return null;
        }
        int mid = l + (r - l) / 2;
        TreeNode root = new TreeNode(nums[mid]);
        root.left = toBst(nums, l, mid - 1);
        root.right = toBst(nums, mid + 1, r);
        return root;
    }
}
</code></pre>
<h5 id="分析">分析：</h5>
<ul>
<li>时间复杂度：O(logn)</li>
<li>空间复杂度：O(1)</li>
</ul>
<hr>
<h2 id="2-review">2. Review</h2>
<p><a href="https://medium.com/javascript-scene/tdd-changed-my-life-5af0ce099f80">TDD Changed My Life</a> TDD 改变了我的人生</p>
<p>TDD 是测试驱动开发，先写测试用例，再写实现代码。作者讲了一个切身的经历，debug 到奔溃也没有发现问题。如果提前写好单元测试，就能及早发现这个 bug。软件开发就是模块的组装，单元测试针对某个功能，每个部件都通过验证，那么整个系统也得到保证。</p>
<h2 id="3-tip">3. Tip</h2>
<p><a href="https://isuperqiang.cn/post/java-bi-jiao-fu-dian-shu-de-zheng-que-fang-shi/">Java 比较浮点数的正确方式</a> 重新认识了浮点数，解决了以前踩过的坑。</p>
<h2 id="4-share">4. Share</h2>
<p>一本书不读完，坚决不碰下一本。最近读书一直虎头蛇尾，看到一半就停下来看其他的。碎片化的生活，耐心越来越稀缺，我想静下心来，踏踏实实做下去。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java 比较浮点数的正确方式]]></title>
        <id>https://isuperqiang.cn/post/java-bi-jiao-fu-dian-shu-de-zheng-que-fang-shi</id>
        <link href="https://isuperqiang.cn/post/java-bi-jiao-fu-dian-shu-de-zheng-que-fang-shi">
        </link>
        <updated>2019-06-23T04:02:17.000Z</updated>
        <summary type="html"><![CDATA[<p>今天在读《Java开发手册》时，看到浮点数的等值判断问题「浮点数的基本数据类型不能用 <code>==</code> 比较，包装数据类型不能用 <code>equals</code> 比较」。以前开发时也遇到过浮点数的坑，所以就想一探究竟。</p>
]]></summary>
        <content type="html"><![CDATA[<p>今天在读《Java开发手册》时，看到浮点数的等值判断问题「浮点数的基本数据类型不能用 <code>==</code> 比较，包装数据类型不能用 <code>equals</code> 比较」。以前开发时也遇到过浮点数的坑，所以就想一探究竟。</p>
<!-- more -->
<h3 id="1-浮点数表示">1. 浮点数表示</h3>
<p>在计算机系统理论中，浮点数采用 IEEE 754 标准表示，编码方式是符号+阶码+尾数，如图：</p>
<p><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/1820210-61af804d90504fc0.webp" alt="浮点数表示"></p>
<p>比如 float 类型占用 32 位，单精度浮点表示法：</p>
<ul>
<li>符号位（sign）占用 1 位，用来表示正负数，0 表示正数，1 表示负数</li>
<li>指数位（exponent）占用 8 位，用来表示指数，实际要加上偏移量</li>
<li>小数位（fraction）占用 23 位，用来表示小数，不足位数补 0</li>
</ul>
<p>从这里可以看出，指数位决定了大小范围，小数位决定了计算精度。当十进制数值转换为二进制科学表达式后，得到的尾数位数是有可能很长甚至是无限长。所以当使用浮点格式来存储数字的时候，实际存储的尾数是被截取或执行舍入后的近似值。这就解释了浮点数计算不准确的问题，因为近似值和原值是有差异的。</p>
<p>更详细的介绍可以查阅 <a href="https://www.zhihu.com/question/46432979/answer/221485161">java浮点类型float和double的主要区别，它们的小数精度范围大小是多少？ - Boss呱呱的回答 - 知乎</a>。</p>
<h3 id="2-比较浮点数的方式">2. 比较浮点数的方式</h3>
<p>让我们来验证一下比较浮点数的几种方式。</p>
<h4 id="1-操作符">1. <code>==</code> 操作符</h4>
<p>比较两个浮点数，一个从零开始加 11 次 0.1，另一个用 0.1 乘以 11 计算。然后用 <code>==</code> 比较大小。</p>
<pre><code class="language-java">    private void compareByOperator() {
        float f1 = 0.0f;
        for (int i = 0; i &lt; 11; i++) {
            f1 += 0.1f;
        }

        float f2 = 0.1f * 11;

        System.out.println(&quot;f1 = &quot; + f1);
        System.out.println(&quot;f2 = &quot; + f2);

        if (f1 == f2) {
            System.out.println(&quot;f1 and f2 are equal using operator ==&quot;);
        } else {
            System.out.println(&quot;f1 and f2 are not equal using operator ==&quot;);
        }
    }
</code></pre>
<p>运行输出：</p>
<pre><code>f1 = 1.1000001
f2 = 1.1
f1 and f2 are not equal
</code></pre>
<p>可以看到，两个浮点数不相等，所以通过 <code>==</code> 来比较浮点数是不可靠的。</p>
<h4 id="2-误差范围">2. 误差范围</h4>
<p>指定一个误差范围，两个浮点数的差值在范围之内，则认为是相等的。使用 <code>Math.abs()</code> 计算差值，然后和阈值比较。</p>
<pre><code class="language-java">    private void compareByThreshold() {
        final float THRESHOLD = 0.000001;
        float f1 = 0.0f;
        for (int i = 0; i &lt; 11; i++) {
            f1 += 0.1f;
        }

        float f2 = 0.1f * 11;

        System.out.println(&quot;f1 = &quot; + f1);
        System.out.println(&quot;f2 = &quot; + f2);

        if (Math.abs(f1 - f2) &lt; THRESHOLD) {
            System.out.println(&quot;f1 and f2 are equal using threshold&quot;);
        } else {
            System.out.println(&quot;f1 and f2 are not equal using threshold&quot;);
        }
    }
</code></pre>
<p>运行输出：</p>
<pre><code>f1 = 1.1000001
f2 = 1.1
f1 and f2 are equal using threshold
</code></pre>
<h4 id="3-使用-bigdecimal">3. 使用 <code>BigDecimal</code></h4>
<p><code>BigDecimal</code> 是不可变的，能够精确地表示十进制数字。需要注意的是，创建 <code>BigDecimal</code> 对象时，要使用参数为 <code>String</code> 的构造方法，不要使用构造参数为 <code>double</code> 的，如果非要使用 <code>double</code> 创建，一定要用 <code>valueOf</code> 静态方法，防止丢失精度。然后调用 <code>compareTo</code> 方法比较即可。</p>
<pre><code class="language-java">    private void compareByBigDecimal() {
        BigDecimal f1 = new BigDecimal(&quot;0.0&quot;);
        BigDecimal pointOne = new BigDecimal(&quot;0.1&quot;);
        for (int i = 0; i &lt; 11; i++) {
            f1 = f1.add(pointOne);
        }

        BigDecimal f2 = new BigDecimal(&quot;0.1&quot;);
        BigDecimal eleven = new BigDecimal(&quot;11&quot;);
        f2 = f2.multiply(eleven);

        System.out.println(&quot;f1 = &quot; + f1);
        System.out.println(&quot;f2 = &quot; + f2);

        if (f1.compareTo(f2) == 0) {
            System.out.println(&quot;f1 and f2 are equal using BigDecimal&quot;);
        } else {
            System.out.println(&quot;f1 and f2 are not equal using BigDecimal&quot;);
        }
    }
</code></pre>
<p>运行输出：</p>
<pre><code>f1 = 1.1
f2 = 1.1
f1 and f2 are equal using BigDecimal
</code></pre>
<h3 id="3-结论">3. 结论</h3>
<p>使用 <code>==</code> 比较浮点数不准确，可以采用误差范围近似相等，或者 <code>BigDecimal</code> 计算比较。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每周 ARTS 第 11 期]]></title>
        <id>https://isuperqiang.cn/post/mei-zhou-arts-di-11-qi</id>
        <link href="https://isuperqiang.cn/post/mei-zhou-arts-di-11-qi">
        </link>
        <updated>2019-06-16T03:38:22.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-algorithm">1. Algorithm</h2>
<h3 id="263-丑数简单">263. 丑数（简单）</h3>
<h5 id="描述">描述：</h5>
<blockquote>
<p>编写一个程序判断给定的数是否为丑数。丑数就是只包含质因数 2, 3, 5 的正整数。</p>
</blockquote>
<h5 id="示例">示例：</h5>
<pre><code>示例：
输入: 6
输出: true
解释: 6 = 2 × 3
</code></pre>
<h5 id="思路">思路：</h5>
<ul>
<li>循环实现：循环去除 2、3、5，直到不能整除，如果余数是 1，那么就是丑数。</li>
<li>递归实现：和循环一样，也是不停地除2、3、5。</li>
</ul>
<pre><code class="language-java">class Solution {
    public boolean isUgly(int num) {
        if (num &lt;= 0) {
            return false;
        } else if (num == 1) {
            return true;
        }
        while (num % 2 == 0) {
            num /= 2;
        }
        while (num % 3 == 0) {
            num /= 3;
        }
        while (num % 5 == 0) {
            num /= 5;
        }
        return num == 1;
    }
  
   private static boolean isUgly2(int num) {
        if (num &lt;= 0) {
            return false;
        } else if (num == 1) {
            return true;
        }
        if (num % 2 == 0) {
            return isUgly2(num / 2);
        }
        if (num % 3 == 0) {
            return isUgly2(num / 3);
        }
        if (num % 5 == 0) {
            return isUgly2(num / 5);
        }
        return false;
    }
}
</code></pre>
<h5 id="分析">分析：</h5>
<p>循环和递归实现一样：</p>
<ul>
<li>时间复杂度：O(logn)</li>
<li>空间复杂度：O(1)</li>
</ul>
<hr>
<h3 id="349-两个数组的交集简单">349.  两个数组的交集（简单）</h3>
<h5 id="描述-2">描述：</h5>
<blockquote>
<p>给定两个数组，编写一个函数来计算它们的交集。</p>
</blockquote>
<h5 id="示例-2">示例：</h5>
<pre><code>输入: nums1 = [1,2,2,1], nums2 = [2,2]
输出: [2]
</code></pre>
<h5 id="说明">说明：</h5>
<ul>
<li>输出结果中的每个元素一定是唯一的。</li>
<li>我们可以不考虑输出结果的顺序。</li>
</ul>
<h5 id="思路-2">思路：</h5>
<p>使用一个 Set 去除数组一重复元素，另一个 Set 保存两个数组的交集</p>
<h5 id="解法">解法：</h5>
<pre><code class="language-java">class Solution {
    public int[] intersection(int[] nums1, int[] nums2) {
        if (nums1 == null || nums2 == null) {
            return new int[]{};
        }

        Set&lt;Integer&gt; set1 = new HashSet&lt;&gt;(nums1.length);
        for (int i : nums1) {
            set1.add(i);
        }
        Set&lt;Integer&gt; set2 = new HashSet&lt;&gt;(nums1.length);
        for (int i : nums2) {
            if (set1.contains(i)) {
                set2.add(i);
            }
        }
        int size = set2.size();
        int[] ret = new int[size];
        Iterator&lt;Integer&gt; iterator = set2.iterator();
        for (int i = 0; i &lt; size; i++) {
            ret[i] = iterator.next();
        }
        return ret;
    }
}
</code></pre>
<h5 id="分析-2">分析：</h5>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(n)</li>
</ul>
<h2 id="2-review">2. Review</h2>
<p><a href="https://medium.com/free-code-camp/what-is-an-api-in-english-please-b880a3214a82">What is an API? In English, please.</a> 什么是 API？</p>
<p>开发者都知道 API 是应用程序接口，作者对它有更广泛的认识。API 是服务方的一部分，它接收请求并发出响应。API 是向客户提供服务的一种方式，客户端访问 API 获取消息，比如 GitHub 的 API。在面向对象编程中，对象的 public 方法也可以看作是一种 API，用来与其他对象进行交互。</p>
<h2 id="3-tip">3. Tip</h2>
<p><a href="https://isuperqiang.cn/post/android-io-na-xie-shi-er/">Android I/O 那些事儿</a> 总结了 Android 系统的 I/O 知识，对它有了更深层次的了解。</p>
<h2 id="4-share">4. Share</h2>
<p>经典是经过时间筛选的，在这个浮躁的社会，多读经典是最省时间的选择。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每周 ARTS 第 10 期]]></title>
        <id>https://isuperqiang.cn/post/mei-zhou-arts-di-10-qi</id>
        <link href="https://isuperqiang.cn/post/mei-zhou-arts-di-10-qi">
        </link>
        <updated>2019-06-09T03:37:47.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-algorithm">1. Algorithm</h2>
<h3 id="226-翻转二叉树简单">226. 翻转二叉树（简单）</h3>
<h5 id="描述">描述：</h5>
<blockquote>
<p>翻转一棵二叉树</p>
</blockquote>
<h5 id="示例">示例：</h5>
<pre><code>示例：
输入:
    4
  2    7
1  3  6  9
输出:
    4
  7    2
9  6  3  1
</code></pre>
<h5 id="思路">思路：</h5>
<ul>
<li>递归法：翻转一个二叉树，就是把根节点的左子树翻转一下，同样的把右子树翻转一下，再交换左右子树就可以了。</li>
<li>迭代法：类似广度优先遍历的方式，使用队列存储尚未交换的节点，每次从队列取出一个结点，交互其左右子结点，直到队列为空。</li>
</ul>
<pre><code class="language-java">class Solution {
    public TreeNode invertTreeRecursively(TreeNode root) {
        if (root == null) {
            return null;
        }

        TreeNode temp = root.left;
        root.left = root.right;
        root.right = temp;
        invertTreeRecursively(root.left);
        invertTreeRecursively(root.right);
        return root;
    }

    public TreeNode invertTreeIteratively(TreeNode root) {
        if (root == null) {
            return null;
        }

        LinkedList&lt;TreeNode&gt; list = new LinkedList&lt;&gt;();
        list.add(root);
        while (list.isEmpty()) {
            TreeNode current = list.poll();
            TreeNode temp = current.left;
            current.left = current.right;
            current.right = temp;

            if (current.left != null) {
                list.add(current.left);
            }
            if (current.right != null) {
                list.add(current.right);
            }
        }
        return root;
    }
}
</code></pre>
<h5 id="分析">分析：</h5>
<p>递归和迭代法一样：</p>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(n)</li>
</ul>
<hr>
<h3 id="326-3-的幂简单">326. 3 的幂（简单）</h3>
<h5 id="描述-2">描述：</h5>
<blockquote>
<p>给定一个整数，写一个函数来判断它是否是 3 的幂次方。</p>
</blockquote>
<h5 id="示例-2">示例：</h5>
<pre><code>输入: 27
输出: true
</code></pre>
<h5 id="思路-2">思路：</h5>
<ul>
<li>解法一：累乘法</li>
<li>解法二：3的幂次质因子只有3，而整数范围内的3的幂次最大是1162261467</li>
</ul>
<h5 id="解法">解法：</h5>
<pre><code class="language-java">class Solution {
    public boolean isPowerOfThree(int n) {
        if (n &lt;= 0) {
            return false;
        }
        if (n == 1) {
            return true;
        }
        long m = 1;
        while (m &lt; n) {
            m *= 3;
            if (m == n) {
                return true;
            }
        }
        return false;
    }

    public boolean isPowerOfThree2(int n) {
        return n &gt; 0 &amp;&amp; 1162261467 % n == 0;
    }
}
</code></pre>
<h5 id="分析-2">分析：</h5>
<p>解法一：</p>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<p>解法二：</p>
<ul>
<li>时间复杂度：O(1)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h2 id="2-review">2. Review</h2>
<p><a href="https://medium.com/@cscalfani/goodbye-object-oriented-programming-a59cda4c0e53">Goodbye, Object Oriented Programming</a> 再见，面向对象编程</p>
<p>作者是个有着多年经验的老程序员，他毫不留情地指出了面向对象编程的问题，分别从封装、继承和多态这三大支柱来阐述。</p>
<ul>
<li>继承最大的好处就是复用。但是出现了「猴子香蕉丛林」问题，我只想要一根香蕉，得到的却是香蕉丛林。钻石问题，继承关系的结构图就像钻石一样，这样容易造成调用混乱。还有基类问题，子类不知道基类的实现，从而引发操作错误。解决办法就是用组合替代继承，原意是包含和委托。</li>
<li>封装使得对象保证内部的变量受保护，然而它却带来了一下问题。引用问题，给构造方法传参时，对象存在多个应用，这样对象就不安全了。解决办法是对象深拷贝，但不是所有对象都支持克隆。</li>
<li>面向对象编程不需要多态，它完全可以基于接口来实现。</li>
</ul>
<p>最后作者告别了面向对象编程，转向函数式编程。</p>
<p>虽然作者举出这么多 OOP 的问题，但是面向对象的思想依然非常流行。软件开发没有银弹，能够实现功能、解决问题的思想都是值得采用的。</p>
<h2 id="3-tip">3. Tip</h2>
<p>日常的琐事都用软件记录，比如有道云笔记、滴答清单、LastPass。大脑是用来思考的，不是用来记东西的，它充当的更多是 CPU 的角色，而不是硬盘。所以，让大脑轻松一下，用工具记录吧。</p>
<h2 id="4-share">4. Share</h2>
<p><a href="https://mp.weixin.qq.com/s/qodCngOPXGSaaBy2ULAgqg">关于线程和I/O模型的极简知识</a> 主要讲述了线程和 I/O 模型的演化历史，问题驱动模型的演化，每种模型都有各自的使用场景。</p>
]]></content>
    </entry>
</feed>