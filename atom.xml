<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://isuperqiang.cn</id>
    <title>落英坠露</title>
    <updated>2019-08-28T14:15:00.887Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://isuperqiang.cn"/>
    <link rel="self" href="https://isuperqiang.cn/atom.xml"/>
    <subtitle>生活不止眼前的苟且，还有诗和远方的田野。</subtitle>
    <logo>https://isuperqiang.cn/images/avatar.png</logo>
    <icon>https://isuperqiang.cn/favicon.ico</icon>
    <rights>All rights reserved 2019, 落英坠露</rights>
    <entry>
        <title type="html"><![CDATA[深入理解计算机系统之计算机系统漫游]]></title>
        <id>https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-ji-suan-ji-xi-tong-man-you</id>
        <link href="https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-ji-suan-ji-xi-tong-man-you">
        </link>
        <updated>2019-08-28T14:11:37.000Z</updated>
        <content type="html"><![CDATA[<h3 id="信息就是位上下文">信息就是位+上下文</h3>
<p>计算机系统中的所有信息——包括磁盘文件、内存中的数据以及网络上传送的数据，都是由一串比特序列表示。区分不同数据对象的唯一方法是我们读到这些数据时的上下文。比如在不同的上下文中，一个同样的字节序列可能表示一个整数、字符串或者机器指令。</p>
<p>这让我想起以前遇到的一个问题。当时用 NDK 开发，错把数组的 JVM 地址直接传递给了 Native，然后程序就运行失败了。同样的内存地址，也就是一段字节序列，在 JVM 和 Native 中的解释不一样，说明信息脱离上下文就没有意义了，传递信息时不能忽略上下文。</p>
<h3 id="程序被编译执行">程序被编译执行</h3>
<p>下面是用 C 语言实现 hello 程序，它是一种人类可读的文本表示，但是计算机只认由 0 和 1 组成的机器指令，C 语句需要被转化为机器语言指令，打包成可执行目标程序，以二进制的磁盘文件形式存放。</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    printf(&quot;Hello world\n&quot;);
    return 0;
}
</code></pre>
<p>在 Unix 系统上，从源文件到目标文件的转化是由编译器驱动程序完成的。</p>
<p><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/Jietu20190115-075112.jpg" alt="编译系统"></p>
<p>为什么要编译才能执行呢？因为 C 语言是高级程序设计语言，计算机无法理解 C 的语句呗。像 Python 这样的脚本语言，源代码需要边解释边执行，这又是另外一种思路，本质上都是翻译为机器代码。</p>
<h3 id="系统的硬件组成">系统的硬件组成</h3>
<p><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/Jietu20190115-075221.jpg" alt="系统硬件组成"></p>
<ol>
<li>总线：贯穿整个系统的一组电子管道。在各个部件间传送定长的字节块，也就是字 word。字长是一个基本的系统参数，要么是 4 个字节（32位），要么是 8 个字节（64位）。</li>
<li>IO 设备：系统与外部世界的联系通道，通过控制器或适配器与 IO 总线相连。</li>
<li>主存：临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。</li>
<li>处理器：CPU，解释或执行存储在主存中指令的引擎。处理器的核心是一个大小为一个字的寄存器，称为程序计数器（PC）。在任何时刻，PC 都指向主存中的某条机器语言指令。</li>
</ol>
<p>上面的组成图也可以用<strong>冯·诺依曼体系结构</strong>解释。处理器负责运算和控制，主存负责存储数据和指令，IO 设备负责输入和输出。</p>
<h3 id="存储设备的层次结构">存储设备的层次结构</h3>
<p><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/Jietu20190115-075353.jpg" alt="存储器层次结构"></p>
<p>存储器层次结构的主要思想是上层的存储器作为下层存储器的高速缓存。</p>
<p>为什么要分层呢？因为读写速度不匹配呗。越靠近 CPU，读写速度越快，当然价格也更高。现在硬件设计的原则是用空间换时间，买电子设备还是选内存大的，因为<strong>时间比空间更值钱</strong>。</p>
<h3 id="操作系统管理硬件">操作系统管理硬件</h3>
<p>操作系统有两个基本功能：</p>
<ol>
<li>防止硬件被失控的应用程序滥用</li>
<li>向应用程序提供简单一致的机制来控制复杂的低级硬件设备</li>
</ol>
<p>操作系统通过几个抽象概念来实现这两个功能，进程、虚拟内存和文件。文件是对 IO 设备的抽象表示，虚拟内存是对主存和磁盘 IO 设备的抽象表示，进程是对处理器、内存和 IO 设备的抽象表示。虚拟机是对整个计算机的抽象，包括操作系统、处理器和程序。指令集架构是对处理器的抽象。</p>
<p><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/Jietu20190115-075700.jpg" alt="计算机系统的抽象"></p>
<p>这里讲的抽象就非常耐人寻味，它简化了系统实现的复杂性。比如，文件操作包括打开、读取、写入和关闭，IO 设备包括本地磁盘、网络存储等。对文件操作都可以抽象出统一的接口，由不同的 IO 设备实现。</p>
<h3 id="进程和线程">进程和线程</h3>
<p>进程是操作系统对一个正在运行的程序的一种抽象。处理器通过在进程间切换的机制（上下文切换）实现并行。</p>
<p>操作系统保持跟踪进程运行所需的所有状态信息，这种状态就是上下文，包括 PC 和寄存器文件的当前值以及主存的内容。上下文切换就是保存当前进程的上下文，恢复新进程的上下文，然后将控制权传递到新进程。</p>
<p><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/Jietu20190115-075513.jpg" alt="进程上下文切换"></p>
<p>从一个进程到另一个进程的切换是由操作系统的内核管理的，内核是操作系统代码常驻主存的部分。它不是一个独立的进程，而是系统管理全部进程所用代码和数据结构的集合。</p>
<p>一个进程实际上由多个线程的组成，每个线程都运行在进程的上下文中，并共享同样的代码和数据。</p>
<p>所以有这样的说法：进程是资源分配的基本单位，线程是任务调度的基本单位。</p>
<p>计算机系统漫游让我们从整体上认识了系统的结构和组成，算是为接下来的学习开了个好头。好的开端是成功的一半。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每周 ARTS 第 21 期]]></title>
        <id>https://isuperqiang.cn/post/mei-zhou-arts-di-21-qi</id>
        <link href="https://isuperqiang.cn/post/mei-zhou-arts-di-21-qi">
        </link>
        <updated>2019-08-25T11:25:36.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-algorithm">1. Algorithm</h2>
<h3 id="24-两两交换链表中的节点中等">24. 两两交换链表中的节点（中等）</h3>
<h5 id="描述">描述：</h5>
<blockquote>
<p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。<br>
你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>
</blockquote>
<h5 id="示例">示例：</h5>
<pre><code>给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.
</code></pre>
<h5 id="思路">思路：</h5>
<ul>
<li>迭代法：从 head 开始遍历，改变相邻节点和它们前后节点之间的关系。</li>
</ul>
<pre><code class="language-java">class Sulution {
    public ListNode swapPairs(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        ListNode curr = head;
        ListNode result = head.next;
        ListNode next;
        ListNode prev = null;
        while (curr != null &amp;&amp; (next = curr.next) != null) {
            ListNode temp = next.next;
            next.next = curr;
            curr.next = temp;
            if (prev != null) {
                prev.next = next;
            }
            prev = curr;
            curr = temp;
        }
        return result;
    }
}
</code></pre>
<ul>
<li>递归法：先处理最后两个或一个节点，然后再从后往前处理每一对节点。</li>
</ul>
<pre><code class="language-java">class Sulution {
    public ListNode swapPairs(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        ListNode next = head.next;
        head.next = swapPairs(next.next);
        next.next = head;
        return next;
    }
}
</code></pre>
<h2 id="2-review">2. Review</h2>
<p><a href="https://medium.com/free-code-camp/how-to-use-git-efficiently-54320a236369">How to use Git efficiently</a> 如何高效地使用 Git</p>
<p>作者通过一个开发场景，讲解了 Git workflow 的使用技巧。在多人协作的开发过程中，分支是重要的代码管理手段。</p>
<p>分支主要分为三种：master、release/、feature/xxx。master 是主分支，它存放的是生产代码的拷贝，任何人都不允许在 master 分支提交代码。release 是发布分支，它从 master 分支创建，可以存在多个并行分支 release/xxx，多个项目在同一个 code base 中时，release 分支可以保证项目并行。feature 是需求分支，它通常从 release 分支创建。每个需求都可以创建新的分支，每个开发者在不同的分支上进行功能开发。然后通过 PR 把代码合并到 release 分支。</p>
<p>通过 pull request，feature 分支的代码合并到 release 分支，主管可以在合并前进行 code review。如果发生合并冲突，解决办法有两种：处理 PR 的主管解决；开发者从 release 分支 pull 最新代码合并到 feature 分支并解决冲突。</p>
<p>项目完成后，release 分支的代码合并到 master 分支，然后发布产品。</p>
<h2 id="3-tip">3. Tip</h2>
<p>最近在维护代码的过程中，发现很多地方写得不够好，重复的代码太多，代码结构有些混乱。有时间我就重构，每个点都仔细推敲，引入经典的设计模式，本着可读性和可维护性好的原则，其他人接手也容易，clean code 原则一定要牢记心间呐。</p>
<h2 id="4-share">4. Share</h2>
<p><a href="https://www.yuque.com/zenany/up/high_productivity_work">高效工作</a> 来自语雀精选</p>
<p>作者从两方面列举了高效工作的做法。</p>
<ul>
<li>增加有效工作时间</li>
<li>提高单位时间的产能</li>
</ul>
<p>高效能的三个要素：<strong>时间、能量和注意力</strong>。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每周 ARTS 第 20 期]]></title>
        <id>https://isuperqiang.cn/post/mei-zhou-arts-di-20-qi</id>
        <link href="https://isuperqiang.cn/post/mei-zhou-arts-di-20-qi">
        </link>
        <updated>2019-08-18T14:16:54.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-algorithm">1. Algorithm</h2>
<h3 id="1116-打印零与奇偶数中等">1116. 打印零与奇偶数（中等）</h3>
<h5 id="描述">描述：</h5>
<blockquote>
<p>有这样一个类 ZeroEvenOdd，相同的一个 ZeroEvenOdd 类实例将会传递给三个不同的线程：</p>
<ul>
<li>
<p>线程 A 将调用 zero()，它只输出 0 。</p>
</li>
<li>
<p>线程 B 将调用 even()，它只输出偶数。</p>
</li>
<li>
<p>线程 C 将调用 odd()，它只输出奇数。</p>
</li>
</ul>
<p>每个线程都有一个 printNumber 方法来输出一个整数。请修改给出的代码以输出整数序列 010203040506... ，其中序列的长度必须为 2n。</p>
</blockquote>
<h5 id="示例">示例：</h5>
<pre><code>输入：n = 2
输出：&quot;0102&quot;
说明：三条线程异步执行，其中一个调用 zero()，另一个线程调用 even()，最后一个线程调用odd()。正确的输出为 &quot;0102&quot;。
</code></pre>
<h5 id="思路">思路：</h5>
<p>线程同步问题，可以使用锁或者信号量解决。</p>
<ul>
<li>解法一：Lock 和 Condition</li>
</ul>
<pre><code class="language-java">    private static class ZeroEvenOdd1 {
        private final Lock lock = new ReentrantLock();
        private final Condition evenCondition = lock.newCondition();
        private final Condition oddCondition = lock.newCondition();
        private final Condition zeroCondition = lock.newCondition();
        private int n;
        private int current = 1;
        // 0 refers zero, 1 refers odd, 2 refers even
        private int state = 0;

        public ZeroEvenOdd1(int n) {
            this.n = n;
        }

        // printNumber.accept(x) outputs &quot;x&quot;, where x is an integer.
        public void zero(IntConsumer printNumber) throws InterruptedException {
            lock.lock();
            try {
                while (current &lt;= n) {
                    if (state != 0) {
                        zeroCondition.await();
                    }
                    printNumber.accept(0);
                    if ((current &amp; 1) == 0) {
                        state = 2;
                        evenCondition.signal();
                    } else {
                        state = 1;
                        oddCondition.signal();
                    }
                    zeroCondition.await();
                }
                oddCondition.signal();
                evenCondition.signal();
            } finally {
                lock.unlock();
            }
        }

        // 偶数
        public void even(IntConsumer printNumber) throws InterruptedException {
            lock.lock();
            try {
                while (current &lt;= n) {
                    if (state != 2) {
                        evenCondition.await();
                    } else {
                        printNumber.accept(current++);
                        state = 0;
                        zeroCondition.signal();
                    }
                }
            } finally {
                lock.unlock();
            }
        }

        // 奇数
        public void odd(IntConsumer printNumber) throws InterruptedException {
            lock.lock();
            try {
                while (current &lt;= n) {
                    if (state != 1) {
                        oddCondition.await();
                    } else {
                        printNumber.accept(current++);
                        state = 0;
                        zeroCondition.signal();
                    }
                }
            } finally {
                lock.unlock();
            }
        }
    }
</code></pre>
<ul>
<li>解法二：Semaphore</li>
</ul>
<pre><code class="language-java">    private static class ZeroEvenOdd2 {
        private final Semaphore zeroSemaphore = new Semaphore(1);
        private final Semaphore evenSemaphore = new Semaphore(0);
        private final Semaphore oddSemaphore = new Semaphore(0);
        private int n;

        public ZeroEvenOdd2(int n) {
            this.n = n;
        }

        // printNumber.accept(x) outputs &quot;x&quot;, where x is an integer.
        public void zero(IntConsumer printNumber) throws InterruptedException {
            for (int i = 1; i &lt;= n; i++) {
                zeroSemaphore.acquire();
                printNumber.accept(0);
                if ((i &amp; 1) == 0) {
                    evenSemaphore.release();
                } else {
                    oddSemaphore.release();
                }
            }
        }

        public void even(IntConsumer printNumber) throws InterruptedException {
            for (int i = 2; i &lt;= n; i += 2) {
                evenSemaphore.acquire();
                printNumber.accept(i);
                zeroSemaphore.release();
            }
        }

        public void odd(IntConsumer printNumber) throws InterruptedException {
            for (int i = 1; i &lt;= n; i += 2) {
                oddSemaphore.acquire();
                printNumber.accept(i);
                zeroSemaphore.release();
            }
        }
    }
</code></pre>
<h2 id="2-review">2. Review</h2>
<p><a href="https://medium.com/free-code-camp/follow-these-simple-rules-and-youll-become-a-git-and-github-master-e1045057468f">Follow these simple rules and you’ll become a Git and GitHub master</a> 遵循这些规范，你就会成为 Git 大师。</p>
<p>作者提出了三条建议：</p>
<ul>
<li>为每个新项目创建 Git 仓库</li>
<li>为每个新需求创建新分支</li>
<li>使用 pull request 合并代码到 master 分支</li>
</ul>
<p>点评：Git 是非常强大的版本控制工具，每个程序员都该熟练掌握。</p>
<h2 id="3-tip">3. Tip</h2>
<p>《高效阅读法》（levarage reading）讲了许多不一样的读书方法。读书不一定要从头开始完整读一遍，只读对自己有用的、感兴趣的地方，无关紧要的内容一律跳过，设定读书的时间限制，比如两小时读完，这样读书速度就提升了一大截。仅仅读了还不够，要运用到生活中，读以致用。 最有效的投资就是自我投资，读书是最好的自我投资。</p>
<h2 id="4-share">4. Share</h2>
<p><a href="https://mp.weixin.qq.com/s/o4CfgIcPibG_QxrsZ4x7sA">技术人如何通过了解业务，获取晋升机会？</a></p>
<p>阿里技术专家的一篇分享，对于技术和业务讲得非常中肯。下面是作者的几个观点：</p>
<ul>
<li>业务先赢是技术第一要务。技术人员首要任务是先把业务支持好，在这个前提下，再来讲技术沉淀和技术红利。</li>
<li>理解业务有助于你做技术决策去驱动业务，有助于你对资源的优先级做判断，而且还有助于提升你的研发效能。</li>
<li>理解业务更多是理解了运营决策背后的原因，理解了网站各个角色的诉求和痛点，理解了自己做的产品和项目对业务的价值和影响。</li>
<li>技术人的三大支柱：业务理解、项目管理和专业技术。一个不理解业务的研发，和流水线的工人是没有很大的区别的。</li>
<li>技术人员不一定要去这么深入理解业务或者成果出在业务上，对技术很感兴趣的同学而且有抓手的同学，就安心地去专研技术并取得结果就好，注意要取得结果，不能是说不清楚的东西。</li>
<li>对于技术上没有鲜明特色的同学，或者有技术深度但是暂时想不到什么技术挖掘点的同学，不妨去多看看业务，寻找技术驱动业务的机会。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每周 ARTS 第 19 期]]></title>
        <id>https://isuperqiang.cn/post/mei-zhou-arts-di-19-qi</id>
        <link href="https://isuperqiang.cn/post/mei-zhou-arts-di-19-qi">
        </link>
        <updated>2019-08-11T14:52:34.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-algorithm">1. Algorithm</h2>
<h3 id="46-全排列中等">46. 全排列（中等）</h3>
<h5 id="描述">描述：</h5>
<blockquote>
<p>给定一个没有重复数字的序列，返回其所有可能的全排列。</p>
</blockquote>
<h5 id="示例">示例：</h5>
<pre><code>输入: [1,2,3]
输出:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
</code></pre>
<h5 id="思路">思路：</h5>
<p>回溯法。深度优先搜索（DFS）和交换元素，</p>
<pre><code class="language-java">class Solution {
    public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) {
        if (nums == null || nums.length == 0) {
            return null;
        }
        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();
        dfs(0, nums, result);
        return result;
    }

    private void dfs(int curr, int[] nums, List&lt;List&lt;Integer&gt;&gt; result) {
        if (curr == nums.length - 1) {
            List&lt;Integer&gt; res = new ArrayList&lt;&gt;();
            for (int num : nums) {
                res.add(num);
            }
            result.add(res);
            return;
        }
        for (int i = curr; i &lt; nums.length; i++) {
            swap(nums, i, curr);
            dfs(curr + 1, nums, result);
            swap(nums, i, curr);
        }
    }

    private void swap(int[] nums, int i, int j) {
        int t = nums[i];
        nums[i] = nums[j];
        nums[j] = t;
    }
}
</code></pre>
<h2 id="2-review">2. Review</h2>
<p><a href="https://engineering.videoblocks.com/these-four-clean-code-tips-will-dramatically-improve-your-engineering-teams-productivity-b5bd121dd150">These four “clean code” tips will dramatically improve your engineering team’s productivity</a> 这四个「整洁代码」的技巧将极大地提高工程团队的生产力</p>
<p>作者列举了整洁代码的四个技巧：</p>
<ul>
<li>
<p>如果没有经过测试，代码就是不合格的</p>
<p>要写大量的测试，特别是单元测试，否则你会后悔的。</p>
</li>
<li>
<p>选择有意义的名字</p>
<p>为变量、类和函数，起一个短小准确的名字。</p>
</li>
<li>
<p>类和函数应该短小，遵循单一职责法则</p>
<p>函数不该超过 4 行，类代码不该超过 100 行。它们做并且只做一件事。</p>
<p>（点评：这里阈值太低，可以适量放大。《阿里巴巴 Java 开发手册》里讲到：方法一般不超过 80 行）</p>
</li>
<li>
<p>函数不该产生副作用</p>
<p>副作用（比如修改输入参数）是魔鬼，代码里面千万不要有，尽可能在函数契约中明确指定这一点。</p>
</li>
</ul>
<h2 id="3-tip">3. Tip</h2>
<p>有时候觉得 IDE 太重量级了，打开个工程都要十几秒。相比之下，Sublime 是轻量级的编辑器，每次几乎秒开，代码显示友好，有丰富的插件。每个程序员都该熟练使用一种 IDE 之外的编辑器，IDE 不总是可靠的，或许也尝试白板编程。</p>
<h2 id="4-share">4. Share</h2>
<p>前些天，有个头条的同行和我聊，说他们面试非常看重基础。基础是什么？我觉得包括这几项：算法和数据结构、操作系统、计算机网络、数据库原理、设计模式等。这些是经久不衰的、不依赖具体语言的基础原理。想要在编程路上走得长远，静下心来研究基础非常必要。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每周 ARTS 第 18 期]]></title>
        <id>https://isuperqiang.cn/post/mei-zhou-arts-di-18-qi</id>
        <link href="https://isuperqiang.cn/post/mei-zhou-arts-di-18-qi">
        </link>
        <updated>2019-08-04T09:41:25.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-algorithm">1. Algorithm</h2>
<h3 id="110-平衡二叉树简单">110. 平衡二叉树（简单）</h3>
<h5 id="描述">描述：</h5>
<blockquote>
<p>给定一个二叉树，判断它是否是高度平衡的二叉树。<br>
本题中，一棵高度平衡二叉树定义为：<br>
一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。</p>
</blockquote>
<h5 id="示例">示例：</h5>
<pre><code>给定二叉树 [3,9,20,null,null,15,7]
    3
   / \
  9  20
    /  \
   15   7
 返回 true
</code></pre>
<h5 id="思路">思路：</h5>
<p>平衡二叉树的条件：</p>
<ul>
<li>左子树是平衡二叉树</li>
<li>右子树是平衡二叉树</li>
<li>左右子树的高度差的绝对值不超过 1</li>
</ul>
<p>深度优先遍历，递归求解树的高度。终止条件是不满足上述三个条件之一，二叉树的最大深度可以参考第 114 题。</p>
<pre><code class="language-java">class Solution {
    public boolean isBalanced(TreeNode root) {
        return height(root) != -1;
    }
    
    private int height(TreeNode root) {
        if (root == null) {
            return 0;
        }
        int leftHeight = height(root.left);
        int rightHeight = height(root.right);
        if (leftHeight == -1 || rightHeight == -1 
                || Math.abs(leftHeight - rightHeight) &gt; 1) {
            return -1;
        }
        return Math.max(leftHeight, rightHeight) + 1;
    }
}
</code></pre>
<h5 id="分析">分析：</h5>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h2 id="2-review">2. Review</h2>
<p><a href="https://maker.pro/linux/tutorial/basic-linux-commands-for-beginners">Basic Linux Commands for Beginners</a> 为新手准备的 Linux 命令</p>
<p>Linux 是免费、开源的操作系统内核，你可以修改 Linux 上的任何东西，并用自己的名字重新发布，比如 Ubuntu、Debian、Red Hat 等版本。</p>
<p>Linux 主要应用于服务器上，世界上 90% 的服务器都运行 Linux 系统，因为它安全、快速并且免费。Android 手机占据智能机的 80%，它也是基于 Linux 内核。大多数的病毒出现在 Windows 上，而不是 Linux。</p>
<p>shell 是一个程序，它接收用户的命令，并传递给系统执行，然后显示结果。Linux 有个命令行界面，是 shell 的主要交互部分。</p>
<p>接下来，作者列举了一些基本的命令：cd/ls/pwd/mkdir/rm/touch/man/cp/mv/cat/sudo/echo/df/vi/tar/apt-get/chmod/ping 等。</p>
<h2 id="3-tip">3. Tip</h2>
<p><a href="https://github.com/robbyrussell/oh-my-zsh">oh my zsh</a> 非常强大的 shell，拥有丰富的插件和主题，只支持 macOS 和 Linux。不愧是终极 Shell，提高 10x 效率没问题。有时候一成不变挺悲哀的，尝试折腾一下才有乐趣。Have a try, you will enjoy it.</p>
<h2 id="4-share">4. Share</h2>
<p>程序员应该学习 Linux，理解设计理想，熟悉常用命令。对于高手来说，一个 Terminal 就够了。在 macOs 或 Linux 下开发，比 Windows 省心多了。首先没有字符编码的问题，其次 Unix-like 平台上有非常多的开发工具，程序员用了绝对爱不释手。另外，Unix-like 平台上的软件不像 Windows 系统上那样流氓，而且不容易感染病毒。值得庆幸的是，Windows 10 内置了 Linux，我们可以下载 Ubuntu 体验。虽然是阉割版，但用来学习够用了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每周 ARTS 第 17 期]]></title>
        <id>https://isuperqiang.cn/post/mei-zhou-arts-di-17-qi</id>
        <link href="https://isuperqiang.cn/post/mei-zhou-arts-di-17-qi">
        </link>
        <updated>2019-07-28T11:37:11.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-algorithm">1. Algorithm</h2>
<h3 id="1114-按序打印简单">1114. 按序打印（简单）</h3>
<h5 id="描述">描述：</h5>
<blockquote>
<p>三个不同的线程将会共用一个 Foo 实例，它们会被异步启动。</p>
<ul>
<li>
<p>线程 A 将会调用 one() 方法</p>
</li>
<li>
<p>线程 B 将会调用 two() 方法</p>
</li>
<li>
<p>线程 C 将会调用 three() 方法</p>
<p>请设计修改程序，以确保 two() 方法在 one() 方法之后被执行，three() 方法在 two() 方法之后被执行。</p>
</li>
</ul>
</blockquote>
<h5 id="示例">示例：</h5>
<pre><code>输入: [1,2,3]
输出: &quot;onetwothree&quot;
解释: 
有三个线程会被异步启动。
输入 [1,2,3] 表示线程 A 将会调用 one() 方法，线程 B 将会调用 two() 方法，线程 C 将会调用 three() 方法。
正确的输出是 &quot;onetwothree&quot;。
</code></pre>
<h5 id="思路">思路：</h5>
<p>排序的思路就是 线程 C 等待线程 B 执行完毕，线程 B 等待线程 A 执行完毕，通过线程阻塞的方式实现，JUC 提供了许多的多线程工具类。</p>
<ul>
<li>解法一：CountDownLoatch</li>
</ul>
<pre><code class="language-java">  /**
     * 通过 CountDownLatch
     */
    public static class Foo1 {
        private CountDownLatch countDownLatchSecond = new CountDownLatch(1);
        private CountDownLatch countDownLatchThird = new CountDownLatch(1);

        public void first(Runnable printFirst) throws InterruptedException {
            printFirst.run();
            countDownLatchSecond.countDown();
        }

        public void second(Runnable printSecond) throws InterruptedException {
            countDownLatchSecond.await();
            printSecond.run();
            countDownLatchThird.countDown();
        }

        public void third(Runnable printThird) throws InterruptedException {
            countDownLatchThird.await();
            printThird.run();
        }
    }
</code></pre>
<ul>
<li>解法二：Object 内置锁</li>
</ul>
<pre><code class="language-java">    /**
     * 通过 Object 内置锁
     */
    public static class Foo2 {
        private final Object lock = new Object();
        private int state = 1;

        public void first(Runnable printFirst) throws InterruptedException {
            synchronized (lock) {
                printFirst.run();
                state = 2;
                lock.notifyAll();
            }
        }

        public void second(Runnable printSecond) throws InterruptedException {
            synchronized (lock) {
                while (state != 2) {
                    lock.wait();
                }
                printSecond.run();
                state = 3;
                lock.notifyAll();
            }
        }

        public void third(Runnable printThird) throws InterruptedException {
            synchronized (lock) {
                while (state != 3) {
                    lock.wait();
                }
                printThird.run();
            }
        }
    }
</code></pre>
<ul>
<li>解法三：Lock 和 Condition</li>
</ul>
<pre><code class="language-java">    /**
     * 通过 Lock 和 Condition
     */
    public static class Foo3 {
        private Lock lock = new ReentrantLock();
        private Condition condition = lock.newCondition();
        private int state = 1;

        public void first(Runnable printFirst) throws InterruptedException {
            lock.lock();
            try {
                printFirst.run();
                state = 2;
                condition.signalAll();
            } finally {
                lock.unlock();
            }
        }

        public void second(Runnable printSecond) throws InterruptedException {
            lock.lock();
            try {
                while (state != 2) {
                    condition.await();
                }
                printSecond.run();
                state = 3;
                condition.signalAll();
            } finally {
                lock.unlock();
            }
        }

        public void third(Runnable printThird) throws InterruptedException {
            lock.lock();
            try {
                while (state != 3) {
                    condition.await();
                }
                printThird.run();
            } finally {
                lock.unlock();
            }
        }
    }
</code></pre>
<ul>
<li>解法四：Semaphore</li>
</ul>
<pre><code class="language-java">    /**
     * 通过 Semaphore
     */
    public static class Foo4 {
        private Semaphore semaphoreSecond = new Semaphore(0);
        private Semaphore semaphoreThird = new Semaphore(0);

        public void first(Runnable printFirst) throws InterruptedException {
            printFirst.run();
            semaphoreSecond.release();
        }

        public void second(Runnable printSecond) throws InterruptedException {
            semaphoreSecond.acquire();
            printSecond.run();
            semaphoreThird.release();
        }

        public void third(Runnable printThird) throws InterruptedException {
            semaphoreThird.acquire();
            printThird.run();
        }
    }
</code></pre>
<h2 id="2-review">2. Review</h2>
<p><a href="https://www.lifehack.org/articles/technology/20-tips-use-google-search-efficiently.html">20 Google Search Tips to Use Google More Efficiently</a> 用好谷歌搜索的 20 条技巧</p>
<ol>
<li>使用 Tab 分类，比如图片、新闻、视频等</li>
<li>使用双引号，精确匹配关键词，比如： “浪潮之巅 吴军”</li>
<li>使用连字符 <code>-</code> 排除词语，比如：见识 -吴军</li>
<li>使用冒号 <code>site:url</code> 搜索指定网站，比如：吴军 site:dangdang.com</li>
<li>查找链接到另一个页面的页面 <code>link:url</code>，比如：link:qq.com</li>
<li>使用星号 <code>*</code> 通配符，比如：生活不止 * 苟且</li>
<li>查找与其他网站相似的网站 <code>related:url</code>，比如：related:amazon.com</li>
<li>用谷歌搜索做数学，比如：8 * 5 + 5</li>
<li>一个搜索多个关键词 <code>OR</code>，比如：巧克力 OR 白巧克力</li>
<li>搜索一系列数字 <code>..</code>，比如：41..43</li>
<li>保持简单，比如：附近的披萨店</li>
<li>逐渐添加搜索词，比如：
<ul>
<li>首先尝试：工作面试</li>
<li>其次尝试：准备工作面试</li>
<li>再次尝试：如何准备工作面试</li>
</ul>
</li>
<li>使用网站会用的词汇，比如：“我头疼”可以换成“头痛缓解”</li>
<li>只用重要的词汇，比如：
<ul>
<li>不要用：我从哪儿可以找到提供配送的餐馆？</li>
<li>而要用：附近的餐馆</li>
</ul>
</li>
<li>谷歌搜索有快捷方式，就像上面的计算器一样。比如：北京时间、杭州天气</li>
<li>拼写不那么重要，谷歌搜索会帮你纠正语法和词汇。</li>
<li>使用描述性词语，比如：如何安装 Ubuntu 的驱动？</li>
<li>查找特定文件 <code>filetype:pdf</code>，比如：文明之光 filetype:pdf</li>
<li>货币和单位换算，</li>
<li>追踪你的包裹</li>
</ol>
<p>谷歌搜索是最棒的搜索工具，比某度好一万倍，善用谷歌是一种高效的方式。</p>
<h2 id="3-tip">3. Tip</h2>
<p>推荐一个静态博客写作客户端 <a href="https://github.com/getgridea/gridea">Gridea</a>，使用它可以方便地管理文章，进行分类、打标签等，一键同步到 GitHub，提供了多套主题，支持配置域名和评论功能，Windows、Mac 、Linux 全平台支持。我的<a href="https://isuperqiang.cn/">博客</a>托管在 GitHub 上，以前使用 <a href="https://hexo.io/zh-cn/">Hexo</a> 发布，但是没有本地管理功能，想修改文章非常麻烦。现在用 Gridea 发布，果然优雅了不少啊。</p>
<h2 id="4-share">4. Share</h2>
<p>程序员一般不喜欢写文档，遇到问题时又骂别人不写文档。在我看来，文档和代码一样重要，开源库的 API 文档写得清晰明了，开发者使用时也省心。最怕的是，过了一段时间，自己的代码都捋不清了。所以，尽可能多些文档吧，为了自己也为了接盘侠 :)</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每周 ARTS 第 16 期]]></title>
        <id>https://isuperqiang.cn/post/mei-zhou-arts-di-16-qi</id>
        <link href="https://isuperqiang.cn/post/mei-zhou-arts-di-16-qi">
        </link>
        <updated>2019-07-20T10:26:43.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-algorithm">1. Algorithm</h2>
<h3 id="152-乘积最大子序列中等">152. 乘积最大子序列（中等）</h3>
<h5 id="描述">描述：</h5>
<blockquote>
<p>给定一个整数数组 nums ，找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）。</p>
</blockquote>
<h5 id="示例">示例：</h5>
<pre><code>输入: [2,3,-2,4]
输出: 6
解释: 子数组 [2,3] 有最大乘积 6。
</code></pre>
<h5 id="思路">思路：</h5>
<ul>
<li>解法一：暴力解法，遍历数组，逐个求出连续子序列的乘积，和当前最大值比较，找到最大值。</li>
<li>解法二：动态规划，遍历数组，计算当前最大值，并不断更新。当前最大乘积 max，当前最小乘积 min。由于存在负数，会导致最大的变成最小的，最小的变成最大的。所以分两种情况讨论：
<ul>
<li>nums[i] &gt; 0 时，max = Max(max * nums[i], nums[i]); min = Min(min * num[i], num[i]);</li>
<li>nums[i] &lt; 0 时，max = Max(min * nums[i], nums[i]); min = Min(max * num[i], num[i]);</li>
</ul>
</li>
</ul>
<pre><code class="language-java">class Solution {
    public int maxProduct1(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }
        int max = nums[0];
        int temp;
        for (int i = 0; i &lt; nums.length; i++) {
            temp = nums[i];
            if (temp &gt; max) {
                max = temp;
            }
            for (int j = i + 1; j &lt; nums.length; j++) {
                temp *= nums[j];
                if (temp &gt; max) {
                    max = temp;
                }
            }
        }
        return max;
    }

    public int maxProduct2(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }
        int ret = nums[0];
        int min = nums[0];
        int max = nums[0];
        for (int i = 1; i &lt; nums.length; i++) {
            if (nums[i] &lt; 0) {
                int temp = min;
                min = max;
                max = temp;
            }
            max = Math.max(max * nums[i], nums[i]);
            min = Math.min(min * nums[i], nums[i]);
            ret = Math.max(ret, max);
        }
        return ret;
    }
}
</code></pre>
<h5 id="分析">分析：</h5>
<ul>
<li>时间复杂度：
<ul>
<li>解法一：O(n^2)</li>
<li>解法二：O(n)</li>
</ul>
</li>
<li>空间复杂度都是 O(1)</li>
</ul>
<h2 id="2-review">2. Review</h2>
<p><a href="http://tutorials.jenkov.com/java-concurrency/java-memory-model.html">Java Memory  Model</a> 主要讲述了 Java 内存模型、硬件内存架构和两者之间的差异。</p>
<p>Java 内存模型把内存分为线程栈和堆。每个线程都有各自的线程栈，线程栈内部包含方法调用信息和方法内局部变量，它不能被其他线程访问。线程栈存储的局部变量，包括「基本数据类型和引用变量」的拷贝，而引用的对象存储在堆中。堆用来存储应用创建的对象，不管是局部对象还是成员对象，不论是哪个线程创建的。</p>
<p>硬件内存架构包含 CPU 寄存器、高速缓存和 RAM 主存，按照前面的顺序，读写速度越来越慢，容量越来越大。当 CPU 读取数据时，会把数据缓存在寄存器和高速缓存中。当 CPU 写回数据时，会把数据从寄存器和高速缓存刷新到 RAM。</p>
<p>Java 内存模型和硬件模型架构不同，通常线程栈和堆在 RAM 中，但有时也会在寄存器和高速缓存中。当变量存储在计算机的不同位置时，就会引发两个主要问题：多线程读写变量的可见性和竞态条件。使用 volatile 可以解决可见性问题，synchronized 可以解决竞态条件。</p>
<h2 id="3-tip">3. Tip</h2>
<p>刷题的时候看到了 override 和 overload，结合前段时间读过的《码出高效：Java开发手册》中的内容，重新梳理了一下知识点：<a href="https://isuperqiang.cn/post/shen-ru-li-jie-java-zhong-de-override-he-overload/">深入理解 Java 中的 override 和 overload</a>。</p>
<h2 id="4-share">4. Share</h2>
<p>多学一些东西总没有错，所谓「技多不压身」。别人不懂的你能做，别人现学现查，你信手拈来，别人浮于表面，你深入原理。这都是机会，是优势，机会总是留给有准备的人。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[深入理解 Java 中的 override 和 overload]]></title>
        <id>https://isuperqiang.cn/post/shen-ru-li-jie-java-zhong-de-override-he-overload</id>
        <link href="https://isuperqiang.cn/post/shen-ru-li-jie-java-zhong-de-override-he-overload">
        </link>
        <updated>2019-07-20T03:25:13.000Z</updated>
        <summary type="html"><![CDATA[<p>override 和 overload，分别翻译为覆写和重载，是 Java 多态（Polymorphism）的两种代表类型。下面详细分析一下 override 和 overload 的使用方式。</p>
]]></summary>
        <content type="html"><![CDATA[<p>override 和 overload，分别翻译为覆写和重载，是 Java 多态（Polymorphism）的两种代表类型。下面详细分析一下 override 和 overload 的使用方式。</p>
<!-- more -->
<h3 id="1-override">1. override</h3>
<p>override 出现在继承关系中，子类覆写父类的实例方法，为它提供专门的实现。举个例子：</p>
<pre><code class="language-java">public class Animal {
    public void bark() {
        System.out.println(&quot;动物叫声&quot;);
    }
}

public class Cat extends Animal {
    @Override
    public void bark() {
        System.out.println(&quot;喵喵&quot;);
    }
}

    public static void main(String[] args) {
        // 向上转型
				Animal cat = new Cat();
        cat.bark(); // 打印 喵喵
    }
</code></pre>
<p>override 的绑定发生在运行期，属于动态绑定，由实例对象决定调用哪个方法，动态绑定是多态性得以实现的重要因素。这里有几点需要注意的地方：</p>
<ul>
<li>子类的方法访问权限只能相同或变大。比如父类方法是 protected，子类可以是 public，不能是 private。</li>
<li>抛出异常和返回值只能变小，它们能够转型成父类对象。比如父类方法返回值 Number，子类可以返回 Integer，不能返回 Object。</li>
<li>方法签名必须完全相同。方法签名包括方法名称和参数列表，是 JVM 标识方法的唯一索引，不包括返回值，其中参数列表分为类型和个数。</li>
<li>覆写方法必须要加上 <code>@Override</code> 注解，为了使编译器自动检查覆写是否满足规则。</li>
</ul>
<p>覆写只能用于类的不被 final 和 private 修饰的实例方法，不能用于静态方法，如果父类和子类中存在同名的静态方法，那么两者都可以被正常调用。</p>
<h3 id="2-overload">2. overload</h3>
<p>overload 出现在同一个类中，多个方法具有相同名字、不同的参数。举个例子：</p>
<pre><code class="language-java">public class Cat {
    public void bark() {
        System.out.println(&quot;喵喵&quot;);
    }

    public void bark(int num) {
        for (int i = 1; i &lt;= num; i++) {
            System.out.println(&quot;第 &quot; + i + &quot; 声喵喵&quot;);
        }
    }
}
</code></pre>
<p>overload 的绑定发生在编译期，属于静态绑定，由方法签名决定调用哪个方法。需要注意的是，方法签名包括方法名称、参数类型和个数，不包括返回值。</p>
<p>当重载的方法参数比较复杂时，JVM 选择合适的目标方法的顺序如下：</p>
<ul>
<li>精确匹配</li>
<li>如果是基本数据类型，自动转换成更大表示范围的基本类型</li>
<li>通过自动拆箱与装箱</li>
<li>通过子类向上转型继承路线依次匹配</li>
<li>通过可变参数匹配</li>
</ul>
<p>下面通过例子说明。</p>
<ol>
<li>基本数据类型优先于包装数据类型。</li>
</ol>
<pre><code class="language-java">    public void mo(int a) {
        System.out.println(&quot;primary int type&quot;);
    }

    public void mo(Integer a) {
        System.out.println(&quot;wrapper int type&quot;);
    }

    Cat cat = new Cat();
    cat.mo(1); // 打印 primary int type
</code></pre>
<ol start="2">
<li>更大范围的基本数据类型优先于包装数据类型。</li>
</ol>
<pre><code class="language-java">    public void mo(long a) {
        System.out.println(&quot;primary long type&quot;);
    }

    public void mo(Integer a) {
        System.out.println(&quot;wrapper int type&quot;);
    }
    
    Cat cat = new Cat();
    cat.mo(1); // 打印 primary long type
</code></pre>
<ol start="3">
<li>null 可以匹配任何类对象，从最底层子类依次向上查找。</li>
</ol>
<pre><code class="language-java">    public void mo(Integer a) {
        System.out.println(&quot;wrapper int type&quot;);
    }

    public void mo(Object a) {
        System.out.println(&quot;object type&quot;);
    }

//  如果包含 String 参数，那么编译器不知道匹配哪个，直接报错。
//  public void mo(String s) {
//      System.out.println(&quot;string type&quot;);
//  }

    Cat cat = new Cat();
    cat.mo(null); // 打印 wrapper int type
</code></pre>
<ol start="4">
<li>自动装箱和拆箱优先于可变参数。</li>
</ol>
<pre><code class="language-java">    public void mo(Integer a, Integer b){
        System.out.println(&quot;double wrapper int type&quot;);
    }

    public void mo(int... a) {
        System.out.println(&quot;primary int array type&quot;);
    }
    
    Cat cat = new Cat();
    cat.mo(1, 2); // 打印 double wrapper int type
</code></pre>
<p>...</p>
<p>重载的参数类型应该简洁些，这样才能提高代码的可读性。</p>
<h3 id="3-总结">3. 总结</h3>
<p>override 和 overload 有很多不同之处：</p>
<ul>
<li>override 属于动态绑定，在运行期通过实例对象决定调用的方法；overload 属于静态绑定，在编译期通过方法签名决定调用的方法。</li>
<li>override 基于继承关系，需要父类和子类参与；overload 出现在同一个类中，通过方法签名区分。</li>
<li>static、final、private 方法不能被 override，但是可以被 overload。</li>
<li>override 关注方法返回值，overload 不关注返回值。</li>
<li>override 的方法参数必须一样，overload 的方法参数必须不同。</li>
<li>overload 的性能比 override 更好些，应为它是静态绑定。</li>
</ul>
<p><strong>参考：</strong></p>
<ul>
<li>《码出高效：Java开发手册》</li>
<li><a href="https://stackoverflow.com/questions/19017258/static-vs-dynamic-binding-in-java">Static Vs. Dynamic Binding in Java</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每周 ARTS 第 15 期]]></title>
        <id>https://isuperqiang.cn/post/mei-zhou-arts-di-15-qi</id>
        <link href="https://isuperqiang.cn/post/mei-zhou-arts-di-15-qi">
        </link>
        <updated>2019-07-14T12:05:07.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-algorithm">1. Algorithm</h2>
<h3 id="287-寻找重复数中等">287. 寻找重复数（中等）</h3>
<h5 id="描述">描述：</h5>
<blockquote>
<p>给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。</p>
</blockquote>
<h5 id="示例">示例：</h5>
<pre><code>输入: [1,3,4,2,2]
输出: 2
</code></pre>
<h5 id="说明">说明：</h5>
<ul>
<li>不能更改原数组（假设数组是只读的）。</li>
<li>只能使用额外的 O(1) 的空间。</li>
<li>时间复杂度小于 O(n2) 。</li>
<li>数组中只有一个重复的数字，但它可能不止重复出现一次。</li>
</ul>
<h5 id="思路">思路：</h5>
<p>数组元素在 [0, n] 之间，可以作为数组索引使用。先通过快慢指针找到相交点，然后两个指针分别从零位置和相交点一起向前遍历，直到找出相同的值。</p>
<pre><code class="language-java">class Solution {
    public int findDuplicate(int[] nums) {
        if (nums == null || nums.length == 0) {
            return -1;
        }

        int fast = nums[0];
        int slow = nums[0];
        do {
            slow = nums[slow];
            fast = nums[nums[fast]];
        } while (fast != slow);

        slow = nums[0];
        while (fast != slow) {
            slow = nums[slow];
            fast = nums[fast];
        }
        return fast;
    }
}
</code></pre>
<h5 id="分析">分析：</h5>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h2 id="2-review">2. Review</h2>
<p><a href="https://medium.com/@rhamedy/key-habits-and-things-i-wish-i-knew-earlier-as-a-developer-43c9466a0407">Key habits and things I wish I knew earlier as a developer</a> 作为开发者，我希望尽早知道的习惯和事情</p>
<p>作者总结了开发者应该尽早熟知的东西，比如习惯、技能、观念等。</p>
<ul>
<li>有效地使用搜索引擎</li>
<li>使用现代化的 IDE 提高生产力</li>
<li>学习 Linux</li>
<li>学习 Git</li>
<li>自我学习，跟随技术潮流</li>
<li>至少精通一门编程语言</li>
<li>聚焦简约</li>
<li>加入团体或者论坛</li>
<li>建立你的个人档案</li>
<li>提问，提问，提问</li>
<li>写代码前先在纸上比划</li>
<li>遵守技术规范，先写测试用例</li>
<li>在日常中解决难题和挑战</li>
<li>开始白板编程</li>
<li>高效地管理时间</li>
<li>保护个人隐私</li>
<li>跟随激励你的个人和组织</li>
<li>参加技术活动</li>
<li>拥抱错误消息</li>
<li>选择正确类型的公司作为事业</li>
<li>建立一套工作方案，不断迭代使其完美</li>
<li>对自己 SEO</li>
</ul>
<p>下面几点需要注意：</p>
<ul>
<li>不轻言放弃</li>
<li>不拷贝工程代码</li>
<li>不要推迟</li>
<li>不要忽略其他学科</li>
<li>不要沉迷社交网络</li>
<li>不是失去希望</li>
</ul>
<h2 id="3-tip">3. Tip</h2>
<p><a href="https://brew.sh/">Homebrew</a> 真是 Mac 上的神器，软件开发包都可以通过命令安装，自动配置环境变量，brew cask 还可以安装 GUI 应用程序。brew 在手，软件我有。</p>
<h2 id="4-share">4. Share</h2>
<p>公司 Q2 季度考核，根据实际情况，自评打了高分，我觉得是对的。caoz 有篇文章：<a href="https://mp.weixin.qq.com/s/0emM3IyruRxhBzMVPpeTpQ">你矜持，你活该</a> 讲过。</p>
<p>职场不要太矜持，合作沟通的时候姿态低一些，争取权益的时候胆子大一些。</p>
<p>创业不能太矜持， 宣传营销的时候，该吹牛的时候敢吹牛，不要怕丢脸。业务合作的时候，该低姿态的时候低姿态，不要老端着。</p>
<p>有些技术人才我知道的，在企业不是很顺心，有些权益期待但没有落实，又觉得老板一直对自己不错，总觉得不好意思提要求，其实该争取的要争取，人家稍微温情两句，自己就开始自责了，哪那么多戏。</p>
<p>你矜持，你端着，你失去好机会，你权益无保障，你自废武功，你男/女神被人追跑了，你活该。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每周 ARTS 第 14 期]]></title>
        <id>https://isuperqiang.cn/post/mei-zhou-arts-di-14-qi</id>
        <link href="https://isuperqiang.cn/post/mei-zhou-arts-di-14-qi">
        </link>
        <updated>2019-07-07T08:25:11.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-algorithm">1. Algorithm</h2>
<h3 id="78-子集中等">78. 子集（中等）</h3>
<h5 id="描述">描述：</h5>
<blockquote>
<p>给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。解集不能包含重复的子集。</p>
</blockquote>
<h5 id="示例">示例：</h5>
<pre><code>输入: nums = [1,2,3]
输出:
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]
</code></pre>
<h5 id="思路">思路：</h5>
<p>利用二进制与位运算：<br>
数组中的每个元素，都有两个状态：在子数组中和不在子数组中。所有状态的组合就是所有的子数组。<br>
遍历 000 到 111，也就是 0 到 7，判断每个比特位是否为 1，如果是 1，那么将对应数字加入子数组。</p>
<pre><code class="language-java">class Solution {
    public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) {
        if (nums == null || nums.length == 0) {
            return Collections.emptyList();
        }

        List&lt;Integer&gt; subList;
        int resultLength = 1 &lt;&lt; nums.length;
        List&lt;List&lt;Integer&gt;&gt; resultList = new ArrayList&lt;&gt;(resultLength);
        for (int i = 0, numsLength = nums.length; i &lt; resultLength; i++) {
            subList = new ArrayList&lt;&gt;(numsLength);
            for (int j = 0; j &lt; numsLength; j++) {
                if ((i &gt;&gt; j &amp; 1) == 1) {
                    subList.add(nums[j]);
                }
            }
            resultList.add(subList);
        }
        return resultList;
    }
}
</code></pre>
<h5 id="分析">分析：</h5>
<ul>
<li>时间复杂度：O(n^2)</li>
<li>空间复杂度：O(n)</li>
</ul>
<h2 id="2-review">2. Review</h2>
<p><a href="https://blog.usejournal.com/what-i-learned-in-my-first-two-years-as-a-software-engineer-4e374fdcf0fd">What I Learned in My First Two Years as a Software Engineer</a> 在我做软件工程师的前两年里学到了什么</p>
<p>作者讲了两个故事。</p>
<p>第一个故事，读大学时导师布置任务，完成好的学生会被分到一组，完成差的学生要么努力挤进好学生队伍，要么放弃，好学生不会帮助差学生，导师奖励做得好的学生。然而进入公司后，如果再采用这种原则，同事之间不免发生矛盾。完成任务不是唯一的事情，与同事的关系和硬技能同样重要。</p>
<p>第二个故事，作者在结对编程时遇到了 Bob，Bob 经常对项目提出问题，帮助作者解决潜在的 bug，此时无招胜有招，因此作者非常佩服 Bob。优秀的问题解决者在给出方案之前，会提出很多问题，用论证影响团队的成员，表现出领导力。</p>
<p>最后，作者总结了一些教训。处理好与同事的关系，编程不比家庭、友谊、健康重要，尽可能做最好的工程师。</p>
<h2 id="3-tip">3. Tip</h2>
<p>《Java并发编程实战》中讲到单例设计模式的几种线程安全的实现方式：延迟初始化、提前初始化、延迟初始化占位类和双重检查锁。其中，双重检查锁的实例变量要声明为 volatile 才有效，作者称其为糟糕的实现，不如静态的占位类优雅。</p>
<h2 id="4-share">4. Share</h2>
<p>近期在优化项目代码，发现在渲染每帧图像的时候，存在大量无用的对象创建。这么来看，Android 屏幕的刷新速率是 60 FPS，高密集地创建对象导致堆空间占满，造成频繁的垃圾回收，不利于程序的性能。我们要避免这种操作，做一个环保的程序员。</p>
]]></content>
    </entry>
</feed>