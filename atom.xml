<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://isuperqiang.cn</id>
    <title>落英坠露</title>
    <updated>2020-06-07T15:23:56.207Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://isuperqiang.cn"/>
    <link rel="self" href="https://isuperqiang.cn/atom.xml"/>
    <subtitle>生活不止眼前的苟且，还有诗和远方的田野。</subtitle>
    <logo>https://isuperqiang.cn/images/avatar.png</logo>
    <icon>https://isuperqiang.cn/favicon.ico</icon>
    <rights>All rights reserved 2020, 落英坠露</rights>
    <entry>
        <title type="html"><![CDATA[每周 ARTS 第 32 周]]></title>
        <id>https://isuperqiang.cn/post/mei-zhou-arts-di-32-zhou/</id>
        <link href="https://isuperqiang.cn/post/mei-zhou-arts-di-32-zhou/">
        </link>
        <updated>2020-06-07T15:22:45.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-algorithm">1. Algorithm</h2>
<h4 id="路径总和"><a href="https://leetcode-cn.com/problems/path-sum/">路径总和</a>（简单）</h4>
<h4 id="描述">描述：</h4>
<blockquote>
<p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。<br>
叶子节点是指没有子节点的节点。</p>
</blockquote>
<h4 id="示例">示例：</h4>
<pre><code>给定如下二叉树，以及目标和 sum = 22，
              5
             / \
            4   8
           /   / \
          11  13  4
         /  \      \
        7    2      1
</code></pre>
<h4 id="思路">思路：</h4>
<p>从根节点开始遍历，每次遍历时从目标和减去当前节点值，当作子节点要凑的和，在叶子节点判断是否刚好凑齐。</p>
<pre><code class="language-java">class Sulution {
    pbulic boolean hasPathSum(TreeNode root, int sum) {
        if (root == null) {
            return false;
        }
        if (root.left == null &amp;&amp; root.right == null) {
            return sum == root.val;
        }
        int csum = sum - root.val;
        return hasPathSum(root.left, csum) || hasPathSum(root.right, csum);
    }
}
</code></pre>
<h4 id="分析">分析：</h4>
<ul>
<li>时间复杂度：O(N)</li>
<li>空间复杂度：O(log(N)) or O(N)</li>
</ul>
<h2 id="2-review">2. Review</h2>
<p><a href="https://medium.com/mind-cafe/a-3-minute-hack-for-focus-youve-probably-never-heard-of-40708b788a0f">A 3-Minute Hack for Focus You’ve Probably Never Heard Of</a> 你从未听说过的 3 分钟聚焦大法</p>
<p>作者一直无法专注工作，同事分享了一个方法给他——双耳节拍。本质上，双耳节拍是重复播放的音乐。它没有实际的节拍，而是在大脑中产生的同时播放两个不同频率的音调。</p>
<p>我一直在用的产品叫「小睡眠」，它主要功能是助眠，但是也有聚焦和放松模式。配合降噪耳机，很快便进入高效工作中。</p>
<h2 id="3-tip">3. Tip</h2>
<p>接手维护老项目，开发者代码设计得烂，不知道怎么代码怎么调用，也无处安放 debug 点。这时只要创建一个异常，打印它的 stack track，就能够对调用时序一目了然。查看源码时也可以通过这种办法确定调用流程。</p>
<h2 id="4-share">4. Share</h2>
<p><a href="https://cyc2018.github.io/CS-Notes/#/">CS-Notes</a> GitHub 100k+ star 的项目，技术面试必备基础知识、Leetcode、计算机操作系统、计算机网络、系统设计、Java 等。</p>
<p>面试前可以刷一刷，主要是增加知识面的广度。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每周 ARTS 第 31 周]]></title>
        <id>https://isuperqiang.cn/post/mei-zhou-arts-di-31-zhou/</id>
        <link href="https://isuperqiang.cn/post/mei-zhou-arts-di-31-zhou/">
        </link>
        <updated>2020-05-26T23:46:49.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-algorithm">1. Algorithm</h2>
<h4 id="环形链表-ii"><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">环形链表 II</a>（中等）</h4>
<h4 id="描述">描述：</h4>
<blockquote>
<p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。<br>
为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。<br>
说明：不允许修改给定的链表。</p>
</blockquote>
<h4 id="示例">示例：</h4>
<pre><code>输入：head = [3,2,0,-4,2], pos = 1
输出：tail connects to node index 1
解释：链表中有一个环，其尾部连接到第二个节点。
</code></pre>
<h4 id="思路">思路：</h4>
<p>快慢指针：使用快慢指针从头遍历链表，如果两个指针相遇则表示链表有环。然后让慢指针从头开始，快指针继续向前，两者再次相遇点就是环的入口。这个地方用图解释更清晰，推荐阅读 <a href="https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/shuang-zhi-zhen-ji-qiao">双指针技巧总结</a>。</p>
<pre><code class="language-java">class Sulution {
    public ListNode detectCycle(ListNode head) {
       if (head == null || head.next == null) {
            return null;
        }
        ListNode fast = head;
        ListNode slow = head;
        boolean hasCycle = false;
        while (fast != null &amp;&amp; fast.next != null) {
            fast = fast.next.next;
            slow = slow.next;
            if (fast == slow) {
                hasCycle = true;
                break;
            }
        }
        if (!hasCycle) {
            return null;
        }
        slow = head;
        while (fast != slow) {
            fast = fast.next;
            slow = slow.next;
        }
        return slow;
    }
}
</code></pre>
<h4 id="分析">分析：</h4>
<ul>
<li>时间复杂度：O(N)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h2 id="2-review">2. Review</h2>
<p><a href="https://medium.com/backticks-tildes/the-s-o-l-i-d-principles-in-pictures-b34ce2f1e898">The S.O.L.I.D Principles in Pictures</a> 图画讲解 SOLID 原则</p>
<p>本文介绍了面向对象编程的 SOLID 原则，每个原则下面都有漫画说明，挺有趣的。</p>
<ul>
<li>单一职责原则：每个类应该只有一个职责，包含一组强相关的行为。</li>
<li>开闭原则：类应该对扩展开放，对修改关闭。扩展功能要增加行为而不是修改它。</li>
<li>里氏替换原则：如果 S 是 T 的子类，那么 T 出现的地方就该被 S 替换并不需要改动代码。</li>
<li>接口隔离原则：类不应该依赖不需要的行为，需要把行为拆分成更小的粒度。</li>
<li>依赖反转原则：高层模块不该依赖低层模块，他们都该依赖抽象；抽象不该依赖细节，细节该依赖抽象。</li>
</ul>
<h2 id="3-tip">3. Tip</h2>
<p>重构项目代码的过程中，遇到不美观的地方，用新技术方案完美解决。<a href="https://isuperqiang.cn/post/shi-yong-android-jia-gou-zu-jian-lifecycle-you-hua-dai-ma/">使用Android架构组件Lifecycle优化代码</a></p>
<h2 id="4-share">4. Share</h2>
<p>B站有个不错的视频 <a href="https://www.bilibili.com/video/BV1EW411u7th">计算机科学速成课</a>，从计算机历史、硬件、软件、编程等方面介绍，是计算机科学的基础知识，当作科普也不错，推荐大家看看。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用Android架构组件Lifecycle优化代码]]></title>
        <id>https://isuperqiang.cn/post/shi-yong-android-jia-gou-zu-jian-lifecycle-you-hua-dai-ma/</id>
        <link href="https://isuperqiang.cn/post/shi-yong-android-jia-gou-zu-jian-lifecycle-you-hua-dai-ma/">
        </link>
        <updated>2020-05-26T23:23:34.000Z</updated>
        <content type="html"><![CDATA[<p>Android developers 提供的支持库越来越完善，不知大家在开发中有没有升级 <a href="https://developer.android.com/jetpack">Jetpack</a>，也就是引入 androidX 包，Jetpack 确实简化了代码，提升了效率。下面介绍架构组件中的 Lifecycle，官网的介绍：<a href="https://developer.android.com/topic/libraries/architecture/lifecycle">使用生命周期感知型组件处理生命周期</a> 非常详细，我就介绍一下 Lifecycle 在开发中的实践。</p>
<h3 id="1-重构之前">1. 重构之前</h3>
<p>项目中有许多组件和 Activity 的生命周期有关联，比如 SensorManager 在 resume 时注册，pause 时解除注册。Camera 在 resume 时打开，pause 时关闭等。代码写起来就像下面这样：</p>
<pre><code class="language-java">    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        mSensorManager = (SensorManager) getSystemService(SENSOR_SERVICE);
        mSensor = mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);
    }   

    @Override
    protected void onResume() {
        super.onResume();
        mSensorManager.registerListener(this, mSensor, SensorManager.SENSOR_DELAY_NORMAL);
      // manage other components that need to respond
            // to the activity lifecycle
    }

    @Override
    protected void onPause() {
        super.onPause();
        mSensorManager.unregisterListener(this);
      // manage other components that need to respond
            // to the activity lifecycle
    }
</code></pre>
<p>如果需要响应 Activity 生命周期的组件非常多，那么代码将变得非常臃肿难以维护。组件对外暴露的状态接口太多，稍不留神就会出错，这种转发式的调用并不是优雅的做法。</p>
<h3 id="2-重构之后">2. 重构之后</h3>
<p>抽离 Sensor 相关代码形成新类，封装 Sensor 注册、解除注册和监听操作，最重要的是可感知生命周期。本质上是观察者设计模式，Activity 是 LifecycleOwner，具有 Lifecycle，是被观察者；LifeCycleSensorManager 实现 LifecyclerObserver 接口，是观察者。外部不需要传递生命周期状态进来，LifeCycleSensorManager 内部可感知生命周期。这样使用时，只要一行代码即可，非常干净清爽。</p>
<pre><code class="language-java">public final class LifeCycleSensorManager implements LifecycleObserver, SensorEventListener {
    private Sensor mSensor;
    private SensorManager mSensorManager;
    private Lifecycle mLifecycle;

    public LifeCycleSensorManager(final Context context, final Lifecycle lifecycle) {
        mSensorManager = (SensorManager) context.getSystemService(Context.SENSOR_SERVICE);
        mSensor = mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);
        lifecycle.addObserver(this);
        mLifecycle = lifecycle;
    }

    @OnLifecycleEvent(Lifecycle.Event.ON_RESUME)
    public void onResume() {
        mSensorManager.registerListener(this, mSensor, SensorManager.SENSOR_DELAY_NORMAL);
    }

    @OnLifecycleEvent(Lifecycle.Event.ON_PAUSE)
    public void onPause() {
        mSensorManager.unregisterListener(this);
    }

    @OnLifecycleEvent(Lifecycle.Event.ON_DESTROY)
    public void onDestroy() {
        mLifecycle.removeObserver(this);
    }

    @Override
    public void onSensorChanged(SensorEvent event) {
    }

    @Override
    public void onAccuracyChanged(Sensor sensor, int accuracy) {
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每周 ARTS 第 30 周]]></title>
        <id>https://isuperqiang.cn/post/mei-zhou-arts-di-30-zhou/</id>
        <link href="https://isuperqiang.cn/post/mei-zhou-arts-di-30-zhou/">
        </link>
        <updated>2020-05-19T00:10:13.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-algorithm">1. Algorithm</h2>
<h4 id="零钱兑换"><a href="https://leetcode-cn.com/problems/coin-change/">零钱兑换</a>（中等）</h4>
<h5 id="描述">描述：</h5>
<blockquote>
<p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。<br>
你可以认为每种硬币的数量是无限的。</p>
</blockquote>
<h5 id="示例">示例：</h5>
<pre><code>输入: coins = [1, 2, 5], amount = 11
输出: 3 
解释: 11 = 5 + 5 + 1
</code></pre>
<h5 id="思路">思路：</h5>
<p>动态规划：dp[i] 表示总金额为 i 时至少需要的硬币个数，初始赋值 amount+1 表示不可能取到的值。注意总金额要不小于硬币面值，而且保证总金额可以被硬币凑出来。</p>
<pre><code class="language-java">class Sulution {
    public int coinChange(int[] coins, int amount) {
        if (coins == null || coins.length == 0) {
            return -1;
        }
        int length = amount + 1;
        int[] dp = new int[length];
        Arrays.fill(dp, length);
        dp[0] = 0;
        for (int i = 0; i &lt; dp.length; i++) {
            for (int coin : coins) {
                if (i &gt;= coin) {
                    dp[i] = Math.min(dp[i], dp[i - coin] + 1);
                }
            }
        }
        return dp[amount] == length ? -1 : dp[amount];
    }
}
</code></pre>
<h5 id="分析">分析：</h5>
<ul>
<li>时间复杂度：O(N * k)，k 为硬币个数</li>
<li>空间复杂度：O(N)</li>
</ul>
<h2 id="2-review">2. Review</h2>
<p><a href="https://medium.com/@magnus.chatt/why-you-should-totally-switch-to-kotlin-c7bbde9e10d5">Why you should totally switch to Kotlin</a> 为什么你该完全切换到 Kotlin</p>
<p>介绍了 Kotlin 的特性，与 Java 互操作、类型推断、空安全、数据类等，Kotlin 是现代化的语言，其特性会令开发者喜欢。</p>
<h2 id="3-tip">3. Tip</h2>
<p>遇到 crash 如何解决呢？分享一下我的经验。</p>
<p>首先查看 stack trace，找到报错的类型、信息、代码文件和行数，常见的异常有 NullPointerException、ClassCastException、IndexOutOfBoundException 等，根据信息就大概可以知道报错原因。如果之前没见过这种异常，把信息复制粘贴到谷歌搜索，排名靠前的搜索结果都来自 Stack Overflow，说不定前人也碰到了类似的错误，从问题回复中就能找到答案，这就要求英文阅读能力要过关。最后如果实在搜不到，那只能请教大佬了。</p>
<h2 id="4-share">4. Share</h2>
<p>分享两个网站，收录了 Windows 和 Mac 平台上的优质软件。</p>
<ul>
<li><a href="https://github.com/Awesome-Windows/Awesome/blob/master/README-cn.md">Awesome-Windows</a></li>
<li><a href="https://github.com/jaywcjlove/awesome-mac/blob/master/README-zh.md">Awesome-Mac</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每周 ARTS 第 29 周]]></title>
        <id>https://isuperqiang.cn/post/mei-zhou-arts-di-29-zhou/</id>
        <link href="https://isuperqiang.cn/post/mei-zhou-arts-di-29-zhou/">
        </link>
        <updated>2020-05-12T13:19:24.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-algorithm">1. Algorithm</h2>
<h4 id="颠倒二进制位"><a href="https://leetcode-cn.com/problems/reverse-bits/">颠倒二进制位</a>（简单）</h4>
<h5 id="描述">描述：</h5>
<blockquote>
<p>颠倒给定的 32 位无符号整数的二进制位。</p>
</blockquote>
<h5 id="示例">示例：</h5>
<pre><code>输入: 00000010100101000001111010011100
输出: 00111001011110000010100101000000
解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，
因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。
</code></pre>
<h5 id="思路">思路：</h5>
<ul>
<li>逐位颠倒：从右向左遍历二进制串，用 n&amp;1 取得最右一位，然后左移该值到对应位置，和结果值求和，退出条件是 n == 0。</li>
</ul>
<pre><code class="language-java">class Sulution {
    // you need treat n as an unsigned value
    public int reverseBits(int n) {
        int ret = 0;
        for (int bitsSize = 31; n != 0; bitsSize--) {
            ret += (n &amp; 1) &lt;&lt; bitsSize;
            n = n &gt;&gt;&gt; 1;
        }
        return ret;
    }
}
</code></pre>
<h5 id="分析">分析：</h5>
<ul>
<li>时间复杂度：O(1)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h2 id="2-review">2. Review</h2>
<p><a href="https://medium.com/free-code-camp/the-code-im-still-ashamed-of-e4c021dff55e">The code I’m still ashamed of</a> 至今令我惭愧的代码</p>
<p>作者回忆了刚开始工作时为医药公司做网站，先让用户做测验然后推荐药物，目标是年轻女性。在庆功聚会前，作者看到一条新闻，一名服用药物的女子自杀了，由药物的副作用导致。回家后发现自己的妹妹也在用这种药，作者马上就制止了她。不久后作者便离职了，自此每次写代码前都要三思代码带来的影响。</p>
<blockquote>
<p>作为开发人员，我们通常是防范潜在危险和不道德行为的最后一道防线。</p>
</blockquote>
<h2 id="3-tip">3. Tip</h2>
<p>最近重构了部分项目代码，对此有些感悟。在重构的过程中，对业务会有更深的理解，编程就是把现实世界抽象成代码结构。同时看到以前代码的糟糕之处，毫不犹豫地删掉重写，目的就是提升可读性、可用性和可维护性。</p>
<p>《重构，改善既有代码的设计》这本书值得每位程序员阅读。任何一个傻瓜都能写出计算机可以理解的代码，唯有写出人类可以理解的代码，才是优秀的程序员。</p>
<h2 id="4-share">4. Share</h2>
<p>最近在看极客时间上《许式伟的架构课》，讲到操作系统很棒，特地分享出来。 <a href="https://time.geekbang.org/column/article/4b4426d9ac4cb25d7f82325a893b494f/share?code=w%2Fj%2F7UNTJpAHk25ddhtU5iTaKNYvSTs5a5gk-p9iOJs%3D">操作系统进场</a></p>
<p><strong>精华部分：</strong></p>
<p>从客户需求来说，操作系统的核心价值在于：</p>
<ul>
<li>
<p>实现软件治理，让多个软件和谐共处；</p>
</li>
<li>
<p>提供基础的编程接口，降低软件开发难度。</p>
</li>
</ul>
<p>从商业价值来说，操作系统是刚性需求，核心的流量入口，兵家必争之地。所以，围绕它的核心能力，操作系统必然会不断演化出新的形态。早期预装软件是一种流量变现的方式。后来苹果引入了 “账号 - 支付 - 应用市场” 商业闭环的收税模式。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每周 ARTS 第 28 周]]></title>
        <id>https://isuperqiang.cn/post/mei-zhou-arts-di-28-zhou/</id>
        <link href="https://isuperqiang.cn/post/mei-zhou-arts-di-28-zhou/">
        </link>
        <updated>2020-05-03T09:48:29.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-algorithm">1. Algorithm</h2>
<h4 id="旋转数组"><a href="https://leetcode-cn.com/problems/rotate-array/">旋转数组</a>（简单）</h4>
<h5 id="描述">描述：</h5>
<blockquote>
<p>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。<br>
尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。<br>
要求使用空间复杂度为 O(1) 的原地算法。</p>
</blockquote>
<h5 id="示例">示例：</h5>
<pre><code>输入: [1,2,3,4,5,6,7] 和 k = 3
输出: [5,6,7,1,2,3,4]
</code></pre>
<h5 id="思路">思路：</h5>
<ul>
<li>暴力解法：循环 K 次，每次移动一个元素。时间复杂度：O(k*N)，空间复杂度：O(1)。</li>
</ul>
<pre><code class="language-java">class Sulution {
    public void rotate(int[] nums, int k) {
        if (nums == null || nums.length == 0) {
            return;
        }
        int length = nums.length;
        int temp;
        for (int i = 0; i &lt; k; i++) {
            temp = nums[length - 1];
            for (int j = length - 1; j &gt; 0; j--) {
                nums[j] = nums[j - 1];
            }
            nums[0] = temp;
        }
    }
}
</code></pre>
<ul>
<li>额外空间：使用额外数组保存旋转后的元素，把原数组下标是 i 的元素放到临时数组 (i+k)%nums.length 的位置，然后写回原数组。时间复杂度：O(N)，空间复杂度：O(N)。</li>
</ul>
<pre><code class="language-java">class Sulution {
    public void rotate(int[] nums, int k) {
        if (nums == null || nums.length == 0) {
            return;
        }
        int[] temp = new int[nums.length];
        for (int i = 0; i &lt; nums.length; i++) {
            temp[(i + k) % nums.length] = nums[i];
        }
        System.arraycopy(temp, 0, nums, 0, nums.length);
    }
}
</code></pre>
<ul>
<li>环状替换：计算每个元素的最终位置，每次迭代时替换到正确位置并保存被替换的值，计算被替换值的正确位置。以 K 为步长跳跃，如果跳跃回原地，就从下一个位置继续。时间复杂度：O(N)，空间复杂度：O(1)。</li>
</ul>
<pre><code class="language-java">class Sulution {
    public void rotate(int[] nums, int k) {
        if (nums == null || nums.length == 0) {
            return;
        }
        k = k % nums.length;
        int count = 0;
        for (int start = 0; count &lt; nums.length; start++) {
            int currentI = start;
            int currentE = nums[start];
            do {
                int nextI = (currentI + k) % nums.length;
                int temp = nums[nextI];
                nums[nextI] = currentE;
                currentE = temp;
                currentI = nextI;
                count++;
            } while (start != currentI);
        }
    }
}
</code></pre>
<ul>
<li>三次反转：当我们旋转数组 k 次， k%n 个尾部元素会被移动到头部，剩下的元素会被向后移动。时间复杂度：O(N)，空间复杂度：O(1)。</li>
</ul>
<pre><code class="language-java">class Sulution {
  // 原始数组                  : 1 2 3 4 5 6 7
  // 反转所有数字后             : 7 6 5 4 3 2 1
  // 反转前 k 个数字后          : 5 6 7 4 3 2 1
  // 反转后 n-k 个数字后        : 5 6 7 1 2 3 4 --&gt; 结果
    public void rotate(int[] nums, int k) {
        if (nums == null || nums.length == 0) {
            return;
        }
        k = k % nums.length;
        reverse(nums, 0, nums.length - 1);
        reverse(nums, 0, k - 1);
        reverse(nums, k, nums.length - 1);
    }
    
    private void reverse(int[] arr, int start, int end) {
        while (start &lt; end) {
            int temp = arr[start];
            arr[start] = arr[end];
            arr[end] = temp;
            start++;
            end--;
        }
    }
}
</code></pre>
<h2 id="2-review">2. Review</h2>
<p><a href="https://levelup.gitconnected.com/programming-habits-you-should-adopt-8ab75419fb09">Programming Habits You Should Adopt</a> 你应该养成的编程习惯</p>
<p>作者列举了 7 个编程习惯：</p>
<ul>
<li>不要写重复代码。遇到重复代码，就该考虑重构了。</li>
<li>一旦认为自己完成了，开始重构吧。实现需求并不代表完成，接下来就该重构。</li>
<li>聚焦业务逻辑。不要总是专注于业务之外的技术栈，做好工作内容更重要。</li>
<li>短小精简的提交。便于回滚排查问题和代码审查。</li>
<li>一致性很关键。坚持标准的代码规范，提升代码的可维护性。</li>
<li>多做一步。完成任务意味着解决 todo，单元测试，编写文档。</li>
<li>不要停止学习。一直做自己熟练的事情，是不会得到成长的。</li>
</ul>
<h2 id="3-tip">3. Tip</h2>
<p>近期看了 Kotlin 语言，感觉是增强型的 Java，简洁灵活安全省心。同样基于 JVM，弥补 Java 的不足，编程语言总是在进化，Google 力推 Kotlin 作为 Android 开发语言是正确的。建议新项目尝试 Kotlin，老项目继续用 Java，两者还可以混编。Have a try 😃</p>
<h2 id="4-share">4. Share</h2>
<p>在 Twitter 上看到陈皓发的推文，从程序员职业发展的角度评论编程语言，有生命力、有市场需求的语言值得投入。原帖在这里：https://twitter.com/haoel/status/1254974994964086785</p>
<figure data-type="image" tabindex="1"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/EWqQTnKU4AES4-K.png" alt="有生命力语言的特征" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/EWqQRcGUcAAKt6z.png" alt="陈皓评论语言" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每周 ARTS 第 27 期]]></title>
        <id>https://isuperqiang.cn/post/mei-zhou-arts-di-27-qi/</id>
        <link href="https://isuperqiang.cn/post/mei-zhou-arts-di-27-qi/">
        </link>
        <updated>2020-04-25T11:15:04.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-algorithm">1. Algorithm</h2>
<h4 id="搜索二维矩阵-ii"><a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/">搜索二维矩阵 II</a>（中等）</h4>
<h5 id="描述">描述：</h5>
<blockquote>
<p>编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性：<br>
每行的元素从左到右升序排列。<br>
每列的元素从上到下升序排列。</p>
</blockquote>
<h5 id="示例">示例：</h5>
<pre><code>现有矩阵 matrix 如下：
[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]
给定 target = 5，返回 true。
给定 target = 20，返回 false。
</code></pre>
<h5 id="思路">思路：</h5>
<p>从左下角出发，把 target 和当前值比较。如果 target 大于当前值，就往右走；如果小于，就往上走。如果等于，就返回 true。</p>
<pre><code class="language-java">class Sulution {
    public boolean searchMatrix(int[][] matrix, int target) {
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
            return false;
        }
        int row = matrix.length - 1;
        int column = 0;
        int columnLength = matrix[0].length;
        while (row &gt;= 0 &amp;&amp; column &lt; columnLength) {
            if (matrix[row][column] &gt; target) {
                row--;
            } else if (matrix[row][column] &lt; target) {
                column++;
            } else {
                return true;
            }
        }
        return false;
    }
}
</code></pre>
<h5 id="分析">分析：</h5>
<ul>
<li>时间复杂度：O(M+N)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h2 id="2-review">2. Review</h2>
<p><a href="https://medium.com/@alexewerlof/my-guiding-principles-after-20-years-of-programming-a087dc55596c">My guiding principles after 20 years of programming</a>  <a href="https://www.infoq.cn/article/VEgR7xkNIYUsSWP9Ohc3">20 年老程序员告诉你的 20 条编码原则</a></p>
<p>软件开发的历史没多久，20年经验的程序员也比较稀缺。作者总结了编程的经验和原则，对刚入门不久的新人有很大启发。比如第一条不要纠结于开发工具，不管是库、编程语言或平台。总是有人争吵什么是最好的语言，其实抛开具体业务场景谈是没有意义的。</p>
<h2 id="3-tip">3. Tip</h2>
<p>断点调试是排查问题的好方法，其效率比打印 log 要高。不管是 Native 库还是 Java 库，都可以用断点调试，一步步执行代码，查看变量值和函数跳转。</p>
<h2 id="4-share">4. Share</h2>
<p><strong>为什么需要软件架构?</strong></p>
<p>早在 1986 年的时候，人月神话的作者在讨论软件的复杂性时，谈到：软件的本质复杂性存在于复杂的业务需求中。</p>
<p>而管理复杂性，最根本的手段就是职责分离。为了实现职责分离，代码重用，架构慢慢地复现出来。架构的本质是管理复杂性。</p>
<p>没有架构，我们所有的代码都耦合在一起，人类的心智模型不擅长处理这种复杂性，架构的设立，和图书馆的图书分类，公司的组织划分等，本质都是一样的。是为了管理复杂性，以取得更高的生产力。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每周 ARTS 第 26 期]]></title>
        <id>https://isuperqiang.cn/post/mei-zhou-arts-di-26-qi/</id>
        <link href="https://isuperqiang.cn/post/mei-zhou-arts-di-26-qi/">
        </link>
        <updated>2020-04-19T14:02:16.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-algorithm">1. Algorithm</h2>
<h4 id="判定字符是否唯一"><a href="https://leetcode-cn.com/problems/is-unique-lcci/">判定字符是否唯一</a>（简单）</h4>
<h5 id="描述">描述：</h5>
<blockquote>
<p>实现一个算法，确定一个字符串 s 的所有字符是否全都不同。</p>
</blockquote>
<h5 id="示例">示例：</h5>
<pre><code>输入: s = &quot;leetcode&quot;
输出: false 
输入: s = &quot;abc&quot;
输出: true
</code></pre>
<h5 id="思路">思路：</h5>
<ul>
<li>统计次数：使用一个额外的 int 数组，统计每个字符出现的次数。</li>
<li>位运算：int 类型有 32 位，取其中的低 26 位，作为每个字符的标志位，通过左移、与、或运算，记录每个字符的对应位置。真是高级解法！</li>
</ul>
<pre><code class="language-java">class Sulution {
    public boolean isUnique1(String astr) {
        if (astr == null || astr.length() == 0) {
            return true;
        }
        int[] counts = new int[26];
        for (int i = 0, length = astr.length(); i &lt; length; i++) {
            int pos = astr.charAt(i) - 'a';
            if (counts[pos] &gt;= 1) {
                return false;
            }
            counts[pos] += 1;
        }
        return true;
    }

    public boolean isUnique2(String astr) {
        if (astr == null || astr.length() == 0) {
            return true;
        }
        int mark = 0;
        for (int i = 0, length = astr.length(); i &lt; length; i++) {
            int flag = 1 &lt;&lt; (astr.charAt(i) - 'a');
            if ((mark &amp; flag) != 0) {
                return false;
            } else {
                mark |= flag;
            }
        }
        return true;
    }
}
</code></pre>
<h5 id="分析">分析：</h5>
<p>统计次数：</p>
<ul>
<li>时间复杂度：O(N)</li>
<li>空间复杂度：O(N)</li>
</ul>
<p>位运算：</p>
<ul>
<li>时间复杂度：O(N)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h2 id="2-review">2. Review</h2>
<p><a href="https://levelup.gitconnected.com/how-to-go-from-junior-to-senior-programmer-29d53f3edd27">How to Go from Junior to Senior Programmer</a>  <a href="https://www.infoq.cn/article/6gagslvv3x5oQLpaVpv8">如何从初级程序员变成高级程序员？</a></p>
<p>从 InfoQ 看到的一篇译文，算是经验之谈。高工不是根据经验判定，而是分析的技能。深有同感，我总是把代码放在第一位，有时候忽略了业务场景，考虑问题的出发点不同，导致任务处理方式也不同。代码只是一部分，真正的目的是解决问题。</p>
<blockquote>
<p>一名程序员不会因为他会写代码而成为一名合格的程序员，而是因为在开始做任何事情之前先做分析，然后再来开展工作，这才是真正的程序员。</p>
</blockquote>
<h2 id="3-tip">3. Tip</h2>
<p>最近某 BAT 之一坑害了 pandownload，真的是令人发指！自己的产品做得烂不去反思，却耍小伎俩坑无辜的开发者。天下苦 B 久矣，作为程序员，从抵制 B 开始。推荐一个好用的木弟子 <a href="https://neoproxy.me/?rc=r1gv64bl">AgentNeo</a>，线路非常稳定，价格也实惠。通过我的链接注册，可以享受 5 元优惠 https://neoproxy.me/?rc=r1gv64bl。（结算时选择团购下单，团购代码 21853G0V，享受 8 折优惠，活动截止 2020-04-25）</p>
<h2 id="4-share">4. Share</h2>
<p>在 GitHub 上搜了一些 Android 面试资料 http://note.youdao.com/noteshare?id=a04ac812925b23f6dc112eda70079c53 愿步步高升。</p>
<p><strong>题外话：</strong></p>
<p>由于个人原因，ARTS 暂停了将近半年，后续恢复打卡，请见谅。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[深入理解计算机系统之并发编程（二）]]></title>
        <id>https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-bing-fa-bian-cheng-er/</id>
        <link href="https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-bing-fa-bian-cheng-er/">
        </link>
        <updated>2020-01-16T13:10:44.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1-多线程程序中的共享变量">1. 多线程程序中的共享变量</h3>
<p>一组并发线程运行在一个进程的上下文中。每个线程都有自己独立的线程上下文，包括线程 ID、栈、<br>
栈指针、程序计数器、条件码和通用目的寄存器值。每个线程和其他线程共享进程上下文的剩余部分，<br>
包括用户虚拟地址空间，它是由只读文本（代码）、读/写数据、堆以及共享库代码和<br>
数据区组成的。线程也共享相同的打开文件的集合。</p>
<p>寄存器是从不共享的，虚拟内存总是共享的。</p>
<p>多线程的 C 程序中的变量根据它们的存储类型被影射到虚拟内存：</p>
<ul>
<li>全局变量：定义在函数之外的变量，虚拟内存中只有一个实例，任何线程都能引用。</li>
<li>本地自动变量：定义在函数内但没有 static 属性的变量，每个线程都有自己的实例。</li>
<li>本地静态变量：定义在函数内并有 static 属性的变量，和全部变量一样。</li>
</ul>
<p>多线程实现计数器，每个线程对共享变量操作，容易出现同步错误。</p>
<p>进度图将 n 个并发线程的执行，模型化为一条 n 维笛卡尔空间中的轨迹线。每条轴 k 对应<br>
线程 k 的进度，每个点代表线程 k 已经完成指令的状态。</p>
<p>每个线程在执行临界区（critical section）的指令时，拥有对共享变量的互斥（mutual exclusion）访问。<br>
在进度图中，两个临界区的交集形成的状态空间称为不安全区，绕开不安全区的轨迹线叫做安全轨迹线。</p>
<p>任何安全轨迹线都会正确地更新共享变量，为了保证线程化程序的正确执行，我们必须以某种方式同步线程。</p>
<figure data-type="image" tabindex="1"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20191227085650.png" alt="安全和不安全轨迹线" loading="lazy"></figure>
<h3 id="2-使用信号量同步线程">2. 使用信号量同步线程</h3>
<p>一种经典的解决线程同步问题的方法：信号量（semephore）。它是具有非负整数的全局变量，只能由两种特殊的操作处理，成为 P 和 V。P 和 V 来源于荷兰语，分别表示测试和增加。</p>
<p>P 中的测试和减一操作是不可分割的，V 中的加一操作也是不可分割的。当多个线程等待同一个信号量时，<br>
无法预测 V 操作也重启哪个线程。</p>
<p>使用信号量可以确保对共享变量的互斥访问。基本思想是将每个共享变量与一个信号量 s （初始为 1）关联起来，<br>
然后用 P(s) 和 V(s) 操作将相应的临界区包围起来。这种保护共享变量的信号量称为二元信号量，<br>
以提供互斥为目的的二元信号量称为互斥锁。</p>
<p>除了提供互斥外，信号量的另一个重要作用是调度对共享资源的访问。比如生产者-消费者问题，读者-写者问题。</p>
<h3 id="3-使用线程提高并行性">3. 使用线程提高并行性</h3>
<p>所有程序的集合被划分为不相交的顺序程序集合和并发程序的结合，并行程序是一种运行在多个处理器上的并发程序。</p>
<p>来看一个用多线程对整数序列求和的问题，将序列划分为多个不相交的区域，给每个线程分配一个区域。</p>
<ul>
<li>第一种做法，将每个线程求得的和放入共享的全局变量中，用互斥锁保护这个变量。结果性能非常差，同步操作的代价太大。</li>
<li>第二种做法，定义一个全局数组，每个对等线程把和累积在数组的不同位置。同时，使用局部变量消除不必要的内存引用。最终性能提升明显。</li>
</ul>
<p>同步开销巨大，要尽可能避免。如果无可避免，必须要用尽可能多的有用计算弥补这个开销。</p>
<p>随着线程数量的增加，程序运行时间不会一直减少，由于线程上下文切换的开销。</p>
<h3 id="4-其他并发问题">4. 其他并发问题</h3>
<p>可重入(reentrant)函数：当被多个线程调用时，不会引用任何共享数据。比不可重入的线程安全的函数高效一些，因为它不需要同步操作。</p>
<p>避免死锁(deadlock)：给定所有互斥操作的一个全序，如果每个线程都以一种顺序获得互斥锁并以相反的顺序<br>
释放，那么这个程序就是无死锁的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[libyuv 库编译]]></title>
        <id>https://isuperqiang.cn/post/libyuv-ku-bian-yi/</id>
        <link href="https://isuperqiang.cn/post/libyuv-ku-bian-yi/">
        </link>
        <updated>2020-01-04T12:17:26.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://chromium.googlesource.com/libyuv/libyuv">libyuv</a> 是谷歌开源的对 YUV 数据进行缩放、旋转和转换的跨平台库，可在 Windows、Linux、Mac、Android 等操作系统，x86、x64、arm 架构上进行编译运行，支持 AVX2、NEON 等 SIMD 指令加速。</p>
<p>官方介绍的几个功能：</p>
<ul>
<li>可以使用 point，bilinear 或 box 三种方法进行 YUV 的压缩</li>
<li>可以转换为 RGB 来实现渲染/特效</li>
<li>旋转 90/180/270 的角度以适配设备的竖屏模式</li>
<li>可以把 webcam 转换为 YUV 来进行压缩</li>
<li>还有一系列的平台性能优化等</li>
</ul>
<p>接下来让我们编译 libyuv，编译步骤在 Windows 和 Mac 上都验证成功，下面以 Mac 为例。</p>
<h3 id="1-clone-libyuv-源码">1. clone libyuv 源码</h3>
<p>既然要编译库，怎么少得了源码呢？</p>
<pre><code>git clone https://chromium.googlesource.com/libyuv/libyuv
</code></pre>
<h3 id="2-重命名文件夹">2. 重命名文件夹</h3>
<p>clone 的文件夹叫做 libyuv，这里要把它修改为 jni。</p>
<h3 id="3-修改-androidmk">3. 修改 Android.mk</h3>
<p>注释 jpeg 相关的代码，其他地方不用改动。</p>
<figure data-type="image" tabindex="1"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/clipboard2.png" alt="fix-jpeg1" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/clipboard3.png" alt="fix-jpeg2" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/clipboard.png" alt="fix-jpeg3" loading="lazy"></figure>
<p>下面是修改后的 Android.mk 文件内容：</p>
<pre><code># This is the Android makefile for libyuv for NDK.
LOCAL_PATH:= $(call my-dir)

include $(CLEAR_VARS)

LOCAL_CPP_EXTENSION := .cc

LOCAL_SRC_FILES := \
    source/compare.cc           \
    source/compare_common.cc    \
    source/compare_gcc.cc       \
    source/compare_mmi.cc       \
    source/compare_msa.cc       \
    source/compare_neon.cc      \
    source/compare_neon64.cc    \
    source/convert.cc           \
    source/convert_argb.cc      \
    source/convert_from.cc      \
    source/convert_from_argb.cc \
    source/convert_to_argb.cc   \
    source/convert_to_i420.cc   \
    source/cpu_id.cc            \
    source/planar_functions.cc  \
    source/rotate.cc            \
    source/rotate_any.cc        \
    source/rotate_argb.cc       \
    source/rotate_common.cc     \
    source/rotate_gcc.cc        \
    source/rotate_mmi.cc        \
    source/rotate_msa.cc        \
    source/rotate_neon.cc       \
    source/rotate_neon64.cc     \
    source/row_any.cc           \
    source/row_common.cc        \
    source/row_gcc.cc           \
    source/row_mmi.cc           \
    source/row_msa.cc           \
    source/row_neon.cc          \
    source/row_neon64.cc        \
    source/scale.cc             \
    source/scale_any.cc         \
    source/scale_argb.cc        \
    source/scale_common.cc      \
    source/scale_gcc.cc         \
    source/scale_mmi.cc         \
    source/scale_msa.cc         \
    source/scale_neon.cc        \
    source/scale_neon64.cc      \
    source/video_common.cc

common_CFLAGS := -Wall -fexceptions
# ifneq ($(LIBYUV_DISABLE_JPEG), &quot;yes&quot;)
# LOCAL_SRC_FILES += \
#     source/convert_jpeg.cc      \
#     source/mjpeg_decoder.cc     \
#     source/mjpeg_validate.cc
# common_CFLAGS += -DHAVE_JPEG
# LOCAL_SHARED_LIBRARIES := libjpeg
# endif

LOCAL_CFLAGS += $(common_CFLAGS)
LOCAL_EXPORT_C_INCLUDES := $(LOCAL_PATH)/include
LOCAL_C_INCLUDES += $(LOCAL_PATH)/include
LOCAL_EXPORT_C_INCLUDE_DIRS := $(LOCAL_PATH)/include

LOCAL_MODULE := libyuv_static
LOCAL_MODULE_TAGS := optional

include $(BUILD_STATIC_LIBRARY)

include $(CLEAR_VARS)

LOCAL_WHOLE_STATIC_LIBRARIES := libyuv_static
# 生成库的名称
LOCAL_MODULE := libyuv
# ifneq ($(LIBYUV_DISABLE_JPEG), &quot;yes&quot;)
# LOCAL_SHARED_LIBRARIES := libjpeg
# endif

# 生成静态库还是动态库
# BUILD_STATIC_LIBRSRY 静态库
# BUILD_SHARED_LIBRARY 动态库
include $(BUILD_SHARED_LIBRARY)

include $(CLEAR_VARS)
LOCAL_STATIC_LIBRARIES := libyuv_static
# LOCAL_SHARED_LIBRARIES := libjpeg
LOCAL_MODULE_TAGS := tests
LOCAL_CPP_EXTENSION := .cc
LOCAL_C_INCLUDES += $(LOCAL_PATH)/include
LOCAL_SRC_FILES := \
    unit_test/unit_test.cc        \
    unit_test/basictypes_test.cc  \
    unit_test/color_test.cc       \
    unit_test/compare_test.cc     \
    unit_test/convert_test.cc     \
    unit_test/cpu_test.cc         \
    unit_test/cpu_thread_test.cc  \
    unit_test/math_test.cc        \
    unit_test/planar_test.cc      \
    unit_test/rotate_argb_test.cc \
    unit_test/rotate_test.cc      \
    unit_test/scale_argb_test.cc  \
    unit_test/scale_test.cc       \
    unit_test/video_common_test.cc

LOCAL_MODULE := libyuv_unittest
include $(BUILD_NATIVE_TEST)
</code></pre>
<h3 id="4-新建-applicationmk">4. 新建 Application.mk</h3>
<p>在 jni 文件夹下，新建 Application.mk 文件，指定架构平台和 Android 版本，内容如下：</p>
<pre><code>APP_ABI := armeabi-v7a arm64-v8a x86 x86_64
APP_PLATFORM := android-18
</code></pre>
<h3 id="5-ndk-build-编译">5. ndk-build 编译</h3>
<p>编译前要确保本机配置好了 NDK 环境变量，如果不知道怎么做请自行百度。</p>
<p>cd 到 jni 文件夹的父级文件夹，然后执行 ndk 相关的命令。每次编译前都要先执行 <code>ndk-build clean</code> 清理缓存，最后执行 <code>ndk-build</code> 编译库，在 jni 父文件夹下就会出现两个文件夹： libs 文件夹下是动态库，obj 文件夹下是静态库。</p>
<figure data-type="image" tabindex="4"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20200104200940.png" alt="ndk-build" loading="lazy"></figure>
<p><strong>参考文章：</strong></p>
<ul>
<li><a href="https://yangandmore.github.io/2019/03/07/libYUV%E7%BC%96%E8%AF%91/">libYUV编译</a></li>
<li><a href="https://github.com/byhook/ffmpeg4android/blob/master/readme/android%E5%85%A8%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91libyuv%E5%BA%93%E5%AE%9E%E7%8E%B0YUV%E5%92%8CRGB%E7%9A%84%E8%BD%AC%E6%8D%A2.md">android全平台编译libyuv库实现YUV和RGB的转换</a></li>
<li><a href="http://www.raomengyang.com/2017/01/15/Android-libyuv%E5%BA%94%E7%94%A8%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89libyuv%E7%9A%84%E4%BD%BF%E7%94%A8/">Android libyuv应用系列（二）libyuv的使用</a></li>
</ul>
]]></content>
    </entry>
</feed>