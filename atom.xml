<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://isuperqiang.cn</id>
    <title>落英坠露</title>
    <updated>2019-12-10T00:22:13.249Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://isuperqiang.cn"/>
    <link rel="self" href="https://isuperqiang.cn/atom.xml"/>
    <subtitle>生活不止眼前的苟且，还有诗和远方的田野。</subtitle>
    <logo>https://isuperqiang.cn/images/avatar.png</logo>
    <icon>https://isuperqiang.cn/favicon.ico</icon>
    <rights>All rights reserved 2019, 落英坠露</rights>
    <entry>
        <title type="html"><![CDATA[深入理解计算机系统之网络编程（一）]]></title>
        <id>https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-wang-luo-bian-cheng-yi</id>
        <link href="https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-wang-luo-bian-cheng-yi">
        </link>
        <updated>2019-11-29T00:20:28.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1-客户端-服务端编程模型">1. 客户端-服务端编程模型</h3>
<p>每个网络应用都是基于客户端-服务器模型。一个应用是由一个服务器进程和一个或者多个客户端进程组成。服务器管理某种资源，并且通过这种资源来为它的客户端提供某种服务。客户端和服务器是进程，而不是常提到的机器或者主机。</p>
<p>客户端-服务器模型中的基本操作是事务。这个事务不是数据库事务，没有数据库事务的任何特性，它仅仅是客户端和服务器执行的一系列步骤。</p>
<figure data-type="image" tabindex="1"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20191209080352.png" alt="客户端-服务器事务"></figure>
<h3 id="2-网络">2. 网络</h3>
<p>对主机而言，网路只是另一种 I/O 设备，是数据源和数据接收方。</p>
<p>网路是一个按照地理远近组成的层次系统，最低层是局域网（LAN），最流行的局域网技术是以太网。</p>
<p>网络协议消除了不同网络之间的差异，使主机和路由器协同工作来实现数据传输，封装是数据传输的关键。</p>
<h3 id="3-全球-ip-因特网">3. 全球 IP 因特网</h3>
<p>客户端-服务器应用的组织一直保持相当的稳定。每台主机都运行实现 TCP/IP 的软件，几乎每个现代<br>
计算机都支持这个协议。客户端和服务器混合使用套接字接口函数和 Unix I/O 函数进行通信。</p>
<p>一个 IP 地址就是一个 32 位无符号整数，使用点分十进制表示法表示。为了方便人们记忆，定义了域名以及将域名映射到 IP 地址的机制。</p>
<p>套接字是连接的端点，套接字地址是由互联网地址和 16 位的整数端口组成的，用「地址：端口」来表示。当客户端发起一个请求时，<br>
客户端套接字地址中的端口是由内核自动分配的，称为临时端口。服务器套接字地址端口通常是某个知名端口，和 这个服务相对应。</p>
<figure data-type="image" tabindex="2"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20191210081750.png" alt="互联网连接分析"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[深入理解计算机系统之系统级IO]]></title>
        <id>https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-xi-tong-ji-io</id>
        <link href="https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-xi-tong-ji-io">
        </link>
        <updated>2019-11-24T13:00:15.000Z</updated>
        <content type="html"><![CDATA[<p>输入/输出(I/O) 是在主存和外部设备之间复制数据的过程。输入操作是从 I/O 设备复制到主存，输出操作是从主存复制到 I/O 设备。</p>
<h3 id="1-unix-io">1. Unix I/O</h3>
<p>一个 Linux 文件就是一个 m 个字节的序列。所有的 I/O 设备都被模型化为文件，所有的输入和输出都被当作相应文件的读和写来执行。这种将设备优雅地映射为文件的方式，允许 Linux 内核引出一个简单、低级的应用接口，称为 Unix I/O。</p>
<h3 id="2-文件">2. 文件</h3>
<p>每个 Linux 文件都有一个类型来表明它在系统中的角色：</p>
<ul>
<li>普通文件包含任意数据。</li>
<li>目录是包含一组链接的文件。</li>
<li>套接字是用来与另一个进程进行跨网络通信的文件。</li>
</ul>
<p>Linux 内核将所有文件都组织称一个目录层次结构，由名为 / 的根目录确定。</p>
<figure data-type="image" tabindex="1"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20191124201916.png" alt="Linux 目录层次结构"></figure>
<p>作为其上下文的一部分，每个进程都有一个当前工作目录，来确定其在目录层次结构中的当前位置。</p>
<h3 id="3-用-rio-包健壮地读写">3. 用 RIO 包健壮地读写</h3>
<p>应用程序不该直接使用 Unix I/O 函数，而应该使用 RIO 包。RIO 包提供了两类不同的函数：无缓冲的输出输出函数和有缓冲的输入函数。RIO 包通过反复执行读写操作，直到传送完所有的请求数据，自动处理不足值。</p>
<h3 id="4-io-重定向">4. I/O 重定向</h3>
<p>Linux shell 提供了 I/O 重定向操作符，允许用户将磁盘文件和标准输入输出联系起来。例如：</p>
<p><code>linux&gt; ls &gt; foo.txt</code>。</p>
<h3 id="5-该使用哪些-io-函数">5. 该使用哪些 I/O 函数</h3>
<p>标准 I/O 库是基于 Unix I/O 实现的，并提供了一组强大的高级 I/O 例程。对于大多数应用程序而言，标准 I/O 更简单，是优于 Unix I/O 的选择。然而，因为 Unix I/O 和网络文件之间有些相互不兼容的限制，Unix I/O 更适合用于网络应用程序。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[深入理解计算机系统之虚拟内存（二）]]></title>
        <id>https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-xu-ni-nei-cun-er</id>
        <link href="https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-xu-ni-nei-cun-er">
        </link>
        <updated>2019-11-22T01:14:46.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1-内存映射">1. 内存映射</h3>
<p>Linux 通过将虚拟内存区域与磁盘上的对象关联起来，来初始化这个虚拟内存区域的内容，这个过程称为内存映射。虚拟内存区域可以映射到两种类型的对象中的一种：</p>
<ul>
<li>Linux 文件系统中的普通文件：磁盘文件的连续部分。</li>
<li>匿名文件：由内核创建，包含的都是二进制零。</li>
</ul>
<p>一旦虚拟页面被初始化，它就在由内核维护的交换空间之间换来换去。在任何时刻，交换空间都限制当前运行的进程能够分配的虚拟页面的总数。</p>
<p>一个对象可以被映射到虚拟内存的一个区域，要么作为共享对象，要么作为私有对象。进程对共享对象映射到的虚拟地址空间的写操作，对把该共享对象映射到它们虚拟内存区域的其他进程也是可见的，并且这些变化反映在磁盘上的对象中。另一方面，对于映射到私有对象的区域的改变，对其他进程来说是不可见的，并且不会反映在磁盘上的对象中。</p>
<p>许多进程有同样的只读代码区域，内存映射可以控制多个进程如何共享对象。即使对象被映射到多个共享区域，物理内存中只需要存放共享对象的一个副本。</p>
<p>私有对象使用写时复制（copy-on-write）的技术被映射到虚拟内存中。和共享对象一样，在物理内存中只保存私有对象的一个副本。当一个进程试图写私有区域内的某个页面时，写操作就会触发一个保护故障。故障处理程序会在物理内存中创建这个页面的新副本，更新页表条目指向新副本，恢复这个页面的写权限。当故障处理程序返回时，CPU 就可以正常执行写操作了。</p>
<h3 id="2-动态内存分配">2. 动态内存分配</h3>
<p>当运行时需要额外虚拟内存时，用动态内存分配器更方便，也有更好的可移植性。</p>
<p>动态内存分配器维护着一个进程的虚拟内存区域，称为堆。分配器将堆视为一组不同大小的块的集合来维护。每个块就是一个连续的虚拟内存片，要么是已分配的，要么是空闲的。</p>
<p>分配器有两种基本风格，两种风格都要求应用显式地分配块，它们的不同之处在于由哪个实体负责释放已分配的块。</p>
<ul>
<li>显式分配器要求应用显式地释放任何已分配的块。例如 C 通过调用 malloc 和 free 分配和释放块。</li>
<li>隐时分配器会自动释放不再使用的已分配的块。例如 Java 的垃圾回收。</li>
</ul>
<p>造成堆利用率很低的主要原因是碎片的现象，当有未使用的内存但不能用来满足分配请求时，就发生这种现象。分配器通常采用试图维持少量的大空闲块，而不是维持大量的小空闲块。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[深入理解计算机系统之虚拟内存（一）]]></title>
        <id>https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-xu-ni-nei-cun-yi</id>
        <link href="https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-xu-ni-nei-cun-yi">
        </link>
        <updated>2019-11-08T14:40:47.000Z</updated>
        <content type="html"><![CDATA[<p>为了更加有效地管理内存并减少出错，现代系统提供了虚拟内存（VM）的概念，它为每个进程提供了一个庞大、一致和私有的地址空间。</p>
<p>虚拟内存提供了三个重要能力：</p>
<ul>
<li>把主存看成一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据</li>
<li>为每个进程提供一致的地址空间，从而简化了内存管理</li>
<li>保护每个进程的地址空间不被其他进程破坏</li>
</ul>
<h3 id="1-物理和虚拟寻址">1. 物理和虚拟寻址</h3>
<p>早起的 PC 使用物理寻址，现代处理器使用虚拟寻址。虚拟寻址的方式需要内存管理单元（MMU）将虚拟地址转换为物理地址。</p>
<figure data-type="image" tabindex="1"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20191106085329.png" alt="物理寻址"></figure>
<figure data-type="image" tabindex="2"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20191106085354.png" alt="虚拟寻址"></figure>
<h3 id="2-地址空间">2. 地址空间</h3>
<p>地址空间是一个非负整数地址的有序集合。如果地址空间中的整数是连续的，那么它就是线性地址空间。</p>
<p>在带有虚拟内存的系统中，CPU 从含有 N=2^n 个地址的地址空间中生成虚拟地址，称为虚拟地址空间。</p>
<p>系统还有一个物理地址空间，对应物理内存的 M 个字节。</p>
<p>地址空间清楚地区分了数据对象（字节）和它们的属性（地址）。允许每个对象有多个独立的地址，其中每个地址都选自不同的地址空间，这就是虚拟内存的基本思想。主存中的每个字节都有一个来自虚拟地址空间的虚拟地址和来自物理地址空间的物理地址。</p>
<h3 id="3-虚拟内存作为缓存的工具">3. 虚拟内存作为缓存的工具</h3>
<p>虚拟内存被组织为一个由存放在磁盘上的 N 个连续的字节大小的单元组成的数组。每个字节都有一个唯一的虚拟地址，作为到数组的索引。磁盘上数组的内容被缓存在主存中。</p>
<p>虚拟内存被分割为称作虚拟页（VP）的大小固定块，来作为磁盘和主存之间的传输单元。类似地，物理内存被分割为物理页。在任意时刻，虚拟页面的集合都分为三个不相交的子集：未分配的、缓存的、未缓存的。</p>
<p>页表（page table）将虚拟页映射到物理页。每次 MMU（内存管理单元）中的地址翻译硬件将虚拟地址转换为物理地址时，都会读取页表。<br>
操作系统负责维护页表的内容，以及在磁盘与 DRAM 之间来回传送页。</p>
<figure data-type="image" tabindex="3"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20191115220042.png" alt="页表"></figure>
<p>页表就是一个页表条目（PTE）的数组。虚拟地址空间中的每个页在页表中一个固定偏移量处都有一个 PTE。</p>
<p>DRAM 缓存不命中称为缺页（page fault）。缺页会触发缺页异常，该异常调用缺页异常处理程序，该程序会选择一个牺牲页，<br>
内核总会修改牺牲页的页表条目，牺牲页就不再缓存在主存中。当异常处理程序返回时，它会重新启动导致缺页的指令，<br>
该指令会把导致缺页的虚拟地址发送到地址翻译硬件，页命中就能由地址翻译硬件正常处理了。</p>
<p>在磁盘和内存之间传送页的活动叫做交换（swapping）或者页面调度（paging）。页从磁盘换入 DRAM 和 从 DRAM 换出磁盘。<br>
当有不命中发生时才换入页面的策略叫做按需页面调度（demand paging）。所有现在操作系统都是用按需页面调度的方式。</p>
<p>尽管在整个运行过程中程序引用的不同页面的总数可能超出物理内存总的大小，但是局部性原理保证了在任意时刻，<br>
程序将趋于在一个较小的活动页面（active page）集合上工作，这个集合叫做工作集合。</p>
<p>如果工作集的大小超出了物理内存的大小，那么程序将产生一种不幸的状态，叫做抖动（thrashing），这时页面将不断地换进换出。</p>
<h3 id="4-虚拟内存作为内存管理的工具">4. 虚拟内存作为内存管理的工具</h3>
<p>实际上，操作系统为每个进程提供了一个独立的页表，也就是一个独立的虚拟地址空间。注意，多个虚拟页面可以映射到同一个共享的物理页面上。</p>
<figure data-type="image" tabindex="4"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20191115221725.png" alt="内存管理"></figure>
<h3 id="5-虚拟存在作为内存保护的工具">5. 虚拟存在作为内存保护的工具</h3>
<p>提供独立的地址空间使得区分不同进程的私有内存变得容易。地址翻译机制可以通过一种自然的方式扩展到提供更好的访问控制。CPU 每次生成一个地址时，地址翻译硬件都会读一个 PTE。所以可以通过在 PTE 上添加一些额外的许可位来控制一个虚拟页面内容的访问。</p>
<figure data-type="image" tabindex="5"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20191115222808.png" alt="内存保护"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[深入理解计算机系统之异常控制流（二）]]></title>
        <id>https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-yi-chang-kong-zhi-liu-er</id>
        <link href="https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-yi-chang-kong-zhi-liu-er">
        </link>
        <updated>2019-11-03T09:30:36.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1-进程控制">1. 进程控制</h3>
<p>每个进程都有一个唯一的正数进程 ID(PID)。</p>
<p>从程序员的角度，可以认为进程总是处于下面三种状态之一：</p>
<ul>
<li>运行。进程要么在执行，要么等待被执行。</li>
<li>停止。进程的执行被挂起，且不会被调度。</li>
<li>终止。进程永远地停止了。</li>
</ul>
<p>父进程通过 fork 函数创建一个新运行的子进程，新创建的子进程几乎但不完全与父进程相同，它们之间的最大区别是有不同的 PID。</p>
<p>当一个进程由于某种原因终止时，进程保持一种终止的状态，直到被它的父进程回收。</p>
<p>execve 函数在当前进程的上下文中加载并运行一个新程序。</p>
<h3 id="2-信号">2. 信号</h3>
<p>一个信号就是一条消息，它通知进程系统中发生某种类型的事件。</p>
<p>传递一个信号到目的进程是由两个步骤组成的：</p>
<ul>
<li>发送信号：内核通过更新目的进程上下文中的某个状态，发送一个信号给目的进程。</li>
<li>接收信号：当目的进程被内核强迫以某种方式对信号的发送做出反应时，它就接收了信号。</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20191103170627.png" alt="信号处理"></figure>
<p>Unix 系统提供了大量的进程发送信号机制，这些机制都是基于进程组这个概念。每个进程只属于一个进程组，<br>
进程组由一个正整数 ID 标识。默认地，子进程和它的父进程属于同一个进程组。</p>
<p>当内核把进程 p 从内核模式切换到用户模式时，它会检查进程 p 的未被阻塞的待处理信号集合，如果集合为空，那么内核将控制传递到 p 的逻辑控制流的下一条指令。如果集合非空，那么内核选择集合中的某个信号 k，并且强制 p 接收 k。收到这个信号会触发进程采取某种行为。一旦进程完成了这个行为，那么控制就传递回 p 的逻辑控制流的下一条指令。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[深入理解计算机系统之异常控制流（一）]]></title>
        <id>https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-yi-chang-kong-zhi-liu-yi</id>
        <link href="https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-yi-chang-kong-zhi-liu-yi">
        </link>
        <updated>2019-10-27T13:14:43.000Z</updated>
        <content type="html"><![CDATA[<p>指令1，指令性2，指令3……，这样的控制转移序列就是处理器的控制流（control flow）。</p>
<p>现代系统通过使控制流发生突变，来应对系统状态的变化，称为异常控制流（ECF），它发生在计算机系统的各个层次。</p>
<p>ECF 的重要性：</p>
<ul>
<li>ECF 是操作系统实现 I/O、进程和虚拟内存的基本机制。</li>
<li>应用程序通过使用系统调用的 ECF 形式，来向操作系统请求服务。</li>
<li>操作系统为应用程序提供了强大的 ECF 机制，用来创建新进程、等待进程终止、通知其他进程中的异常事件。</li>
<li>ECF 是计算机系统中实现并发的基本机制，比如中断应用程序执行的异常处理程序。</li>
<li>非本地跳转是一种应用层 ECF，软件异常允许程序进行非本地跳转来响应错误情况。</li>
</ul>
<h3 id="1-异常">1. 异常</h3>
<p>异常就是控制流中的突变，用来响应处理器状态中的某些变化。它一部分由硬件实现，一部分由操作系统实现。</p>
<figure data-type="image" tabindex="1"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20191026212833.png" alt="异常的剖析"></figure>
<p>在任何情况下，当处理器检测到有事件发生时，就会通过一张叫做「异常表」的跳转表，进行一个间接过程调用，交给异常处理程序去处理。<br>
当处理完成后，根据引起异常事件的类型，发生以下 3 种情况中的一种：</p>
<ul>
<li>处理程序将控制返回给当前指令。</li>
<li>处理程序将控制返回给下一条指令。</li>
<li>处理程序终止被中断的程序。</li>
</ul>
<p>异常可以分为四类：</p>
<ul>
<li>中断：来自外部 I/O 设备信号的结果，不是由专门的指令造成的。</li>
<li>陷阱：最重要的用途是在用户程序和内核之间提供一个接口——系统调用。</li>
<li>故障：由错误情况引起，可能被故障处理程序修正，比如缺页异常。</li>
<li>终止：不可恢复的致命错误造成的结果，通常是一些硬件错误。</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20191026213802.png" alt="异常的类别"></figure>
<h3 id="2-进程">2. 进程</h3>
<p>进程就是一个正在执行的程序实例，系统中的每个程序都运行在某个进程的上下文（context）中。</p>
<p>进程提供给应用程序的关键抽象：</p>
<ul>
<li>一个独立的逻辑控制流，它提供一个假象，好像程序独占地使用处理器。</li>
<li>一个私有的地址空间，它提供一个假象，好像程序独占地使用内存系统。</li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20191027200254.png" alt="进程控制流"></figure>
<p>进程是轮流使用处理器的，每个进程执行它的流的一部分，然后被抢占（暂时挂起），然后轮到其他进程。</p>
<p>进程为每个程序提供它自己私有地址空间。一般而言，和某个地址关联的内存字节是不能被其他进程读或写的。每个私有地址空间都有相同的通用结构。</p>
<figure data-type="image" tabindex="4"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20191027201327.png" alt="x86-64 linux 进程地址空间"></figure>
<p>处理器通常是用某个控制寄存器中的一个模式位，来实现限制应用可以执行的指令以及可以访问的地址空间。</p>
<p>当设置了模式位时，进程就运行在内核模式中，它可以执行指令集中的任何指令，并且可以访问系统中的任何内存位置。没有设置模式位时，进行就运行在用户模式中，不允许执行特权指令，也不允许直接引用地址空间中内核区的代码和数据。</p>
<p>运行应用程序代码的进程起初是在用户模式中的，进程从用户模式变为内核模式的唯一方法就是通过中断、故障或者陷入系统调用这样的异常。</p>
<p>操作系统内核使用一种称为「上下文切换」的异常控制流来实现多任务。内核为每个进程维持一个上下文。上下文就是内核重新启动一个被抢占的进程所需的状态。这些状态包括：通用目的寄存器、程序计数器、用户栈、环境变量等。</p>
<p>上下文切换的过程：</p>
<ul>
<li>保存当前进程的上下文</li>
<li>恢复某个先前被抢占的进程保存的上下文</li>
<li>将控制传递给这个刚恢复的进程</li>
</ul>
<p>当执行系统调用或者中断时，都可能会发生上下文切换。</p>
<figure data-type="image" tabindex="5"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20191027202847.png" alt="进程上下文切换"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[深入理解计算机系统之存储器层次结构]]></title>
        <id>https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-cun-chu-qi-ceng-ci-jie-gou</id>
        <link href="https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-cun-chu-qi-ceng-ci-jie-gou">
        </link>
        <updated>2019-10-20T07:47:51.000Z</updated>
        <content type="html"><![CDATA[<h3 id="61-存储技术">6.1 存储技术</h3>
<p>这一节主要讲述存储技术的发展，从 SRAM、DRAM、ROM 再到硬盘。</p>
<p>随机访问存储器（RAM），分为静态 RAM 和动态 RAM，前者比后者更快，但也贵得多。SRAM 应用于高速缓存，DRAM 应用于主存和帧缓冲区。</p>
<p>高速缓存存储器作为 CPU 和主存之间的缓存区域，对应用程序性能的影响最大。现代计算机频繁使用基于 SRAM 的高速缓存，试图弥补处理器和内存之间的差距。</p>
<p>数据流通过总线（bus）在 CPU 和主存之间传递，总线携带地址、数据和控制信号。</p>
<figure data-type="image" tabindex="1"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20191020101259.png" alt="连接 CPU 和主存的总线"></figure>
<p>像显示器、鼠标、键盘这样的 I/O 设备，都是通过 I/O 总线连接到 CPU 和主存的。I/O 总线比系统和内存总线慢，但可以容纳多种第三方 I/O 设备。</p>
<figure data-type="image" tabindex="2"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20191020101728.png" alt="总线结构图"></figure>
<p>CPU 使用内存映射的技术向 I/O 设备发出命令，地址空间有一块是为 I/O 设备通信保留的 I/O 端口。</p>
<h3 id="62-局部性原理">6.2 局部性原理</h3>
<p>程序倾向于引用最近引用过的数据项，或者与最近引用过的数据项邻近的数据项。</p>
<p>局部性有两种表现形式：时间局部性和空间局部性。有着良好局部性的程序比局部性差的程序运行得更快。</p>
<p>对于一个循环求数组元素之和的函数，结果 sum 每次循环都被引用，具有良好的时间局部性。而数组按顺序迭代，具有良好的空间局部性。<br>
而对于多维数组，步长会影响程序的空间局部性。</p>
<p>评价程序中局部性的一些简单原则：</p>
<ul>
<li>重复引用相同变量的程序具有良好的时间局部性。</li>
<li>对于具有步长的引用模式的程序，步长越小，空间局部性越好。在内存中以大步长跳来跳去的程序，空间局部性会很差。</li>
<li>对于取指令来说，循环具有好的时间和空间局部性。循环体越小，迭次次数越多，局部性越好。</li>
</ul>
<h3 id="63-存储器的层次结构">6.3 存储器的层次结构</h3>
<figure data-type="image" tabindex="3"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20191020152557.png" alt="存储器层次结构"></figure>
<p>一般而言，从高层到底层，存储设备变得更慢、更便宜和更大容量。</p>
<p>存储器层次结构的本质是：每一层存储设备都是较低一层的缓存。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[深入理解计算机系统之程序的机器级表示（二）]]></title>
        <id>https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-cheng-xu-de-ji-qi-ji-biao-shi-er</id>
        <link href="https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-cheng-xu-de-ji-qi-ji-biao-shi-er">
        </link>
        <updated>2019-10-13T06:07:47.000Z</updated>
        <content type="html"><![CDATA[<h3 id="过程">过程</h3>
<p>过程提供了一种封装代码的方式，用一组指定的参数和一个可选的返回值实现某种功能。形式有函数、方法、子例程等。</p>
<p>C 语言使用栈提供的后进先出的内存管理原则。栈和程序寄存器存放着传递控制和数据、分配内存需要的信息。</p>
<p>当 Q 执行时，P 及 P 以上的函数调研暂时被挂起，需要为局部变量分配存储空间，或者设置另一个过程调用。当 Q 返回时，它分配的局部存储空间都会被释放。P 的返回地址也被压入栈中，表示在 Q 返回时，从 P 的返回地址继续执行。</p>
<p>大多数过程间数据传送通过寄存器实现，寄存器最多传递 6 个整型参数，超过 6 个的部分要通过栈来传递。</p>
<figure data-type="image" tabindex="1"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/20191014070514.png" alt="栈帧结构"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每周 ARTS 第 25 期]]></title>
        <id>https://isuperqiang.cn/post/mei-zhou-arts-di-25-qi</id>
        <link href="https://isuperqiang.cn/post/mei-zhou-arts-di-25-qi">
        </link>
        <updated>2019-09-28T11:54:01.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-algorithm">1. Algorithm</h2>
<h3 id="22-递增的三元子序列中等">22. 递增的三元子序列（中等）</h3>
<h5 id="描述">描述：</h5>
<blockquote>
<p>给定一个未排序的数组，判断这个数组中是否存在长度为 3 的递增子序列。</p>
<p>数学表达式如下:</p>
<p>如果存在这样的 i, j, k,  且满足 0 ≤ i &lt; j &lt; k ≤ n-1，<br>
使得 arr[i] &lt; arr[j] &lt; arr[k] ，返回 true ; 否则返回 false 。</p>
</blockquote>
<h5 id="示例">示例：</h5>
<pre><code>输入: [1,2,3,4,5]
输出: true
输入: [5,4,3,2,1]
输出: false
</code></pre>
<h5 id="思路">思路：</h5>
<p><strong>双指针</strong></p>
<p>定义 min 为序列中的较小值，mid 为中间值，看是否能找到较大值。</p>
<pre><code class="language-java">class Sulution {
    public boolean increasingTriplet(int[] nums) {
        if (nums == null || nums.length &lt; 3) {
            return false;
        }

        int min = Integer.MAX_VALUE;
        int mid = Integer.MAX_VALUE;
        for (int num : nums) {
            if (num &lt;= min) {
                min = num;
            } else if (num &lt;= mid) {
                mid = num;
            } else {
                return true;
            }
        }
        return false;    
    }
}
</code></pre>
<h5 id="分析">分析：</h5>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h2 id="2-review">2. Review</h2>
<p><a href="https://skorks.com/2011/02/the-greatest-developer-fallacy-or-the-wisest-words-youll-ever-hear/">The Greatest Developer Fallacy Or The Wisest Words You’ll Ever Hear?</a> 你听过最伟大开发者的谬误还是最明智的话？</p>
<p>作者从 “I will learn it when I need it” 开始谈起，列举了一些自己的观点。</p>
<ul>
<li>投资你的未来，而不是需要的时候才学习，渴望比知识更重要。</li>
<li>你不知道你不知道的知识，你不去学习它，是因为你根本不知道它的存在。</li>
<li>广度是深度的副作用，在一个领域成为专家，其他领域也顺便了解。</li>
<li>和大牛交朋友，从他们那里学到东西。</li>
</ul>
<h2 id="3-tip">3. Tip</h2>
<p>分享一个搜索引擎 —— <a href="https://www.dogedoge.com/">多吉搜索</a>，它的宗旨是不追踪，不误导，称得上是国内的 duckduckgo。界面清爽，简单纯粹，搜索质量比百度高 100 倍。如果你不能愉快地访问谷歌，那么多吉搜索是不错的选择。😃</p>
<h2 id="4-share">4. Share</h2>
<p>最近由于国庆，SS 服务被阻隔了，无法访问谷歌，对开发很不方便。互联网本该自由，何必构筑高墙，遮蔽众人耳目，自欺欺人呢？</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[深入理解计算机系统之程序的机器级表示（一）]]></title>
        <id>https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-cheng-xu-de-ji-qi-ji-biao-shi-yi</id>
        <link href="https://isuperqiang.cn/post/shen-ru-li-jie-ji-suan-ji-xi-tong-zhi-cheng-xu-de-ji-qi-ji-biao-shi-yi">
        </link>
        <updated>2019-09-23T12:45:49.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1-概述">1. 概述</h3>
<p>计算机执行机器代码，用字节序列编码低级的操作，包括处理数据、管理内存、读写存储设备上的数据，以及利用网络通信。编译器基于编程语言的规则、目标机器的指令集和操作系统遵循的惯例，经过一系列的阶段生成机器代码。GCC C 语言编译器以汇编代码的形式产生输出，汇编代码是机器代码的文本表示，给出程序中的每一条指令。然后 GCC 调用汇编器和链接器，根据汇编代码生成可执行的机器代码。</p>
<h3 id="2-程序编码">2. 程序编码</h3>
<p>计算机系统使用多种抽象模型来隐藏实现的细节。对于机器级编程来说，有两种抽象尤为重要。</p>
<ul>
<li>第一种是由指令集架构（Instruction Set Architecture, ISA）来定义机器级程序的格式和行为，它定义了处理器状态、指令的格式，以及每条指令对状态的影响。</li>
<li>第二种抽象是，机器级程序使用的内存地址是虚拟地址，提供的内存模型看上去是一个非常大的字节数组。存储器系统的实际实现是将多个硬件存储器和操作系统软件组合起来。</li>
</ul>
<p>在编译过程中，编译器把用 C 语言提供的相对比较抽象的执行模型表示的程序，转化为处理器执行的非常基本的指令。汇编代码表示非常接近于机器代码。与机器代码的二进制格式相比，汇编代码的主要特点是它用可读性更好的文本格式表示。</p>
<p>程序内存包含：程序的可执行机器代码、操作系统需要的一些信息、用来管理过程调用和返回的运行时栈，以及用户分配的内存块。程序内存用虚拟地址来寻址，在任意给定的时刻，只有一部分虚拟地址被认为是合法的。操作系统负责管理虚拟地址空间，将虚拟地址翻译为实际处理器内存中的物理地址。</p>
<p>一条机器指令只执行一个非常基本的操作。机器执行的程序只是一个字节序列，它是对一系列指令的编码。机器对产生这些指令对源代码几乎一无所知。</p>
<figure data-type="image" tabindex="1"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/Jietu20190222-072526@2x.jpg" alt="机器代码与汇编代码"></figure>
<p>生成实际可执行的代码需要对一组目标代码文件运行链接器，而这一组目标代码文件必须含有一个 main 函数。上图中，<code>callq</code> 指令调用函数 <code>muil2</code> 需要使用地址，链接器的任务之一就是为函数调用找到匹配的函数的可执行的代码的位置。最后的两行 <code>nop</code> 对程序没有影响，插入这些指令的目的是为了使代码变为 16 字节，使得存储器系统更好地放置下一个代码块。</p>
<h3 id="3-数据格式">3. 数据格式</h3>
<figure data-type="image" tabindex="2"><img src="https://richie-storage.oss-cn-hangzhou.aliyuncs.com/img/Jietu20190222-073010@2x.jpg" alt="C语言数据类型"></figure>
]]></content>
    </entry>
</feed>